# -*- coding: UTF-8 -*-
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=UTF-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw ncException

        """
        pass

    def get_all_jobs(self):
        """
        获取所有任务

        @return 任务对象列表

        """
        pass

    def get_all_jobs_for_ams(self):
        """
        获取所有任务,用来推送给AMS

        @return 任务对象列表

        """
        pass

    def get_task_log_message_by_id(self, instanceId):
        """
        获取任务执行记录，用来与AMS消息推送

        @return 任务执行记录

        Parameters:
         - instanceId

        """
        pass

    def get_jobs_log_for_ams(self):
        """
        获取任务执行记录,用来推送给AMS

        @return 任务对象列表

        """
        pass

    def get_job_info_by_id(self, jobId):
        """
        根据jobId获取任务信息,用来推送给AMS

        @return 任务对象列表

        Parameters:
         - jobId

        """
        pass

    def get_all_clean_jobs(self):
        """
        获取当前所有的数据请管理任务，用来与AMS消息推送

        @return 数据清理任务

        """
        pass

    def get_job(self, jobId):
        """
        获取一个任务

        @return 任务对象

        Parameters:
         - jobId

        """
        pass

    def update_jobs_nstart_time(self, jobs_params):
        """
        更新任务的下次运行时间

        Parameters:
         - jobs_params

        """
        pass

    def get_jobs_like_for_schedule(self, jobName, clientIds):
        """
        获取任务列表

        @return 任务对象列表

        Parameters:
         - jobName
         - clientIds

        """
        pass

    def get_jobs_for_schedule_by_ids(self, jobIds):
        """
        根据id组获取job
        @return
        @throw ncException

        Parameters:
         - jobIds

        """
        pass

    def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        """
        发起任务

        oneway接口(可阅读Thrift关于这方面的规范), 不会阻塞调用者

        @return void

        Parameters:
         - jobId
         - customer
         - backupType
         - desc
         - is_auto_execute
         - nstart_time
         - strategy_id

        """
        pass

    def get_support_backup_type(self, job_id):
        """
        获取某任务支持的类型

        Parameters:
         - job_id

        """
        pass

    def get_jobs_by_instance_name(self, instance_name):
        """
        根据实例名获取任务列表

        Parameters:
         - instance_name

        """
        pass

    def get_jobs_by_fpguid(self, fpGuid):
        """
        根据指纹库GUID获取关联任务信息

        @param fpGuid : 指纹库GUID
        @return
        @throw ncException

        Parameters:
         - fpGuid

        """
        pass

    def client_exsit_job(self, clientId):
        """
        Parameters:
         - clientId

        """
        pass

    def get_jobs_by_cloud_storage_id(self, cloud_storage_id):
        """
        Parameters:
         - cloud_storage_id

        """
        pass

    def get_db_job_instances(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_db_job_mappings(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_contentcloud_datasource_job_names(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_jobs_by_filter(self, filter_request):
        """
        根据一组条件, 获取一组任务

        建议: 向BS获取任务信息时, 只使用这个接口即可, 无论是获取一个还是多个

        Parameters:
         - filter_request

        """
        pass

    def get_cloud_backup_jobs(self, query_all):
        """
        获取云服务任务

        Parameters:
         - query_all

        """
        pass

    def update_jobs(self, requests):
        """
            更新一批任务

            job_ids与nc_update_requests的长度必须一致( 以短的那个为准)
            根据thrift的特性, 声明为oneway的接口是不会阻塞调用者的. 也不会抛异常给调用者
        *

        Parameters:
         - requests

        """
        pass

    def update_data_sources(self, request):
        """
        更新任务的数据源

        Parameters:
         - request

        """
        pass

    def remove_all_jobs_by_client_ids(self, clientIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - clientIds

        """
        pass

    def get_datasource_jobs(self, request):
        """
        获取某一数据源映射的任务列表

        Parameters:
         - request

        """
        pass

    def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - vplatformIds

        """
        pass

    def remove_all_jobs_by_backup_media_and_username(self, usernames, cloud_storage_name):
        """
        批量删除任务 根据备份介质名字和用户


        Parameters:
         - usernames
         - cloud_storage_name

        """
        pass

    def remove_all_jobs_by_contentcloud_resources(self, contentcloud_resource_ids):
        """
        Parameters:
         - contentcloud_resource_ids

        """
        pass

    def get_datasource_by_client(self, client_id, job_is_backup):
        """
        获取任务列表

        @return 任务对象列表

        Parameters:
         - client_id
         - job_is_backup

        """
        pass

    def add_schedule_jobs(self, ids):
        """
        Parameters:
         - ids

        """
        pass

    def modify_schedule_jobs(self, ids):
        """
        Parameters:
         - ids

        """
        pass

    def get_schedule_jobs(self):
        pass

    def online_reload(self, ip):
        """
        Parameters:
         - ip

        """
        pass

    def offline_reload(self, ip):
        """
        Parameters:
         - ip

        """
        pass

    def migrate_node_vibration(self, ip_to_state):
        """
        Parameters:
         - ip_to_state

        """
        pass

    def app_ctrl_push(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        pass

    def is_exists_running_job_on_client(self, clientId):
        """
        *  客户端上是否存在正则运行的任务
           @ return True:存在正在运行的任务, False： 不存在正在运行的任务
        *

        Parameters:
         - clientId

        """
        pass

    def client_exsit_volume_job(self, clientId):
        """
        Parameters:
         - clientId

        """
        pass

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        pass

    def get_jobs_status_by_contentcloud_resources(self, ids):
        """
        检测contentcloud资源是否有正在运行的任务


        Parameters:
         - ids

        """
        pass

    def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        """
        生产资源类型  sourceType
        服务类型     svcType
        生产资源标识  sourceId
        @ return


        Parameters:
         - sourceType
         - svcType
         - sourceId
         - relation

        """
        pass

    def GetKeyMaterial(self, KeyId, DeviceId):
        """
        获取kms密钥

        Parameters:
         - KeyId
         - DeviceId

        """
        pass

    def get_dict_export(self, body, jobInstanceId, user):
        """
        Parameters:
         - body
         - jobInstanceId
         - user

        """
        pass

    def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        """
        数据源       datasource
        客户端ID     clientId
        数据源的用户名(适用于多用户场景)   dbRunUserName
        @ return


        Parameters:
         - datasource
         - clientId
         - dbRunUserName

        """
        pass

    def get_backup_jobs_by_node_ip(self, node_ip):
        """
        获取该节点ip上是否拥有备份任务
        return result
        @throw ncException

        Parameters:
         - node_ip

        """
        pass

    def get_backup_jobs_by_volume_id(self, volume_id):
        """
        获取该卷下是否拥有文件备份任务
        return result
        @throw ncException

        Parameters:
         - volume_id

        """
        pass

    def get_permanent_increment_job(self):
        """
        获取永久增量备份任务列表
        (临时给创建归档任务时判断使用的, 当前不支持对开启了永久增量备份任务进行归档。但只能限制本地备份任务,
        远程复制与反向复制无法限制, 相当于只限制了一部分, 但还是要求要这样处理。)

        """
        pass

    def check_user_has_data(self, user_list):
        """
        检查指定用户名列表中的用户是否有备份任务
        return 存在任务的用户名列表
        @throw ncException

        Parameters:
         - user_list

        """
        pass

    def get_job_count_info(self, startTime, userId):
        """
        获取任务状态数据
        return result
        @throw ncException

        Parameters:
         - startTime
         - userId

        """
        pass

    def get_strategy_export(self, strategy_ids, user_name):
        """
        策略计划导出
        return result
        @throw ncException

        Parameters:
         - strategy_ids
         - user_name

        """
        pass

    def get_deleted_backup_jobs(self):
        """
        获取已删除的备份任务信息(专供归档服务调用, 当前归档的数据源查询要求必须对已删除的任务做区分, 如果是已删除的任务则加个创建时间区分)
        return {jobId: createTime}

        """
        pass

    def remove_all_jobs_by_cloud_storage_name_and_username(self, usernames, cloud_storage_name):
        """
        批量删除任务 根据云存储名称和用户名


        Parameters:
         - usernames
         - cloud_storage_name

        """
        pass

    def delete_extra_resource_by_username(self, user_names):
        """
        通过用户名称删除其附属的策略及数据保留策略
        @ return


        Parameters:
         - user_names

        """
        pass

    def get_sub_using_num(self, sub_license_types):
        """
        正在运行任务的UNIX客户端数量


        Parameters:
         - sub_license_types

        """
        pass

    def get_all_jobs_by_pages(self, BaseReq):
        """
        分页获取指定用户下的备份任务
        @return list<ncJob.ncTJob>任务对象列表


        Parameters:
         - BaseReq

        """
        pass

    def get_task_src_from_DB_InBackup(self, job_id):
        """
        获取数据库中的任务的数据源
        @ return list<string>


        Parameters:
         - job_id

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw ncException

        """
        self.send_microprobe()
        self.recv_microprobe()

    def send_microprobe(self):
        self._oprot.writeMessageBegin('microprobe', TMessageType.CALL, self._seqid)
        args = microprobe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_microprobe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = microprobe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_all_jobs(self):
        """
        获取所有任务

        @return 任务对象列表

        """
        self.send_get_all_jobs()
        return self.recv_get_all_jobs()

    def send_get_all_jobs(self):
        self._oprot.writeMessageBegin('get_all_jobs', TMessageType.CALL, self._seqid)
        args = get_all_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs failed: unknown result")

    def get_all_jobs_for_ams(self):
        """
        获取所有任务,用来推送给AMS

        @return 任务对象列表

        """
        self.send_get_all_jobs_for_ams()
        return self.recv_get_all_jobs_for_ams()

    def send_get_all_jobs_for_ams(self):
        self._oprot.writeMessageBegin('get_all_jobs_for_ams', TMessageType.CALL, self._seqid)
        args = get_all_jobs_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_jobs_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_jobs_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs_for_ams failed: unknown result")

    def get_task_log_message_by_id(self, instanceId):
        """
        获取任务执行记录，用来与AMS消息推送

        @return 任务执行记录

        Parameters:
         - instanceId

        """
        self.send_get_task_log_message_by_id(instanceId)
        return self.recv_get_task_log_message_by_id()

    def send_get_task_log_message_by_id(self, instanceId):
        self._oprot.writeMessageBegin('get_task_log_message_by_id', TMessageType.CALL, self._seqid)
        args = get_task_log_message_by_id_args()
        args.instanceId = instanceId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_task_log_message_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_task_log_message_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_task_log_message_by_id failed: unknown result")

    def get_jobs_log_for_ams(self):
        """
        获取任务执行记录,用来推送给AMS

        @return 任务对象列表

        """
        self.send_get_jobs_log_for_ams()
        return self.recv_get_jobs_log_for_ams()

    def send_get_jobs_log_for_ams(self):
        self._oprot.writeMessageBegin('get_jobs_log_for_ams', TMessageType.CALL, self._seqid)
        args = get_jobs_log_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_log_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_log_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_log_for_ams failed: unknown result")

    def get_job_info_by_id(self, jobId):
        """
        根据jobId获取任务信息,用来推送给AMS

        @return 任务对象列表

        Parameters:
         - jobId

        """
        self.send_get_job_info_by_id(jobId)
        return self.recv_get_job_info_by_id()

    def send_get_job_info_by_id(self, jobId):
        self._oprot.writeMessageBegin('get_job_info_by_id', TMessageType.CALL, self._seqid)
        args = get_job_info_by_id_args()
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_job_info_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_job_info_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job_info_by_id failed: unknown result")

    def get_all_clean_jobs(self):
        """
        获取当前所有的数据请管理任务，用来与AMS消息推送

        @return 数据清理任务

        """
        self.send_get_all_clean_jobs()
        return self.recv_get_all_clean_jobs()

    def send_get_all_clean_jobs(self):
        self._oprot.writeMessageBegin('get_all_clean_jobs', TMessageType.CALL, self._seqid)
        args = get_all_clean_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_clean_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_clean_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_clean_jobs failed: unknown result")

    def get_job(self, jobId):
        """
        获取一个任务

        @return 任务对象

        Parameters:
         - jobId

        """
        self.send_get_job(jobId)
        return self.recv_get_job()

    def send_get_job(self, jobId):
        self._oprot.writeMessageBegin('get_job', TMessageType.CALL, self._seqid)
        args = get_job_args()
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job failed: unknown result")

    def update_jobs_nstart_time(self, jobs_params):
        """
        更新任务的下次运行时间

        Parameters:
         - jobs_params

        """
        self.send_update_jobs_nstart_time(jobs_params)
        self.recv_update_jobs_nstart_time()

    def send_update_jobs_nstart_time(self, jobs_params):
        self._oprot.writeMessageBegin('update_jobs_nstart_time', TMessageType.CALL, self._seqid)
        args = update_jobs_nstart_time_args()
        args.jobs_params = jobs_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_jobs_nstart_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_jobs_nstart_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_jobs_like_for_schedule(self, jobName, clientIds):
        """
        获取任务列表

        @return 任务对象列表

        Parameters:
         - jobName
         - clientIds

        """
        self.send_get_jobs_like_for_schedule(jobName, clientIds)
        return self.recv_get_jobs_like_for_schedule()

    def send_get_jobs_like_for_schedule(self, jobName, clientIds):
        self._oprot.writeMessageBegin('get_jobs_like_for_schedule', TMessageType.CALL, self._seqid)
        args = get_jobs_like_for_schedule_args()
        args.jobName = jobName
        args.clientIds = clientIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_like_for_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_like_for_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_like_for_schedule failed: unknown result")

    def get_jobs_for_schedule_by_ids(self, jobIds):
        """
        根据id组获取job
        @return
        @throw ncException

        Parameters:
         - jobIds

        """
        self.send_get_jobs_for_schedule_by_ids(jobIds)
        return self.recv_get_jobs_for_schedule_by_ids()

    def send_get_jobs_for_schedule_by_ids(self, jobIds):
        self._oprot.writeMessageBegin('get_jobs_for_schedule_by_ids', TMessageType.CALL, self._seqid)
        args = get_jobs_for_schedule_by_ids_args()
        args.jobIds = jobIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_for_schedule_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_for_schedule_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_for_schedule_by_ids failed: unknown result")

    def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        """
        发起任务

        oneway接口(可阅读Thrift关于这方面的规范), 不会阻塞调用者

        @return void

        Parameters:
         - jobId
         - customer
         - backupType
         - desc
         - is_auto_execute
         - nstart_time
         - strategy_id

        """
        self.send_commit_job(jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id)
        self.recv_commit_job()

    def send_commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        self._oprot.writeMessageBegin('commit_job', TMessageType.CALL, self._seqid)
        args = commit_job_args()
        args.jobId = jobId
        args.customer = customer
        args.backupType = backupType
        args.desc = desc
        args.is_auto_execute = is_auto_execute
        args.nstart_time = nstart_time
        args.strategy_id = strategy_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_support_backup_type(self, job_id):
        """
        获取某任务支持的类型

        Parameters:
         - job_id

        """
        self.send_get_support_backup_type(job_id)
        return self.recv_get_support_backup_type()

    def send_get_support_backup_type(self, job_id):
        self._oprot.writeMessageBegin('get_support_backup_type', TMessageType.CALL, self._seqid)
        args = get_support_backup_type_args()
        args.job_id = job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_support_backup_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_support_backup_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_support_backup_type failed: unknown result")

    def get_jobs_by_instance_name(self, instance_name):
        """
        根据实例名获取任务列表

        Parameters:
         - instance_name

        """
        self.send_get_jobs_by_instance_name(instance_name)
        return self.recv_get_jobs_by_instance_name()

    def send_get_jobs_by_instance_name(self, instance_name):
        self._oprot.writeMessageBegin('get_jobs_by_instance_name', TMessageType.CALL, self._seqid)
        args = get_jobs_by_instance_name_args()
        args.instance_name = instance_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_instance_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_instance_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_instance_name failed: unknown result")

    def get_jobs_by_fpguid(self, fpGuid):
        """
        根据指纹库GUID获取关联任务信息

        @param fpGuid : 指纹库GUID
        @return
        @throw ncException

        Parameters:
         - fpGuid

        """
        self.send_get_jobs_by_fpguid(fpGuid)
        return self.recv_get_jobs_by_fpguid()

    def send_get_jobs_by_fpguid(self, fpGuid):
        self._oprot.writeMessageBegin('get_jobs_by_fpguid', TMessageType.CALL, self._seqid)
        args = get_jobs_by_fpguid_args()
        args.fpGuid = fpGuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_fpguid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_fpguid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_fpguid failed: unknown result")

    def client_exsit_job(self, clientId):
        """
        Parameters:
         - clientId

        """
        self.send_client_exsit_job(clientId)
        return self.recv_client_exsit_job()

    def send_client_exsit_job(self, clientId):
        self._oprot.writeMessageBegin('client_exsit_job', TMessageType.CALL, self._seqid)
        args = client_exsit_job_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_exsit_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_exsit_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "client_exsit_job failed: unknown result")

    def get_jobs_by_cloud_storage_id(self, cloud_storage_id):
        """
        Parameters:
         - cloud_storage_id

        """
        self.send_get_jobs_by_cloud_storage_id(cloud_storage_id)
        return self.recv_get_jobs_by_cloud_storage_id()

    def send_get_jobs_by_cloud_storage_id(self, cloud_storage_id):
        self._oprot.writeMessageBegin('get_jobs_by_cloud_storage_id', TMessageType.CALL, self._seqid)
        args = get_jobs_by_cloud_storage_id_args()
        args.cloud_storage_id = cloud_storage_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_cloud_storage_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_cloud_storage_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_cloud_storage_id failed: unknown result")

    def get_db_job_instances(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_job_instances(request)
        return self.recv_get_db_job_instances()

    def send_get_db_job_instances(self, request):
        self._oprot.writeMessageBegin('get_db_job_instances', TMessageType.CALL, self._seqid)
        args = get_db_job_instances_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_job_instances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_job_instances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_instances failed: unknown result")

    def get_db_job_mappings(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_job_mappings(request)
        return self.recv_get_db_job_mappings()

    def send_get_db_job_mappings(self, request):
        self._oprot.writeMessageBegin('get_db_job_mappings', TMessageType.CALL, self._seqid)
        args = get_db_job_mappings_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_job_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_job_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_mappings failed: unknown result")

    def get_contentcloud_datasource_job_names(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_contentcloud_datasource_job_names(request)
        return self.recv_get_contentcloud_datasource_job_names()

    def send_get_contentcloud_datasource_job_names(self, request):
        self._oprot.writeMessageBegin('get_contentcloud_datasource_job_names', TMessageType.CALL, self._seqid)
        args = get_contentcloud_datasource_job_names_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_contentcloud_datasource_job_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_contentcloud_datasource_job_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_contentcloud_datasource_job_names failed: unknown result")

    def get_jobs_by_filter(self, filter_request):
        """
        根据一组条件, 获取一组任务

        建议: 向BS获取任务信息时, 只使用这个接口即可, 无论是获取一个还是多个

        Parameters:
         - filter_request

        """
        self.send_get_jobs_by_filter(filter_request)
        return self.recv_get_jobs_by_filter()

    def send_get_jobs_by_filter(self, filter_request):
        self._oprot.writeMessageBegin('get_jobs_by_filter', TMessageType.CALL, self._seqid)
        args = get_jobs_by_filter_args()
        args.filter_request = filter_request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_filter failed: unknown result")

    def get_cloud_backup_jobs(self, query_all):
        """
        获取云服务任务

        Parameters:
         - query_all

        """
        self.send_get_cloud_backup_jobs(query_all)
        return self.recv_get_cloud_backup_jobs()

    def send_get_cloud_backup_jobs(self, query_all):
        self._oprot.writeMessageBegin('get_cloud_backup_jobs', TMessageType.CALL, self._seqid)
        args = get_cloud_backup_jobs_args()
        args.query_all = query_all
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cloud_backup_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cloud_backup_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cloud_backup_jobs failed: unknown result")

    def update_jobs(self, requests):
        """
            更新一批任务

            job_ids与nc_update_requests的长度必须一致( 以短的那个为准)
            根据thrift的特性, 声明为oneway的接口是不会阻塞调用者的. 也不会抛异常给调用者
        *

        Parameters:
         - requests

        """
        self.send_update_jobs(requests)

    def send_update_jobs(self, requests):
        self._oprot.writeMessageBegin('update_jobs', TMessageType.ONEWAY, self._seqid)
        args = update_jobs_args()
        args.requests = requests
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def update_data_sources(self, request):
        """
        更新任务的数据源

        Parameters:
         - request

        """
        self.send_update_data_sources(request)

    def send_update_data_sources(self, request):
        self._oprot.writeMessageBegin('update_data_sources', TMessageType.ONEWAY, self._seqid)
        args = update_data_sources_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def remove_all_jobs_by_client_ids(self, clientIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - clientIds

        """
        self.send_remove_all_jobs_by_client_ids(clientIds)
        return self.recv_remove_all_jobs_by_client_ids()

    def send_remove_all_jobs_by_client_ids(self, clientIds):
        self._oprot.writeMessageBegin('remove_all_jobs_by_client_ids', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_client_ids_args()
        args.clientIds = clientIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_client_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_client_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_client_ids failed: unknown result")

    def get_datasource_jobs(self, request):
        """
        获取某一数据源映射的任务列表

        Parameters:
         - request

        """
        self.send_get_datasource_jobs(request)
        return self.recv_get_datasource_jobs()

    def send_get_datasource_jobs(self, request):
        self._oprot.writeMessageBegin('get_datasource_jobs', TMessageType.CALL, self._seqid)
        args = get_datasource_jobs_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_datasource_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_datasource_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_datasource_jobs failed: unknown result")

    def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - vplatformIds

        """
        self.send_remove_all_jobs_by_vplatform_ids(vplatformIds)
        return self.recv_remove_all_jobs_by_vplatform_ids()

    def send_remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        self._oprot.writeMessageBegin('remove_all_jobs_by_vplatform_ids', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_vplatform_ids_args()
        args.vplatformIds = vplatformIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_vplatform_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_vplatform_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_vplatform_ids failed: unknown result")

    def remove_all_jobs_by_backup_media_and_username(self, usernames, cloud_storage_name):
        """
        批量删除任务 根据备份介质名字和用户


        Parameters:
         - usernames
         - cloud_storage_name

        """
        self.send_remove_all_jobs_by_backup_media_and_username(usernames, cloud_storage_name)
        return self.recv_remove_all_jobs_by_backup_media_and_username()

    def send_remove_all_jobs_by_backup_media_and_username(self, usernames, cloud_storage_name):
        self._oprot.writeMessageBegin('remove_all_jobs_by_backup_media_and_username', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_backup_media_and_username_args()
        args.usernames = usernames
        args.cloud_storage_name = cloud_storage_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_backup_media_and_username(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_backup_media_and_username_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_backup_media_and_username failed: unknown result")

    def remove_all_jobs_by_contentcloud_resources(self, contentcloud_resource_ids):
        """
        Parameters:
         - contentcloud_resource_ids

        """
        self.send_remove_all_jobs_by_contentcloud_resources(contentcloud_resource_ids)
        self.recv_remove_all_jobs_by_contentcloud_resources()

    def send_remove_all_jobs_by_contentcloud_resources(self, contentcloud_resource_ids):
        self._oprot.writeMessageBegin('remove_all_jobs_by_contentcloud_resources', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_contentcloud_resources_args()
        args.contentcloud_resource_ids = contentcloud_resource_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_contentcloud_resources(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_contentcloud_resources_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_datasource_by_client(self, client_id, job_is_backup):
        """
        获取任务列表

        @return 任务对象列表

        Parameters:
         - client_id
         - job_is_backup

        """
        self.send_get_datasource_by_client(client_id, job_is_backup)
        return self.recv_get_datasource_by_client()

    def send_get_datasource_by_client(self, client_id, job_is_backup):
        self._oprot.writeMessageBegin('get_datasource_by_client', TMessageType.CALL, self._seqid)
        args = get_datasource_by_client_args()
        args.client_id = client_id
        args.job_is_backup = job_is_backup
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_datasource_by_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_datasource_by_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_datasource_by_client failed: unknown result")

    def add_schedule_jobs(self, ids):
        """
        Parameters:
         - ids

        """
        self.send_add_schedule_jobs(ids)
        return self.recv_add_schedule_jobs()

    def send_add_schedule_jobs(self, ids):
        self._oprot.writeMessageBegin('add_schedule_jobs', TMessageType.CALL, self._seqid)
        args = add_schedule_jobs_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_schedule_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_schedule_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_schedule_jobs failed: unknown result")

    def modify_schedule_jobs(self, ids):
        """
        Parameters:
         - ids

        """
        self.send_modify_schedule_jobs(ids)
        return self.recv_modify_schedule_jobs()

    def send_modify_schedule_jobs(self, ids):
        self._oprot.writeMessageBegin('modify_schedule_jobs', TMessageType.CALL, self._seqid)
        args = modify_schedule_jobs_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_schedule_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_schedule_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modify_schedule_jobs failed: unknown result")

    def get_schedule_jobs(self):
        self.send_get_schedule_jobs()
        return self.recv_get_schedule_jobs()

    def send_get_schedule_jobs(self):
        self._oprot.writeMessageBegin('get_schedule_jobs', TMessageType.CALL, self._seqid)
        args = get_schedule_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_jobs failed: unknown result")

    def online_reload(self, ip):
        """
        Parameters:
         - ip

        """
        self.send_online_reload(ip)
        self.recv_online_reload()

    def send_online_reload(self, ip):
        self._oprot.writeMessageBegin('online_reload', TMessageType.CALL, self._seqid)
        args = online_reload_args()
        args.ip = ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_online_reload(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = online_reload_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def offline_reload(self, ip):
        """
        Parameters:
         - ip

        """
        self.send_offline_reload(ip)
        self.recv_offline_reload()

    def send_offline_reload(self, ip):
        self._oprot.writeMessageBegin('offline_reload', TMessageType.CALL, self._seqid)
        args = offline_reload_args()
        args.ip = ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_offline_reload(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = offline_reload_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def migrate_node_vibration(self, ip_to_state):
        """
        Parameters:
         - ip_to_state

        """
        self.send_migrate_node_vibration(ip_to_state)
        self.recv_migrate_node_vibration()

    def send_migrate_node_vibration(self, ip_to_state):
        self._oprot.writeMessageBegin('migrate_node_vibration', TMessageType.CALL, self._seqid)
        args = migrate_node_vibration_args()
        args.ip_to_state = ip_to_state
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_migrate_node_vibration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = migrate_node_vibration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def app_ctrl_push(self, req):
        """
        Parameters:
         - req

        """
        self.send_app_ctrl_push(req)
        self.recv_app_ctrl_push()

    def send_app_ctrl_push(self, req):
        self._oprot.writeMessageBegin('app_ctrl_push', TMessageType.CALL, self._seqid)
        args = app_ctrl_push_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_app_ctrl_push(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = app_ctrl_push_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        self.send_get_data_for_ams(kwargs)
        return self.recv_get_data_for_ams()

    def send_get_data_for_ams(self, kwargs):
        self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
        args = get_data_for_ams_args()
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

    def is_exists_running_job_on_client(self, clientId):
        """
        *  客户端上是否存在正则运行的任务
           @ return True:存在正在运行的任务, False： 不存在正在运行的任务
        *

        Parameters:
         - clientId

        """
        self.send_is_exists_running_job_on_client(clientId)
        return self.recv_is_exists_running_job_on_client()

    def send_is_exists_running_job_on_client(self, clientId):
        self._oprot.writeMessageBegin('is_exists_running_job_on_client', TMessageType.CALL, self._seqid)
        args = is_exists_running_job_on_client_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_exists_running_job_on_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_exists_running_job_on_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_running_job_on_client failed: unknown result")

    def client_exsit_volume_job(self, clientId):
        """
        Parameters:
         - clientId

        """
        self.send_client_exsit_volume_job(clientId)
        return self.recv_client_exsit_volume_job()

    def send_client_exsit_volume_job(self, clientId):
        self._oprot.writeMessageBegin('client_exsit_volume_job', TMessageType.CALL, self._seqid)
        args = client_exsit_volume_job_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_exsit_volume_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_exsit_volume_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "client_exsit_volume_job failed: unknown result")

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        self.send_do_operation_from_ams(target, method, kwargs)
        return self.recv_do_operation_from_ams()

    def send_do_operation_from_ams(self, target, method, kwargs):
        self._oprot.writeMessageBegin('do_operation_from_ams', TMessageType.CALL, self._seqid)
        args = do_operation_from_ams_args()
        args.target = target
        args.method = method
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_do_operation_from_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = do_operation_from_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "do_operation_from_ams failed: unknown result")

    def get_jobs_status_by_contentcloud_resources(self, ids):
        """
        检测contentcloud资源是否有正在运行的任务


        Parameters:
         - ids

        """
        self.send_get_jobs_status_by_contentcloud_resources(ids)
        return self.recv_get_jobs_status_by_contentcloud_resources()

    def send_get_jobs_status_by_contentcloud_resources(self, ids):
        self._oprot.writeMessageBegin('get_jobs_status_by_contentcloud_resources', TMessageType.CALL, self._seqid)
        args = get_jobs_status_by_contentcloud_resources_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_status_by_contentcloud_resources(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_status_by_contentcloud_resources_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_status_by_contentcloud_resources failed: unknown result")

    def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        """
        生产资源类型  sourceType
        服务类型     svcType
        生产资源标识  sourceId
        @ return


        Parameters:
         - sourceType
         - svcType
         - sourceId
         - relation

        """
        self.send_get_jobs_by_sourceId(sourceType, svcType, sourceId, relation)
        return self.recv_get_jobs_by_sourceId()

    def send_get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        self._oprot.writeMessageBegin('get_jobs_by_sourceId', TMessageType.CALL, self._seqid)
        args = get_jobs_by_sourceId_args()
        args.sourceType = sourceType
        args.svcType = svcType
        args.sourceId = sourceId
        args.relation = relation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_sourceId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_sourceId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_sourceId failed: unknown result")

    def GetKeyMaterial(self, KeyId, DeviceId):
        """
        获取kms密钥

        Parameters:
         - KeyId
         - DeviceId

        """
        self.send_GetKeyMaterial(KeyId, DeviceId)
        return self.recv_GetKeyMaterial()

    def send_GetKeyMaterial(self, KeyId, DeviceId):
        self._oprot.writeMessageBegin('GetKeyMaterial', TMessageType.CALL, self._seqid)
        args = GetKeyMaterial_args()
        args.KeyId = KeyId
        args.DeviceId = DeviceId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetKeyMaterial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetKeyMaterial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetKeyMaterial failed: unknown result")

    def get_dict_export(self, body, jobInstanceId, user):
        """
        Parameters:
         - body
         - jobInstanceId
         - user

        """
        self.send_get_dict_export(body, jobInstanceId, user)
        return self.recv_get_dict_export()

    def send_get_dict_export(self, body, jobInstanceId, user):
        self._oprot.writeMessageBegin('get_dict_export', TMessageType.CALL, self._seqid)
        args = get_dict_export_args()
        args.body = body
        args.jobInstanceId = jobInstanceId
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dict_export(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dict_export_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err is not None:
            raise result.err
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dict_export failed: unknown result")

    def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        """
        数据源       datasource
        客户端ID     clientId
        数据源的用户名(适用于多用户场景)   dbRunUserName
        @ return


        Parameters:
         - datasource
         - clientId
         - dbRunUserName

        """
        self.send_get_jobs_by_datasource(datasource, clientId, dbRunUserName)
        return self.recv_get_jobs_by_datasource()

    def send_get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        self._oprot.writeMessageBegin('get_jobs_by_datasource', TMessageType.CALL, self._seqid)
        args = get_jobs_by_datasource_args()
        args.datasource = datasource
        args.clientId = clientId
        args.dbRunUserName = dbRunUserName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_datasource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_datasource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_datasource failed: unknown result")

    def get_backup_jobs_by_node_ip(self, node_ip):
        """
        获取该节点ip上是否拥有备份任务
        return result
        @throw ncException

        Parameters:
         - node_ip

        """
        self.send_get_backup_jobs_by_node_ip(node_ip)
        return self.recv_get_backup_jobs_by_node_ip()

    def send_get_backup_jobs_by_node_ip(self, node_ip):
        self._oprot.writeMessageBegin('get_backup_jobs_by_node_ip', TMessageType.CALL, self._seqid)
        args = get_backup_jobs_by_node_ip_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backup_jobs_by_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backup_jobs_by_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backup_jobs_by_node_ip failed: unknown result")

    def get_backup_jobs_by_volume_id(self, volume_id):
        """
        获取该卷下是否拥有文件备份任务
        return result
        @throw ncException

        Parameters:
         - volume_id

        """
        self.send_get_backup_jobs_by_volume_id(volume_id)
        return self.recv_get_backup_jobs_by_volume_id()

    def send_get_backup_jobs_by_volume_id(self, volume_id):
        self._oprot.writeMessageBegin('get_backup_jobs_by_volume_id', TMessageType.CALL, self._seqid)
        args = get_backup_jobs_by_volume_id_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backup_jobs_by_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backup_jobs_by_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backup_jobs_by_volume_id failed: unknown result")

    def get_permanent_increment_job(self):
        """
        获取永久增量备份任务列表
        (临时给创建归档任务时判断使用的, 当前不支持对开启了永久增量备份任务进行归档。但只能限制本地备份任务,
        远程复制与反向复制无法限制, 相当于只限制了一部分, 但还是要求要这样处理。)

        """
        self.send_get_permanent_increment_job()
        return self.recv_get_permanent_increment_job()

    def send_get_permanent_increment_job(self):
        self._oprot.writeMessageBegin('get_permanent_increment_job', TMessageType.CALL, self._seqid)
        args = get_permanent_increment_job_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_permanent_increment_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_permanent_increment_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_permanent_increment_job failed: unknown result")

    def check_user_has_data(self, user_list):
        """
        检查指定用户名列表中的用户是否有备份任务
        return 存在任务的用户名列表
        @throw ncException

        Parameters:
         - user_list

        """
        self.send_check_user_has_data(user_list)
        return self.recv_check_user_has_data()

    def send_check_user_has_data(self, user_list):
        self._oprot.writeMessageBegin('check_user_has_data', TMessageType.CALL, self._seqid)
        args = check_user_has_data_args()
        args.user_list = user_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_user_has_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_user_has_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_user_has_data failed: unknown result")

    def get_job_count_info(self, startTime, userId):
        """
        获取任务状态数据
        return result
        @throw ncException

        Parameters:
         - startTime
         - userId

        """
        self.send_get_job_count_info(startTime, userId)
        return self.recv_get_job_count_info()

    def send_get_job_count_info(self, startTime, userId):
        self._oprot.writeMessageBegin('get_job_count_info', TMessageType.CALL, self._seqid)
        args = get_job_count_info_args()
        args.startTime = startTime
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_job_count_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_job_count_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job_count_info failed: unknown result")

    def get_strategy_export(self, strategy_ids, user_name):
        """
        策略计划导出
        return result
        @throw ncException

        Parameters:
         - strategy_ids
         - user_name

        """
        self.send_get_strategy_export(strategy_ids, user_name)
        return self.recv_get_strategy_export()

    def send_get_strategy_export(self, strategy_ids, user_name):
        self._oprot.writeMessageBegin('get_strategy_export', TMessageType.CALL, self._seqid)
        args = get_strategy_export_args()
        args.strategy_ids = strategy_ids
        args.user_name = user_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_strategy_export(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_strategy_export_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_strategy_export failed: unknown result")

    def get_deleted_backup_jobs(self):
        """
        获取已删除的备份任务信息(专供归档服务调用, 当前归档的数据源查询要求必须对已删除的任务做区分, 如果是已删除的任务则加个创建时间区分)
        return {jobId: createTime}

        """
        self.send_get_deleted_backup_jobs()
        return self.recv_get_deleted_backup_jobs()

    def send_get_deleted_backup_jobs(self):
        self._oprot.writeMessageBegin('get_deleted_backup_jobs', TMessageType.CALL, self._seqid)
        args = get_deleted_backup_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_deleted_backup_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_deleted_backup_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_deleted_backup_jobs failed: unknown result")

    def remove_all_jobs_by_cloud_storage_name_and_username(self, usernames, cloud_storage_name):
        """
        批量删除任务 根据云存储名称和用户名


        Parameters:
         - usernames
         - cloud_storage_name

        """
        self.send_remove_all_jobs_by_cloud_storage_name_and_username(usernames, cloud_storage_name)
        return self.recv_remove_all_jobs_by_cloud_storage_name_and_username()

    def send_remove_all_jobs_by_cloud_storage_name_and_username(self, usernames, cloud_storage_name):
        self._oprot.writeMessageBegin('remove_all_jobs_by_cloud_storage_name_and_username', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_cloud_storage_name_and_username_args()
        args.usernames = usernames
        args.cloud_storage_name = cloud_storage_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_cloud_storage_name_and_username(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_cloud_storage_name_and_username_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_cloud_storage_name_and_username failed: unknown result")

    def delete_extra_resource_by_username(self, user_names):
        """
        通过用户名称删除其附属的策略及数据保留策略
        @ return


        Parameters:
         - user_names

        """
        self.send_delete_extra_resource_by_username(user_names)
        self.recv_delete_extra_resource_by_username()

    def send_delete_extra_resource_by_username(self, user_names):
        self._oprot.writeMessageBegin('delete_extra_resource_by_username', TMessageType.CALL, self._seqid)
        args = delete_extra_resource_by_username_args()
        args.user_names = user_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_extra_resource_by_username(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_extra_resource_by_username_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_sub_using_num(self, sub_license_types):
        """
        正在运行任务的UNIX客户端数量


        Parameters:
         - sub_license_types

        """
        self.send_get_sub_using_num(sub_license_types)
        return self.recv_get_sub_using_num()

    def send_get_sub_using_num(self, sub_license_types):
        self._oprot.writeMessageBegin('get_sub_using_num', TMessageType.CALL, self._seqid)
        args = get_sub_using_num_args()
        args.sub_license_types = sub_license_types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sub_using_num(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sub_using_num_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sub_using_num failed: unknown result")

    def get_all_jobs_by_pages(self, BaseReq):
        """
        分页获取指定用户下的备份任务
        @return list<ncJob.ncTJob>任务对象列表


        Parameters:
         - BaseReq

        """
        self.send_get_all_jobs_by_pages(BaseReq)
        return self.recv_get_all_jobs_by_pages()

    def send_get_all_jobs_by_pages(self, BaseReq):
        self._oprot.writeMessageBegin('get_all_jobs_by_pages', TMessageType.CALL, self._seqid)
        args = get_all_jobs_by_pages_args()
        args.BaseReq = BaseReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_jobs_by_pages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_jobs_by_pages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs_by_pages failed: unknown result")

    def get_task_src_from_DB_InBackup(self, job_id):
        """
        获取数据库中的任务的数据源
        @ return list<string>


        Parameters:
         - job_id

        """
        self.send_get_task_src_from_DB_InBackup(job_id)
        return self.recv_get_task_src_from_DB_InBackup()

    def send_get_task_src_from_DB_InBackup(self, job_id):
        self._oprot.writeMessageBegin('get_task_src_from_DB_InBackup', TMessageType.CALL, self._seqid)
        args = get_task_src_from_DB_InBackup_args()
        args.job_id = job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_task_src_from_DB_InBackup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_task_src_from_DB_InBackup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_task_src_from_DB_InBackup failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["microprobe"] = Processor.process_microprobe
        self._processMap["get_all_jobs"] = Processor.process_get_all_jobs
        self._processMap["get_all_jobs_for_ams"] = Processor.process_get_all_jobs_for_ams
        self._processMap["get_task_log_message_by_id"] = Processor.process_get_task_log_message_by_id
        self._processMap["get_jobs_log_for_ams"] = Processor.process_get_jobs_log_for_ams
        self._processMap["get_job_info_by_id"] = Processor.process_get_job_info_by_id
        self._processMap["get_all_clean_jobs"] = Processor.process_get_all_clean_jobs
        self._processMap["get_job"] = Processor.process_get_job
        self._processMap["update_jobs_nstart_time"] = Processor.process_update_jobs_nstart_time
        self._processMap["get_jobs_like_for_schedule"] = Processor.process_get_jobs_like_for_schedule
        self._processMap["get_jobs_for_schedule_by_ids"] = Processor.process_get_jobs_for_schedule_by_ids
        self._processMap["commit_job"] = Processor.process_commit_job
        self._processMap["get_support_backup_type"] = Processor.process_get_support_backup_type
        self._processMap["get_jobs_by_instance_name"] = Processor.process_get_jobs_by_instance_name
        self._processMap["get_jobs_by_fpguid"] = Processor.process_get_jobs_by_fpguid
        self._processMap["client_exsit_job"] = Processor.process_client_exsit_job
        self._processMap["get_jobs_by_cloud_storage_id"] = Processor.process_get_jobs_by_cloud_storage_id
        self._processMap["get_db_job_instances"] = Processor.process_get_db_job_instances
        self._processMap["get_db_job_mappings"] = Processor.process_get_db_job_mappings
        self._processMap["get_contentcloud_datasource_job_names"] = Processor.process_get_contentcloud_datasource_job_names
        self._processMap["get_jobs_by_filter"] = Processor.process_get_jobs_by_filter
        self._processMap["get_cloud_backup_jobs"] = Processor.process_get_cloud_backup_jobs
        self._processMap["update_jobs"] = Processor.process_update_jobs
        self._processMap["update_data_sources"] = Processor.process_update_data_sources
        self._processMap["remove_all_jobs_by_client_ids"] = Processor.process_remove_all_jobs_by_client_ids
        self._processMap["get_datasource_jobs"] = Processor.process_get_datasource_jobs
        self._processMap["remove_all_jobs_by_vplatform_ids"] = Processor.process_remove_all_jobs_by_vplatform_ids
        self._processMap["remove_all_jobs_by_backup_media_and_username"] = Processor.process_remove_all_jobs_by_backup_media_and_username
        self._processMap["remove_all_jobs_by_contentcloud_resources"] = Processor.process_remove_all_jobs_by_contentcloud_resources
        self._processMap["get_datasource_by_client"] = Processor.process_get_datasource_by_client
        self._processMap["add_schedule_jobs"] = Processor.process_add_schedule_jobs
        self._processMap["modify_schedule_jobs"] = Processor.process_modify_schedule_jobs
        self._processMap["get_schedule_jobs"] = Processor.process_get_schedule_jobs
        self._processMap["online_reload"] = Processor.process_online_reload
        self._processMap["offline_reload"] = Processor.process_offline_reload
        self._processMap["migrate_node_vibration"] = Processor.process_migrate_node_vibration
        self._processMap["app_ctrl_push"] = Processor.process_app_ctrl_push
        self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
        self._processMap["is_exists_running_job_on_client"] = Processor.process_is_exists_running_job_on_client
        self._processMap["client_exsit_volume_job"] = Processor.process_client_exsit_volume_job
        self._processMap["do_operation_from_ams"] = Processor.process_do_operation_from_ams
        self._processMap["get_jobs_status_by_contentcloud_resources"] = Processor.process_get_jobs_status_by_contentcloud_resources
        self._processMap["get_jobs_by_sourceId"] = Processor.process_get_jobs_by_sourceId
        self._processMap["GetKeyMaterial"] = Processor.process_GetKeyMaterial
        self._processMap["get_dict_export"] = Processor.process_get_dict_export
        self._processMap["get_jobs_by_datasource"] = Processor.process_get_jobs_by_datasource
        self._processMap["get_backup_jobs_by_node_ip"] = Processor.process_get_backup_jobs_by_node_ip
        self._processMap["get_backup_jobs_by_volume_id"] = Processor.process_get_backup_jobs_by_volume_id
        self._processMap["get_permanent_increment_job"] = Processor.process_get_permanent_increment_job
        self._processMap["check_user_has_data"] = Processor.process_check_user_has_data
        self._processMap["get_job_count_info"] = Processor.process_get_job_count_info
        self._processMap["get_strategy_export"] = Processor.process_get_strategy_export
        self._processMap["get_deleted_backup_jobs"] = Processor.process_get_deleted_backup_jobs
        self._processMap["remove_all_jobs_by_cloud_storage_name_and_username"] = Processor.process_remove_all_jobs_by_cloud_storage_name_and_username
        self._processMap["delete_extra_resource_by_username"] = Processor.process_delete_extra_resource_by_username
        self._processMap["get_sub_using_num"] = Processor.process_get_sub_using_num
        self._processMap["get_all_jobs_by_pages"] = Processor.process_get_all_jobs_by_pages
        self._processMap["get_task_src_from_DB_InBackup"] = Processor.process_get_task_src_from_DB_InBackup
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_microprobe(self, seqid, iprot, oprot):
        args = microprobe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = microprobe_result()
        try:
            self._handler.microprobe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("microprobe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_jobs(self, seqid, iprot, oprot):
        args = get_all_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_jobs_result()
        try:
            result.success = self._handler.get_all_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_jobs_for_ams(self, seqid, iprot, oprot):
        args = get_all_jobs_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_jobs_for_ams_result()
        try:
            result.success = self._handler.get_all_jobs_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_jobs_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_task_log_message_by_id(self, seqid, iprot, oprot):
        args = get_task_log_message_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_task_log_message_by_id_result()
        try:
            result.success = self._handler.get_task_log_message_by_id(args.instanceId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_task_log_message_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_log_for_ams(self, seqid, iprot, oprot):
        args = get_jobs_log_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_log_for_ams_result()
        try:
            result.success = self._handler.get_jobs_log_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_log_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_job_info_by_id(self, seqid, iprot, oprot):
        args = get_job_info_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_job_info_by_id_result()
        try:
            result.success = self._handler.get_job_info_by_id(args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_job_info_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_clean_jobs(self, seqid, iprot, oprot):
        args = get_all_clean_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_clean_jobs_result()
        try:
            result.success = self._handler.get_all_clean_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_clean_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_job(self, seqid, iprot, oprot):
        args = get_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_job_result()
        try:
            result.success = self._handler.get_job(args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_jobs_nstart_time(self, seqid, iprot, oprot):
        args = update_jobs_nstart_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_jobs_nstart_time_result()
        try:
            self._handler.update_jobs_nstart_time(args.jobs_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_jobs_nstart_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_like_for_schedule(self, seqid, iprot, oprot):
        args = get_jobs_like_for_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_like_for_schedule_result()
        try:
            result.success = self._handler.get_jobs_like_for_schedule(args.jobName, args.clientIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_like_for_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_for_schedule_by_ids(self, seqid, iprot, oprot):
        args = get_jobs_for_schedule_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_for_schedule_by_ids_result()
        try:
            result.success = self._handler.get_jobs_for_schedule_by_ids(args.jobIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_for_schedule_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_job(self, seqid, iprot, oprot):
        args = commit_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_job_result()
        try:
            self._handler.commit_job(args.jobId, args.customer, args.backupType, args.desc, args.is_auto_execute, args.nstart_time, args.strategy_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_support_backup_type(self, seqid, iprot, oprot):
        args = get_support_backup_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_support_backup_type_result()
        try:
            result.success = self._handler.get_support_backup_type(args.job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_support_backup_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_instance_name(self, seqid, iprot, oprot):
        args = get_jobs_by_instance_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_instance_name_result()
        try:
            result.success = self._handler.get_jobs_by_instance_name(args.instance_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_instance_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_fpguid(self, seqid, iprot, oprot):
        args = get_jobs_by_fpguid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_fpguid_result()
        try:
            result.success = self._handler.get_jobs_by_fpguid(args.fpGuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_fpguid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_exsit_job(self, seqid, iprot, oprot):
        args = client_exsit_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_exsit_job_result()
        try:
            result.success = self._handler.client_exsit_job(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_exsit_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_cloud_storage_id(self, seqid, iprot, oprot):
        args = get_jobs_by_cloud_storage_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_cloud_storage_id_result()
        try:
            result.success = self._handler.get_jobs_by_cloud_storage_id(args.cloud_storage_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_cloud_storage_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_job_instances(self, seqid, iprot, oprot):
        args = get_db_job_instances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_job_instances_result()
        try:
            result.success = self._handler.get_db_job_instances(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_job_instances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_job_mappings(self, seqid, iprot, oprot):
        args = get_db_job_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_job_mappings_result()
        try:
            result.success = self._handler.get_db_job_mappings(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_job_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_contentcloud_datasource_job_names(self, seqid, iprot, oprot):
        args = get_contentcloud_datasource_job_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_contentcloud_datasource_job_names_result()
        try:
            result.success = self._handler.get_contentcloud_datasource_job_names(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_contentcloud_datasource_job_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_filter(self, seqid, iprot, oprot):
        args = get_jobs_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_filter_result()
        try:
            result.success = self._handler.get_jobs_by_filter(args.filter_request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cloud_backup_jobs(self, seqid, iprot, oprot):
        args = get_cloud_backup_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cloud_backup_jobs_result()
        try:
            result.success = self._handler.get_cloud_backup_jobs(args.query_all)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cloud_backup_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_jobs(self, seqid, iprot, oprot):
        args = update_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.update_jobs(args.requests)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_update_data_sources(self, seqid, iprot, oprot):
        args = update_data_sources_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.update_data_sources(args.request)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_remove_all_jobs_by_client_ids(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_client_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_client_ids_result()
        try:
            result.success = self._handler.remove_all_jobs_by_client_ids(args.clientIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_client_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_datasource_jobs(self, seqid, iprot, oprot):
        args = get_datasource_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_datasource_jobs_result()
        try:
            result.success = self._handler.get_datasource_jobs(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_datasource_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_vplatform_ids(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_vplatform_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_vplatform_ids_result()
        try:
            result.success = self._handler.remove_all_jobs_by_vplatform_ids(args.vplatformIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_vplatform_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_backup_media_and_username(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_backup_media_and_username_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_backup_media_and_username_result()
        try:
            result.success = self._handler.remove_all_jobs_by_backup_media_and_username(args.usernames, args.cloud_storage_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_backup_media_and_username", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_contentcloud_resources(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_contentcloud_resources_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_contentcloud_resources_result()
        try:
            self._handler.remove_all_jobs_by_contentcloud_resources(args.contentcloud_resource_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_contentcloud_resources", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_datasource_by_client(self, seqid, iprot, oprot):
        args = get_datasource_by_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_datasource_by_client_result()
        try:
            result.success = self._handler.get_datasource_by_client(args.client_id, args.job_is_backup)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_datasource_by_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_schedule_jobs(self, seqid, iprot, oprot):
        args = add_schedule_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_schedule_jobs_result()
        try:
            result.success = self._handler.add_schedule_jobs(args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_schedule_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_schedule_jobs(self, seqid, iprot, oprot):
        args = modify_schedule_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_schedule_jobs_result()
        try:
            result.success = self._handler.modify_schedule_jobs(args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_schedule_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_jobs(self, seqid, iprot, oprot):
        args = get_schedule_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_jobs_result()
        try:
            result.success = self._handler.get_schedule_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_online_reload(self, seqid, iprot, oprot):
        args = online_reload_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = online_reload_result()
        try:
            self._handler.online_reload(args.ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("online_reload", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_offline_reload(self, seqid, iprot, oprot):
        args = offline_reload_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = offline_reload_result()
        try:
            self._handler.offline_reload(args.ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("offline_reload", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_migrate_node_vibration(self, seqid, iprot, oprot):
        args = migrate_node_vibration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = migrate_node_vibration_result()
        try:
            self._handler.migrate_node_vibration(args.ip_to_state)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("migrate_node_vibration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_app_ctrl_push(self, seqid, iprot, oprot):
        args = app_ctrl_push_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = app_ctrl_push_result()
        try:
            self._handler.app_ctrl_push(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("app_ctrl_push", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_for_ams(self, seqid, iprot, oprot):
        args = get_data_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_for_ams_result()
        try:
            result.success = self._handler.get_data_for_ams(args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_exists_running_job_on_client(self, seqid, iprot, oprot):
        args = is_exists_running_job_on_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_exists_running_job_on_client_result()
        try:
            result.success = self._handler.is_exists_running_job_on_client(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_exists_running_job_on_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_exsit_volume_job(self, seqid, iprot, oprot):
        args = client_exsit_volume_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_exsit_volume_job_result()
        try:
            result.success = self._handler.client_exsit_volume_job(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_exsit_volume_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_do_operation_from_ams(self, seqid, iprot, oprot):
        args = do_operation_from_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = do_operation_from_ams_result()
        try:
            result.success = self._handler.do_operation_from_ams(args.target, args.method, args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("do_operation_from_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_status_by_contentcloud_resources(self, seqid, iprot, oprot):
        args = get_jobs_status_by_contentcloud_resources_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_status_by_contentcloud_resources_result()
        try:
            result.success = self._handler.get_jobs_status_by_contentcloud_resources(args.ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_status_by_contentcloud_resources", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_sourceId(self, seqid, iprot, oprot):
        args = get_jobs_by_sourceId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_sourceId_result()
        try:
            result.success = self._handler.get_jobs_by_sourceId(args.sourceType, args.svcType, args.sourceId, args.relation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_sourceId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetKeyMaterial(self, seqid, iprot, oprot):
        args = GetKeyMaterial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetKeyMaterial_result()
        try:
            result.success = self._handler.GetKeyMaterial(args.KeyId, args.DeviceId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetKeyMaterial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dict_export(self, seqid, iprot, oprot):
        args = get_dict_export_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dict_export_result()
        try:
            result.success = self._handler.get_dict_export(args.body, args.jobInstanceId, args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as err:
            msg_type = TMessageType.REPLY
            result.err = err
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dict_export", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_datasource(self, seqid, iprot, oprot):
        args = get_jobs_by_datasource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_datasource_result()
        try:
            result.success = self._handler.get_jobs_by_datasource(args.datasource, args.clientId, args.dbRunUserName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_datasource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backup_jobs_by_node_ip(self, seqid, iprot, oprot):
        args = get_backup_jobs_by_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backup_jobs_by_node_ip_result()
        try:
            result.success = self._handler.get_backup_jobs_by_node_ip(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backup_jobs_by_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backup_jobs_by_volume_id(self, seqid, iprot, oprot):
        args = get_backup_jobs_by_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backup_jobs_by_volume_id_result()
        try:
            result.success = self._handler.get_backup_jobs_by_volume_id(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backup_jobs_by_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_permanent_increment_job(self, seqid, iprot, oprot):
        args = get_permanent_increment_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_permanent_increment_job_result()
        try:
            result.success = self._handler.get_permanent_increment_job()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_permanent_increment_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_user_has_data(self, seqid, iprot, oprot):
        args = check_user_has_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_user_has_data_result()
        try:
            result.success = self._handler.check_user_has_data(args.user_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_user_has_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_job_count_info(self, seqid, iprot, oprot):
        args = get_job_count_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_job_count_info_result()
        try:
            result.success = self._handler.get_job_count_info(args.startTime, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_job_count_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_strategy_export(self, seqid, iprot, oprot):
        args = get_strategy_export_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_strategy_export_result()
        try:
            result.success = self._handler.get_strategy_export(args.strategy_ids, args.user_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_strategy_export", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_deleted_backup_jobs(self, seqid, iprot, oprot):
        args = get_deleted_backup_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_deleted_backup_jobs_result()
        try:
            result.success = self._handler.get_deleted_backup_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_deleted_backup_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_cloud_storage_name_and_username(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_cloud_storage_name_and_username_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_cloud_storage_name_and_username_result()
        try:
            result.success = self._handler.remove_all_jobs_by_cloud_storage_name_and_username(args.usernames, args.cloud_storage_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_cloud_storage_name_and_username", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_extra_resource_by_username(self, seqid, iprot, oprot):
        args = delete_extra_resource_by_username_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_extra_resource_by_username_result()
        try:
            self._handler.delete_extra_resource_by_username(args.user_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_extra_resource_by_username", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sub_using_num(self, seqid, iprot, oprot):
        args = get_sub_using_num_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sub_using_num_result()
        try:
            result.success = self._handler.get_sub_using_num(args.sub_license_types)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sub_using_num", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_jobs_by_pages(self, seqid, iprot, oprot):
        args = get_all_jobs_by_pages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_jobs_by_pages_result()
        try:
            result.success = self._handler.get_all_jobs_by_pages(args.BaseReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_jobs_by_pages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_task_src_from_DB_InBackup(self, seqid, iprot, oprot):
        args = get_task_src_from_DB_InBackup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_task_src_from_DB_InBackup_result()
        try:
            result.success = self._handler.get_task_src_from_DB_InBackup(args.job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_task_src_from_DB_InBackup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class microprobe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_args)
microprobe_args.thrift_spec = (
)


class microprobe_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_result)
microprobe_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_args)
get_all_jobs_args.thrift_spec = (
)


class get_all_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = ncJob.ttypes.ncTJob()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_result)
get_all_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_jobs_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_for_ams_args)
get_all_jobs_for_ams_args.thrift_spec = (
)


class get_all_jobs_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ncAmsJob.ttypes.ncAmsJobType()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_for_ams_result)
get_all_jobs_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncAmsJobType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_task_log_message_by_id_args(object):
    """
    Attributes:
     - instanceId

    """


    def __init__(self, instanceId=None,):
        self.instanceId = instanceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_log_message_by_id_args')
        if self.instanceId is not None:
            oprot.writeFieldBegin('instanceId', TType.STRING, 1)
            oprot.writeString(self.instanceId.encode('utf-8') if sys.version_info[0] == 2 else self.instanceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_log_message_by_id_args)
get_task_log_message_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'instanceId', 'UTF8', None, ),  # 1
)


class get_task_log_message_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncAmsJob.ttypes.ncJobLog()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_log_message_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_log_message_by_id_result)
get_task_log_message_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncAmsJob.ttypes.ncJobLog, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_log_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_log_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_log_for_ams_args)
get_jobs_log_for_ams_args.thrift_spec = (
)


class get_jobs_log_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = ncAmsJob.ttypes.ncJobLog()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_log_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_log_for_ams_result)
get_jobs_log_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncJobLog, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_job_info_by_id_args(object):
    """
    Attributes:
     - jobId

    """


    def __init__(self, jobId=None,):
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_info_by_id_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_info_by_id_args)
get_job_info_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
)


class get_job_info_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ncAmsJob.ttypes.ncAmsJobType()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_info_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_info_by_id_result)
get_job_info_by_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncAmsJobType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_clean_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clean_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clean_jobs_args)
get_all_clean_jobs_args.thrift_spec = (
)


class get_all_clean_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = ncAmsJob.ttypes.ncAmsJobType()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clean_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clean_jobs_result)
get_all_clean_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncAmsJobType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_job_args(object):
    """
    Attributes:
     - jobId

    """


    def __init__(self, jobId=None,):
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_args)
get_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
)


class get_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncJob.ttypes.ncTJob()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_result)
get_job_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncJob.ttypes.ncTJob, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_jobs_nstart_time_args(object):
    """
    Attributes:
     - jobs_params

    """


    def __init__(self, jobs_params=None,):
        self.jobs_params = jobs_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.jobs_params = {}
                    (_ktype36, _vtype37, _size35) = iprot.readMapBegin()
                    for _i39 in range(_size35):
                        _key40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val41 = iprot.readI64()
                        self.jobs_params[_key40] = _val41
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_jobs_nstart_time_args')
        if self.jobs_params is not None:
            oprot.writeFieldBegin('jobs_params', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.jobs_params))
            for kiter42, viter43 in self.jobs_params.items():
                oprot.writeString(kiter42.encode('utf-8') if sys.version_info[0] == 2 else kiter42)
                oprot.writeI64(viter43)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobs_params is None:
            raise TProtocolException(message='Required field jobs_params is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_jobs_nstart_time_args)
update_jobs_nstart_time_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'jobs_params', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 1
)


class update_jobs_nstart_time_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_jobs_nstart_time_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_jobs_nstart_time_result)
update_jobs_nstart_time_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_like_for_schedule_args(object):
    """
    Attributes:
     - jobName
     - clientIds

    """


    def __init__(self, jobName=None, clientIds=None,):
        self.jobName = jobName
        self.clientIds = clientIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.clientIds = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.clientIds.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_like_for_schedule_args')
        if self.jobName is not None:
            oprot.writeFieldBegin('jobName', TType.STRING, 1)
            oprot.writeString(self.jobName.encode('utf-8') if sys.version_info[0] == 2 else self.jobName)
            oprot.writeFieldEnd()
        if self.clientIds is not None:
            oprot.writeFieldBegin('clientIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.clientIds))
            for iter50 in self.clientIds:
                oprot.writeString(iter50.encode('utf-8') if sys.version_info[0] == 2 else iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobName is None:
            raise TProtocolException(message='Required field jobName is unset!')
        if self.clientIds is None:
            raise TProtocolException(message='Required field clientIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_like_for_schedule_args)
get_jobs_like_for_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'clientIds', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class get_jobs_like_for_schedule_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = ncJob.ttypes.ncTJob()
                        _elem56.read(iprot)
                        self.success.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_like_for_schedule_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter57 in self.success:
                iter57.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_like_for_schedule_result)
get_jobs_like_for_schedule_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_for_schedule_by_ids_args(object):
    """
    Attributes:
     - jobIds

    """


    def __init__(self, jobIds=None,):
        self.jobIds = jobIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobIds = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobIds.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_for_schedule_by_ids_args')
        if self.jobIds is not None:
            oprot.writeFieldBegin('jobIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jobIds))
            for iter64 in self.jobIds:
                oprot.writeString(iter64.encode('utf-8') if sys.version_info[0] == 2 else iter64)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobIds is None:
            raise TProtocolException(message='Required field jobIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_for_schedule_by_ids_args)
get_jobs_for_schedule_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_jobs_for_schedule_by_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = ncJob.ttypes.ncTJob()
                        _elem70.read(iprot)
                        self.success.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_for_schedule_by_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter71 in self.success:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_for_schedule_by_ids_result)
get_jobs_for_schedule_by_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class commit_job_args(object):
    """
    Attributes:
     - jobId
     - customer
     - backupType
     - desc
     - is_auto_execute
     - nstart_time
     - strategy_id

    """


    def __init__(self, jobId=None, customer=None, backupType=None, desc=None, is_auto_execute=None, nstart_time=None, strategy_id=None,):
        self.jobId = jobId
        self.customer = customer
        self.backupType = backupType
        self.desc = desc
        self.is_auto_execute = is_auto_execute
        self.nstart_time = nstart_time
        self.strategy_id = strategy_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.customer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.backupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.desc = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_auto_execute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.nstart_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.strategy_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.customer is not None:
            oprot.writeFieldBegin('customer', TType.STRING, 2)
            oprot.writeString(self.customer.encode('utf-8') if sys.version_info[0] == 2 else self.customer)
            oprot.writeFieldEnd()
        if self.backupType is not None:
            oprot.writeFieldBegin('backupType', TType.I32, 3)
            oprot.writeI32(self.backupType)
            oprot.writeFieldEnd()
        if self.desc is not None:
            oprot.writeFieldBegin('desc', TType.STRING, 4)
            oprot.writeString(self.desc.encode('utf-8') if sys.version_info[0] == 2 else self.desc)
            oprot.writeFieldEnd()
        if self.is_auto_execute is not None:
            oprot.writeFieldBegin('is_auto_execute', TType.BOOL, 5)
            oprot.writeBool(self.is_auto_execute)
            oprot.writeFieldEnd()
        if self.nstart_time is not None:
            oprot.writeFieldBegin('nstart_time', TType.I64, 6)
            oprot.writeI64(self.nstart_time)
            oprot.writeFieldEnd()
        if self.strategy_id is not None:
            oprot.writeFieldBegin('strategy_id', TType.STRING, 7)
            oprot.writeString(self.strategy_id.encode('utf-8') if sys.version_info[0] == 2 else self.strategy_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobId is None:
            raise TProtocolException(message='Required field jobId is unset!')
        if self.backupType is None:
            raise TProtocolException(message='Required field backupType is unset!')
        if self.is_auto_execute is None:
            raise TProtocolException(message='Required field is_auto_execute is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_args)
commit_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'customer', 'UTF8', None, ),  # 2
    (3, TType.I32, 'backupType', None, None, ),  # 3
    (4, TType.STRING, 'desc', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'is_auto_execute', None, None, ),  # 5
    (6, TType.I64, 'nstart_time', None, None, ),  # 6
    (7, TType.STRING, 'strategy_id', 'UTF8', None, ),  # 7
)


class commit_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_result)
commit_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_support_backup_type_args(object):
    """
    Attributes:
     - job_id

    """


    def __init__(self, job_id=None,):
        self.job_id = job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_support_backup_type_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.job_id is None:
            raise TProtocolException(message='Required field job_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_support_backup_type_args)
get_support_backup_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
)


class get_support_backup_type_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = iprot.readI32()
                        self.success.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_support_backup_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter78 in self.success:
                oprot.writeI32(iter78)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_support_backup_type_result)
get_support_backup_type_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_instance_name_args(object):
    """
    Attributes:
     - instance_name

    """


    def __init__(self, instance_name=None,):
        self.instance_name = instance_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instance_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_instance_name_args')
        if self.instance_name is not None:
            oprot.writeFieldBegin('instance_name', TType.STRING, 1)
            oprot.writeString(self.instance_name.encode('utf-8') if sys.version_info[0] == 2 else self.instance_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.instance_name is None:
            raise TProtocolException(message='Required field instance_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_instance_name_args)
get_jobs_by_instance_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'instance_name', 'UTF8', None, ),  # 1
)


class get_jobs_by_instance_name_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = ncJob.ttypes.ncDBJobInstance()
                        _elem84.read(iprot)
                        self.success.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_instance_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter85 in self.success:
                iter85.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_instance_name_result)
get_jobs_by_instance_name_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_fpguid_args(object):
    """
    Attributes:
     - fpGuid

    """


    def __init__(self, fpGuid=None,):
        self.fpGuid = fpGuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fpGuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_fpguid_args')
        if self.fpGuid is not None:
            oprot.writeFieldBegin('fpGuid', TType.STRING, 1)
            oprot.writeString(self.fpGuid.encode('utf-8') if sys.version_info[0] == 2 else self.fpGuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fpGuid is None:
            raise TProtocolException(message='Required field fpGuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_fpguid_args)
get_jobs_by_fpguid_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fpGuid', 'UTF8', None, ),  # 1
)


class get_jobs_by_fpguid_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = ncJob.ttypes.ncRelatedJob()
                        _elem91.read(iprot)
                        self.success.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_fpguid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter92 in self.success:
                iter92.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_fpguid_result)
get_jobs_by_fpguid_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncRelatedJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class client_exsit_job_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_job_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_job_args)
client_exsit_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class client_exsit_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_job_result)
client_exsit_job_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_cloud_storage_id_args(object):
    """
    Attributes:
     - cloud_storage_id

    """


    def __init__(self, cloud_storage_id=None,):
        self.cloud_storage_id = cloud_storage_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cloud_storage_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_cloud_storage_id_args')
        if self.cloud_storage_id is not None:
            oprot.writeFieldBegin('cloud_storage_id', TType.STRING, 1)
            oprot.writeString(self.cloud_storage_id.encode('utf-8') if sys.version_info[0] == 2 else self.cloud_storage_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cloud_storage_id is None:
            raise TProtocolException(message='Required field cloud_storage_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_cloud_storage_id_args)
get_jobs_by_cloud_storage_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cloud_storage_id', 'UTF8', None, ),  # 1
)


class get_jobs_by_cloud_storage_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = ncJob.ttypes.ncTJob()
                        _elem98.read(iprot)
                        self.success.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_cloud_storage_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter99 in self.success:
                iter99.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_cloud_storage_id_result)
get_jobs_by_cloud_storage_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_job_instances_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncDBJobInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_instances_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_instances_args)
get_db_job_instances_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncDBJobInstanceRequest, None], None, ),  # 1
)


class get_db_job_instances_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = ncJob.ttypes.ncDBJobInstance()
                        _elem105.read(iprot)
                        self.success.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_instances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter106 in self.success:
                iter106.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_instances_result)
get_db_job_instances_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_job_mappings_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncDBJobInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_mappings_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_mappings_args)
get_db_job_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncDBJobInstanceRequest, None], None, ),  # 1
)


class get_db_job_mappings_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = ncJob.ttypes.ncDBJobInstance()
                        _elem112.read(iprot)
                        self.success.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_mappings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter113 in self.success:
                iter113.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_mappings_result)
get_db_job_mappings_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_contentcloud_datasource_job_names_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncASDatasourceMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_contentcloud_datasource_job_names_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_contentcloud_datasource_job_names_args)
get_contentcloud_datasource_job_names_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncASDatasourceMappingRequest, None], None, ),  # 1
)


class get_contentcloud_datasource_job_names_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = ncJob.ttypes.ncASDatasourceMappingResponse()
                        _elem119.read(iprot)
                        self.success.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_contentcloud_datasource_job_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter120 in self.success:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_contentcloud_datasource_job_names_result)
get_contentcloud_datasource_job_names_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncASDatasourceMappingResponse, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_filter_args(object):
    """
    Attributes:
     - filter_request

    """


    def __init__(self, filter_request=None,):
        self.filter_request = filter_request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.filter_request = ncJob.ttypes.ncJobFilterRequest()
                    self.filter_request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_filter_args')
        if self.filter_request is not None:
            oprot.writeFieldBegin('filter_request', TType.STRUCT, 1)
            self.filter_request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.filter_request is None:
            raise TProtocolException(message='Required field filter_request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_filter_args)
get_jobs_by_filter_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'filter_request', [ncJob.ttypes.ncJobFilterRequest, None], None, ),  # 1
)


class get_jobs_by_filter_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = ncJob.ttypes.ncTJob()
                        _elem126.read(iprot)
                        self.success.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter127 in self.success:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_filter_result)
get_jobs_by_filter_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_cloud_backup_jobs_args(object):
    """
    Attributes:
     - query_all

    """


    def __init__(self, query_all=None,):
        self.query_all = query_all

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.query_all = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cloud_backup_jobs_args')
        if self.query_all is not None:
            oprot.writeFieldBegin('query_all', TType.BOOL, 1)
            oprot.writeBool(self.query_all)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cloud_backup_jobs_args)
get_cloud_backup_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'query_all', None, None, ),  # 1
)


class get_cloud_backup_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = ncJob.ttypes.ncTJob()
                        _elem133.read(iprot)
                        self.success.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cloud_backup_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter134 in self.success:
                iter134.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cloud_backup_jobs_result)
get_cloud_backup_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_jobs_args(object):
    """
    Attributes:
     - requests

    """


    def __init__(self, requests=None,):
        self.requests = requests

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = ncJob.ttypes.ncFilterUpdateRequest()
                        _elem140.read(iprot)
                        self.requests.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_jobs_args')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter141 in self.requests:
                iter141.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_jobs_args)
update_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [ncJob.ttypes.ncFilterUpdateRequest, None], False), None, ),  # 1
)


class update_data_sources_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncUpdateDatasourceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_data_sources_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_data_sources_args)
update_data_sources_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncUpdateDatasourceRequest, None], None, ),  # 1
)


class remove_all_jobs_by_client_ids_args(object):
    """
    Attributes:
     - clientIds

    """


    def __init__(self, clientIds=None,):
        self.clientIds = clientIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.clientIds = []
                    (_etype145, _size142) = iprot.readListBegin()
                    for _i146 in range(_size142):
                        _elem147 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.clientIds.append(_elem147)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_client_ids_args')
        if self.clientIds is not None:
            oprot.writeFieldBegin('clientIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.clientIds))
            for iter148 in self.clientIds:
                oprot.writeString(iter148.encode('utf-8') if sys.version_info[0] == 2 else iter148)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_client_ids_args)
remove_all_jobs_by_client_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'clientIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_all_jobs_by_client_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_client_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_client_ids_result)
remove_all_jobs_by_client_ids_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_datasource_jobs_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncBackupSvcDataSourceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_jobs_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_jobs_args)
get_datasource_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncBackupSvcDataSourceRequest, None], None, ),  # 1
)


class get_datasource_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype150, _vtype151, _size149) = iprot.readMapBegin()
                    for _i153 in range(_size149):
                        _key154 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val155 = []
                        (_etype159, _size156) = iprot.readListBegin()
                        for _i160 in range(_size156):
                            _elem161 = ncJob.ttypes.ncTJob()
                            _elem161.read(iprot)
                            _val155.append(_elem161)
                        iprot.readListEnd()
                        self.success[_key154] = _val155
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter162, viter163 in self.success.items():
                oprot.writeString(kiter162.encode('utf-8') if sys.version_info[0] == 2 else kiter162)
                oprot.writeListBegin(TType.STRUCT, len(viter163))
                for iter164 in viter163:
                    iter164.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_jobs_result)
get_datasource_jobs_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.LIST, (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_vplatform_ids_args(object):
    """
    Attributes:
     - vplatformIds

    """


    def __init__(self, vplatformIds=None,):
        self.vplatformIds = vplatformIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vplatformIds = []
                    (_etype168, _size165) = iprot.readListBegin()
                    for _i169 in range(_size165):
                        _elem170 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vplatformIds.append(_elem170)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_args')
        if self.vplatformIds is not None:
            oprot.writeFieldBegin('vplatformIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.vplatformIds))
            for iter171 in self.vplatformIds:
                oprot.writeString(iter171.encode('utf-8') if sys.version_info[0] == 2 else iter171)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_vplatform_ids_args)
remove_all_jobs_by_vplatform_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vplatformIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_all_jobs_by_vplatform_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_vplatform_ids_result)
remove_all_jobs_by_vplatform_ids_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_backup_media_and_username_args(object):
    """
    Attributes:
     - usernames
     - cloud_storage_name

    """


    def __init__(self, usernames=None, cloud_storage_name=None,):
        self.usernames = usernames
        self.cloud_storage_name = cloud_storage_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cloud_storage_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_backup_media_and_username_args')
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter178 in self.usernames:
                oprot.writeString(iter178.encode('utf-8') if sys.version_info[0] == 2 else iter178)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cloud_storage_name is not None:
            oprot.writeFieldBegin('cloud_storage_name', TType.STRING, 2)
            oprot.writeString(self.cloud_storage_name.encode('utf-8') if sys.version_info[0] == 2 else self.cloud_storage_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_backup_media_and_username_args)
remove_all_jobs_by_backup_media_and_username_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'cloud_storage_name', 'UTF8', None, ),  # 2
)


class remove_all_jobs_by_backup_media_and_username_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_backup_media_and_username_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_backup_media_and_username_result)
remove_all_jobs_by_backup_media_and_username_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_contentcloud_resources_args(object):
    """
    Attributes:
     - contentcloud_resource_ids

    """


    def __init__(self, contentcloud_resource_ids=None,):
        self.contentcloud_resource_ids = contentcloud_resource_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.contentcloud_resource_ids = set()
                    (_etype182, _size179) = iprot.readSetBegin()
                    for _i183 in range(_size179):
                        _elem184 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.contentcloud_resource_ids.add(_elem184)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_contentcloud_resources_args')
        if self.contentcloud_resource_ids is not None:
            oprot.writeFieldBegin('contentcloud_resource_ids', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.contentcloud_resource_ids))
            for iter185 in self.contentcloud_resource_ids:
                oprot.writeString(iter185.encode('utf-8') if sys.version_info[0] == 2 else iter185)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.contentcloud_resource_ids is None:
            raise TProtocolException(message='Required field contentcloud_resource_ids is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_contentcloud_resources_args)
remove_all_jobs_by_contentcloud_resources_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'contentcloud_resource_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_all_jobs_by_contentcloud_resources_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_contentcloud_resources_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_contentcloud_resources_result)
remove_all_jobs_by_contentcloud_resources_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_datasource_by_client_args(object):
    """
    Attributes:
     - client_id
     - job_is_backup

    """


    def __init__(self, client_id=None, job_is_backup=None,):
        self.client_id = client_id
        self.job_is_backup = job_is_backup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_is_backup = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_by_client_args')
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 1)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        if self.job_is_backup is not None:
            oprot.writeFieldBegin('job_is_backup', TType.STRING, 2)
            oprot.writeString(self.job_is_backup.encode('utf-8') if sys.version_info[0] == 2 else self.job_is_backup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.client_id is None:
            raise TProtocolException(message='Required field client_id is unset!')
        if self.job_is_backup is None:
            raise TProtocolException(message='Required field job_is_backup is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_by_client_args)
get_datasource_by_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_is_backup', 'UTF8', None, ),  # 2
)


class get_datasource_by_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_by_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter192 in self.success:
                oprot.writeString(iter192.encode('utf-8') if sys.version_info[0] == 2 else iter192)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_by_client_result)
get_datasource_by_client_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class add_schedule_jobs_args(object):
    """
    Attributes:
     - ids

    """


    def __init__(self, ids=None,):
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ids.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_schedule_jobs_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for iter199 in self.ids:
                oprot.writeString(iter199.encode('utf-8') if sys.version_info[0] == 2 else iter199)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_schedule_jobs_args)
add_schedule_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class add_schedule_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype203, _size200) = iprot.readListBegin()
                    for _i204 in range(_size200):
                        _elem205 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem205)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_schedule_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter206 in self.success:
                oprot.writeString(iter206.encode('utf-8') if sys.version_info[0] == 2 else iter206)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_schedule_jobs_result)
add_schedule_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_schedule_jobs_args(object):
    """
    Attributes:
     - ids

    """


    def __init__(self, ids=None,):
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ids.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_jobs_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for iter213 in self.ids:
                oprot.writeString(iter213.encode('utf-8') if sys.version_info[0] == 2 else iter213)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_jobs_args)
modify_schedule_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class modify_schedule_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter220 in self.success:
                oprot.writeString(iter220.encode('utf-8') if sys.version_info[0] == 2 else iter220)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_jobs_result)
modify_schedule_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_jobs_args)
get_schedule_jobs_args.thrift_spec = (
)


class get_schedule_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype224, _size221) = iprot.readListBegin()
                    for _i225 in range(_size221):
                        _elem226 = ncScheTask_v2.ttypes.ncToolScheInfo()
                        _elem226.read(iprot)
                        self.success.append(_elem226)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter227 in self.success:
                iter227.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_jobs_result)
get_schedule_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncScheTask_v2.ttypes.ncToolScheInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class online_reload_args(object):
    """
    Attributes:
     - ip

    """


    def __init__(self, ip=None,):
        self.ip = ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('online_reload_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(online_reload_args)
online_reload_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
)


class online_reload_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('online_reload_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(online_reload_result)
online_reload_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class offline_reload_args(object):
    """
    Attributes:
     - ip

    """


    def __init__(self, ip=None,):
        self.ip = ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offline_reload_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offline_reload_args)
offline_reload_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
)


class offline_reload_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('offline_reload_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(offline_reload_result)
offline_reload_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class migrate_node_vibration_args(object):
    """
    Attributes:
     - ip_to_state

    """


    def __init__(self, ip_to_state=None,):
        self.ip_to_state = ip_to_state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.ip_to_state = {}
                    (_ktype229, _vtype230, _size228) = iprot.readMapBegin()
                    for _i232 in range(_size228):
                        _key233 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val234 = iprot.readI32()
                        self.ip_to_state[_key233] = _val234
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('migrate_node_vibration_args')
        if self.ip_to_state is not None:
            oprot.writeFieldBegin('ip_to_state', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.ip_to_state))
            for kiter235, viter236 in self.ip_to_state.items():
                oprot.writeString(kiter235.encode('utf-8') if sys.version_info[0] == 2 else kiter235)
                oprot.writeI32(viter236)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(migrate_node_vibration_args)
migrate_node_vibration_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'ip_to_state', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 1
)


class migrate_node_vibration_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('migrate_node_vibration_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(migrate_node_vibration_result)
migrate_node_vibration_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class app_ctrl_push_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.req = {}
                    (_ktype238, _vtype239, _size237) = iprot.readMapBegin()
                    for _i241 in range(_size237):
                        _key242 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val243 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.req[_key242] = _val243
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('app_ctrl_push_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.req))
            for kiter244, viter245 in self.req.items():
                oprot.writeString(kiter244.encode('utf-8') if sys.version_info[0] == 2 else kiter244)
                oprot.writeString(viter245.encode('utf-8') if sys.version_info[0] == 2 else viter245)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(app_ctrl_push_args)
app_ctrl_push_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'req', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class app_ctrl_push_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('app_ctrl_push_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(app_ctrl_push_result)
app_ctrl_push_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_data_for_ams_args(object):
    """
    Attributes:
     - kwargs

    """


    def __init__(self, kwargs=None,):
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_args')
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 1)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_args)
get_data_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'kwargs', 'UTF8', None, ),  # 1
)


class get_data_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_result)
get_data_for_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class is_exists_running_job_on_client_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_running_job_on_client_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_running_job_on_client_args)
is_exists_running_job_on_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class is_exists_running_job_on_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_running_job_on_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_running_job_on_client_result)
is_exists_running_job_on_client_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class client_exsit_volume_job_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_volume_job_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_volume_job_args)
client_exsit_volume_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class client_exsit_volume_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_volume_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_volume_job_result)
client_exsit_volume_job_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class do_operation_from_ams_args(object):
    """
    Attributes:
     - target
     - method
     - kwargs

    """


    def __init__(self, target=None, method=None, kwargs=None,):
        self.target = target
        self.method = method
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.target = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_args')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.STRING, 1)
            oprot.writeString(self.target.encode('utf-8') if sys.version_info[0] == 2 else self.target)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 3)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_args)
do_operation_from_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'target', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'kwargs', 'UTF8', None, ),  # 3
)


class do_operation_from_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_result)
do_operation_from_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_status_by_contentcloud_resources_args(object):
    """
    Attributes:
     - ids

    """


    def __init__(self, ids=None,):
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ids = []
                    (_etype249, _size246) = iprot.readListBegin()
                    for _i250 in range(_size246):
                        _elem251 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.ids.append(_elem251)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_status_by_contentcloud_resources_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.ids))
            for iter252 in self.ids:
                oprot.writeString(iter252.encode('utf-8') if sys.version_info[0] == 2 else iter252)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_status_by_contentcloud_resources_args)
get_jobs_status_by_contentcloud_resources_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_jobs_status_by_contentcloud_resources_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype256, _size253) = iprot.readListBegin()
                    for _i257 in range(_size253):
                        _elem258 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem258)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_status_by_contentcloud_resources_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter259 in self.success:
                oprot.writeString(iter259.encode('utf-8') if sys.version_info[0] == 2 else iter259)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_status_by_contentcloud_resources_result)
get_jobs_status_by_contentcloud_resources_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_sourceId_args(object):
    """
    Attributes:
     - sourceType
     - svcType
     - sourceId
     - relation

    """


    def __init__(self, sourceType=None, svcType=None, sourceId=None, relation=1,):
        self.sourceType = sourceType
        self.svcType = svcType
        self.sourceId = sourceId
        self.relation = relation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sourceType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sourceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.relation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_sourceId_args')
        if self.sourceType is not None:
            oprot.writeFieldBegin('sourceType', TType.I32, 1)
            oprot.writeI32(self.sourceType)
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        if self.sourceId is not None:
            oprot.writeFieldBegin('sourceId', TType.STRING, 3)
            oprot.writeString(self.sourceId.encode('utf-8') if sys.version_info[0] == 2 else self.sourceId)
            oprot.writeFieldEnd()
        if self.relation is not None:
            oprot.writeFieldBegin('relation', TType.I32, 4)
            oprot.writeI32(self.relation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_sourceId_args)
get_jobs_by_sourceId_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sourceType', None, None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
    (3, TType.STRING, 'sourceId', 'UTF8', None, ),  # 3
    (4, TType.I32, 'relation', None, 1, ),  # 4
)


class get_jobs_by_sourceId_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype263, _size260) = iprot.readListBegin()
                    for _i264 in range(_size260):
                        _elem265 = ncJob.ttypes.ncTJob()
                        _elem265.read(iprot)
                        self.success.append(_elem265)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_sourceId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter266 in self.success:
                iter266.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_sourceId_result)
get_jobs_by_sourceId_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class GetKeyMaterial_args(object):
    """
    Attributes:
     - KeyId
     - DeviceId

    """


    def __init__(self, KeyId=None, DeviceId=None,):
        self.KeyId = KeyId
        self.DeviceId = DeviceId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.KeyId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.DeviceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetKeyMaterial_args')
        if self.KeyId is not None:
            oprot.writeFieldBegin('KeyId', TType.STRING, 1)
            oprot.writeString(self.KeyId.encode('utf-8') if sys.version_info[0] == 2 else self.KeyId)
            oprot.writeFieldEnd()
        if self.DeviceId is not None:
            oprot.writeFieldBegin('DeviceId', TType.STRING, 2)
            oprot.writeString(self.DeviceId.encode('utf-8') if sys.version_info[0] == 2 else self.DeviceId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetKeyMaterial_args)
GetKeyMaterial_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'KeyId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'DeviceId', 'UTF8', None, ),  # 2
)


class GetKeyMaterial_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncJob.ttypes.ncKmsKeyMaterial()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = ncException.ttypes.ncException()
                    self.err.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetKeyMaterial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetKeyMaterial_result)
GetKeyMaterial_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncJob.ttypes.ncKmsKeyMaterial, None], None, ),  # 0
    (1, TType.STRUCT, 'err', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_dict_export_args(object):
    """
    Attributes:
     - body
     - jobInstanceId
     - user

    """


    def __init__(self, body=None, jobInstanceId=None, user=None,):
        self.body = body
        self.jobInstanceId = jobInstanceId
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.body = {}
                    (_ktype268, _vtype269, _size267) = iprot.readMapBegin()
                    for _i271 in range(_size267):
                        _key272 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val273 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.body[_key272] = _val273
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobInstanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.user = ncUser.ttypes.ncUserInfo()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dict_export_args')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
            for kiter274, viter275 in self.body.items():
                oprot.writeString(kiter274.encode('utf-8') if sys.version_info[0] == 2 else kiter274)
                oprot.writeString(viter275.encode('utf-8') if sys.version_info[0] == 2 else viter275)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.jobInstanceId is not None:
            oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
            oprot.writeString(self.jobInstanceId.encode('utf-8') if sys.version_info[0] == 2 else self.jobInstanceId)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 3)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dict_export_args)
get_dict_export_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'body', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'jobInstanceId', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'user', [ncUser.ttypes.ncUserInfo, None], None, ),  # 3
)


class get_dict_export_result(object):
    """
    Attributes:
     - success
     - err

    """


    def __init__(self, success=None, err=None,):
        self.success = success
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype277, _vtype278, _size276) = iprot.readMapBegin()
                    for _i280 in range(_size276):
                        _key281 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val282 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key281] = _val282
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err = ncException.ttypes.ncException()
                    self.err.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dict_export_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter283, viter284 in self.success.items():
                oprot.writeString(kiter283.encode('utf-8') if sys.version_info[0] == 2 else kiter283)
                oprot.writeString(viter284.encode('utf-8') if sys.version_info[0] == 2 else viter284)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.STRUCT, 1)
            self.err.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dict_export_result)
get_dict_export_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'err', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_datasource_args(object):
    """
    Attributes:
     - datasource
     - clientId
     - dbRunUserName

    """


    def __init__(self, datasource=None, clientId=None, dbRunUserName=None,):
        self.datasource = datasource
        self.clientId = clientId
        self.dbRunUserName = dbRunUserName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.datasource = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbRunUserName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_datasource_args')
        if self.datasource is not None:
            oprot.writeFieldBegin('datasource', TType.STRING, 1)
            oprot.writeString(self.datasource.encode('utf-8') if sys.version_info[0] == 2 else self.datasource)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 2)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.dbRunUserName is not None:
            oprot.writeFieldBegin('dbRunUserName', TType.STRING, 3)
            oprot.writeString(self.dbRunUserName.encode('utf-8') if sys.version_info[0] == 2 else self.dbRunUserName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_datasource_args)
get_jobs_by_datasource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'datasource', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'dbRunUserName', 'UTF8', None, ),  # 3
)


class get_jobs_by_datasource_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = ncJob.ttypes.ncBackupJob()
                        _elem290.read(iprot)
                        self.success.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_datasource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter291 in self.success:
                iter291.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_datasource_result)
get_jobs_by_datasource_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncBackupJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_backup_jobs_by_node_ip_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_node_ip_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_node_ip_args)
get_backup_jobs_by_node_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_backup_jobs_by_node_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_node_ip_result)
get_backup_jobs_by_node_ip_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_backup_jobs_by_volume_id_args(object):
    """
    Attributes:
     - volume_id

    """


    def __init__(self, volume_id=None,):
        self.volume_id = volume_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_volume_id_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_volume_id_args)
get_backup_jobs_by_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
)


class get_backup_jobs_by_volume_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_volume_id_result)
get_backup_jobs_by_volume_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_permanent_increment_job_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_permanent_increment_job_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_permanent_increment_job_args)
get_permanent_increment_job_args.thrift_spec = (
)


class get_permanent_increment_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype295, _size292) = iprot.readListBegin()
                    for _i296 in range(_size292):
                        _elem297 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem297)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_permanent_increment_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter298 in self.success:
                oprot.writeString(iter298.encode('utf-8') if sys.version_info[0] == 2 else iter298)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_permanent_increment_job_result)
get_permanent_increment_job_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_user_has_data_args(object):
    """
    Attributes:
     - user_list

    """


    def __init__(self, user_list=None,):
        self.user_list = user_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.user_list = []
                    (_etype302, _size299) = iprot.readListBegin()
                    for _i303 in range(_size299):
                        _elem304 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.user_list.append(_elem304)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_args')
        if self.user_list is not None:
            oprot.writeFieldBegin('user_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.user_list))
            for iter305 in self.user_list:
                oprot.writeString(iter305.encode('utf-8') if sys.version_info[0] == 2 else iter305)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_args)
check_user_has_data_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'user_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class check_user_has_data_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter312 in self.success:
                oprot.writeString(iter312.encode('utf-8') if sys.version_info[0] == 2 else iter312)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_result)
check_user_has_data_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_job_count_info_args(object):
    """
    Attributes:
     - startTime
     - userId

    """


    def __init__(self, startTime=None, userId=None,):
        self.startTime = startTime
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_count_info_args')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_count_info_args)
get_job_count_info_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'startTime', None, None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class get_job_count_info_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncJob.ttypes.ncBackupJobCountInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_count_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_count_info_result)
get_job_count_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncJob.ttypes.ncBackupJobCountInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_strategy_export_args(object):
    """
    Attributes:
     - strategy_ids
     - user_name

    """


    def __init__(self, strategy_ids=None, user_name=None,):
        self.strategy_ids = strategy_ids
        self.user_name = user_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.strategy_ids = []
                    (_etype316, _size313) = iprot.readListBegin()
                    for _i317 in range(_size313):
                        _elem318 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.strategy_ids.append(_elem318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_export_args')
        if self.strategy_ids is not None:
            oprot.writeFieldBegin('strategy_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.strategy_ids))
            for iter319 in self.strategy_ids:
                oprot.writeString(iter319.encode('utf-8') if sys.version_info[0] == 2 else iter319)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 2)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_export_args)
get_strategy_export_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'strategy_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'user_name', 'UTF8', None, ),  # 2
)


class get_strategy_export_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype321, _vtype322, _size320) = iprot.readMapBegin()
                    for _i324 in range(_size320):
                        _key325 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val326 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key325] = _val326
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_export_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter327, viter328 in self.success.items():
                oprot.writeString(kiter327.encode('utf-8') if sys.version_info[0] == 2 else kiter327)
                oprot.writeString(viter328.encode('utf-8') if sys.version_info[0] == 2 else viter328)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_export_result)
get_strategy_export_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_deleted_backup_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_deleted_backup_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_deleted_backup_jobs_args)
get_deleted_backup_jobs_args.thrift_spec = (
)


class get_deleted_backup_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype330, _vtype331, _size329) = iprot.readMapBegin()
                    for _i333 in range(_size329):
                        _key334 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val335 = iprot.readI64()
                        self.success[_key334] = _val335
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_deleted_backup_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter336, viter337 in self.success.items():
                oprot.writeString(kiter336.encode('utf-8') if sys.version_info[0] == 2 else kiter336)
                oprot.writeI64(viter337)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_deleted_backup_jobs_result)
get_deleted_backup_jobs_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_cloud_storage_name_and_username_args(object):
    """
    Attributes:
     - usernames
     - cloud_storage_name

    """


    def __init__(self, usernames=None, cloud_storage_name=None,):
        self.usernames = usernames
        self.cloud_storage_name = cloud_storage_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.usernames = []
                    (_etype341, _size338) = iprot.readListBegin()
                    for _i342 in range(_size338):
                        _elem343 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.usernames.append(_elem343)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cloud_storage_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_cloud_storage_name_and_username_args')
        if self.usernames is not None:
            oprot.writeFieldBegin('usernames', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.usernames))
            for iter344 in self.usernames:
                oprot.writeString(iter344.encode('utf-8') if sys.version_info[0] == 2 else iter344)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cloud_storage_name is not None:
            oprot.writeFieldBegin('cloud_storage_name', TType.STRING, 2)
            oprot.writeString(self.cloud_storage_name.encode('utf-8') if sys.version_info[0] == 2 else self.cloud_storage_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_cloud_storage_name_and_username_args)
remove_all_jobs_by_cloud_storage_name_and_username_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'usernames', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'cloud_storage_name', 'UTF8', None, ),  # 2
)


class remove_all_jobs_by_cloud_storage_name_and_username_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_cloud_storage_name_and_username_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_cloud_storage_name_and_username_result)
remove_all_jobs_by_cloud_storage_name_and_username_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_extra_resource_by_username_args(object):
    """
    Attributes:
     - user_names

    """


    def __init__(self, user_names=None,):
        self.user_names = user_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.user_names = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.user_names.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_extra_resource_by_username_args')
        if self.user_names is not None:
            oprot.writeFieldBegin('user_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.user_names))
            for iter351 in self.user_names:
                oprot.writeString(iter351.encode('utf-8') if sys.version_info[0] == 2 else iter351)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_extra_resource_by_username_args)
delete_extra_resource_by_username_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'user_names', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class delete_extra_resource_by_username_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_extra_resource_by_username_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_extra_resource_by_username_result)
delete_extra_resource_by_username_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_sub_using_num_args(object):
    """
    Attributes:
     - sub_license_types

    """


    def __init__(self, sub_license_types=None,):
        self.sub_license_types = sub_license_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.sub_license_types = []
                    (_etype355, _size352) = iprot.readListBegin()
                    for _i356 in range(_size352):
                        _elem357 = iprot.readI32()
                        self.sub_license_types.append(_elem357)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sub_using_num_args')
        if self.sub_license_types is not None:
            oprot.writeFieldBegin('sub_license_types', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.sub_license_types))
            for iter358 in self.sub_license_types:
                oprot.writeI32(iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sub_using_num_args)
get_sub_using_num_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'sub_license_types', (TType.I32, None, False), None, ),  # 1
)


class get_sub_using_num_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype360, _vtype361, _size359) = iprot.readMapBegin()
                    for _i363 in range(_size359):
                        _key364 = iprot.readI32()
                        _val365 = iprot.readI32()
                        self.success[_key364] = _val365
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sub_using_num_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.success))
            for kiter366, viter367 in self.success.items():
                oprot.writeI32(kiter366)
                oprot.writeI32(viter367)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sub_using_num_result)
get_sub_using_num_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_jobs_by_pages_args(object):
    """
    Attributes:
     - BaseReq

    """


    def __init__(self, BaseReq=None,):
        self.BaseReq = BaseReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.BaseReq = ncJob.ttypes.ncJobFilterRequest()
                    self.BaseReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_by_pages_args')
        if self.BaseReq is not None:
            oprot.writeFieldBegin('BaseReq', TType.STRUCT, 1)
            self.BaseReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.BaseReq is None:
            raise TProtocolException(message='Required field BaseReq is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_by_pages_args)
get_all_jobs_by_pages_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'BaseReq', [ncJob.ttypes.ncJobFilterRequest, None], None, ),  # 1
)


class get_all_jobs_by_pages_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncBackupJobsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_by_pages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_by_pages_result)
get_all_jobs_by_pages_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncBackupJobsResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_task_src_from_DB_InBackup_args(object):
    """
    Attributes:
     - job_id

    """


    def __init__(self, job_id=None,):
        self.job_id = job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_src_from_DB_InBackup_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_src_from_DB_InBackup_args)
get_task_src_from_DB_InBackup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
)


class get_task_src_from_DB_InBackup_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_src_from_DB_InBackup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter374 in self.success:
                oprot.writeString(iter374.encode('utf-8') if sys.version_info[0] == 2 else iter374)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_src_from_DB_InBackup_result)
get_task_src_from_DB_InBackup_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

