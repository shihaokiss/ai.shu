# -*- coding: UTF-8 -*-
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=UTF-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    CdmStoreMgm服务接口

    """
    def Microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw ncException

        """
        pass

    def get_volume(self, volume_name, volume_type):
        """
        有卷名卷类型获取卷信息


        Parameters:
         - volume_name
         - volume_type

        """
        pass

    def get_volume_by_id(self, volume_id, volume_type):
        """
        有卷id卷类型获取卷信息


        Parameters:
         - volume_id
         - volume_type

        """
        pass

    def get_pool(self, poolId, poolType):
        """
        获取指定存储池信息
        @ throw ncException

        Parameters:
         - poolId
         - poolType

        """
        pass

    def get_pools_by(self, request):
        """
        获取条件过滤存储池信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        pass

    def update_snap_pool_mdisk(self, request):
        """
        获取更新块磁盘和快照池状态信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        pass

    def get_m_disk_by(self, request):
        """
        获取条件过滤快磁盘信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        pass

    def update_m_disk(self, request):
        """
        更新快磁盘信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        pass

    def get_pools(self, poolType):
        """
        获取指定类型存储池信息
        @ throw ncExceptions

        Parameters:
         - poolType

        """
        pass

    def create_base_volume(self, request):
        """
        创建基本卷
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def delete_base_volumes(self, baseVolumeIds, poolType):
        """
        删除基本卷
        @ throw ncException

        Parameters:
         - baseVolumeIds
         - poolType

        """
        pass

    def delete_base_volumes_by(self, request):
        """
        通过卷信息删除基本卷
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def get_base_volumes_space_by(self, request):
        """
        通过卷信息批量获取基本卷卷容量
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def get_base_volume_space(self, baseVolumeId, poolType):
        """
        获取基本卷卷容量
        @ throw ncException

        Parameters:
         - baseVolumeId
         - poolType

        """
        pass

    def create_snap_volume(self, baseVolumeId, poolType):
        """
        创建快照卷
        @ throw ncException


        Parameters:
         - baseVolumeId
         - poolType

        """
        pass

    def create_snap_volume_by(self, request):
        """
        通过卷信息创建快照卷
        @ throw ncException


        Parameters:
         - request

        """
        pass

    def get_snap_volumes_space_by(self, request):
        """
        通过卷信息批量获取基本卷卷容量
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def delete_snap_volumes(self, snapVolumeIds, poolType):
        """
        删除快照卷
        @ throw ncException

        Parameters:
         - snapVolumeIds
         - poolType

        """
        pass

    def delete_snap_volumes_by(self, request):
        """
        通过卷信息删除快照卷
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def get_snap_volume_space(self, snapVolumeId, poolType):
        """
        获取快照卷容量
        @ throw ncException

        Parameters:
         - snapVolumeId
         - poolType

        """
        pass

    def create_clone_volume_by(self, request):
        """
        通过卷信息创建克隆卷
        @ throw ncException


        Parameters:
         - request

        """
        pass

    def get_clone_volumes_space_by(self, request):
        """
        通过卷信息批量获取克隆卷容量
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def create_clone_volume(self, snapVolumeId, poolType):
        """
        创建克隆卷
        @ throw ncException


        Parameters:
         - snapVolumeId
         - poolType

        """
        pass

    def delete_clone_volumes(self, cloneVolumeIds, poolType):
        """
        删除克隆卷
        @ throw ncException

        Parameters:
         - cloneVolumeIds
         - poolType

        """
        pass

    def delete_clone_volumes_by(self, request):
        """
        通过卷信息删除克隆卷
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def get_clone_volume_space(self, cloneVolumeId, poolType):
        """
        获取克隆卷容量
        @ throw ncException

        Parameters:
         - cloneVolumeId
         - poolType

        """
        pass

    def create_volume_mapping(self, request):
        """
        创建卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        pass

    def delete_volume_mapping(self, request):
        """
        删除卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        pass

    def async_create_volume_mappings(self, requests, jobId):
        """
        异步批量创建卷映射
        @ throw ncException

        Parameters:
         - requests
         - jobId

        """
        pass

    def query_create_volume_mappings(self, request):
        """
        同步查询卷映射创建信息
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def async_delete_volume_mappings(self, requests, jobId):
        """
        异步批量删除卷映射
        @ throw ncException

        Parameters:
         - requests
         - jobId

        """
        pass

    def query_delete_volume_mappings(self, request):
        """
        同步查询卷映射删除信息
        @ throw ncException

        Parameters:
         - request

        """
        pass

    def get_volume_mappings(self, request):
        """
        获取卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        pass

    def get_target_wwn(self, deviceIp, poolType, poolId):
        """
        Parameters:
         - deviceIp
         - poolType
         - poolId

        """
        pass

    def get_all_target_wwn(self, poolType, poolId, linkId):
        """
        获取集群所有节点的ip以及对应的iqn
        @ throw ncExeption

        Parameters:
         - poolType
         - poolId
         - linkId

        """
        pass

    def get_m_disk(self, path, poolType, nodeIp):
        """
        获取块和存储池映射

        Parameters:
         - path
         - poolType
         - nodeIp

        """
        pass

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        pass

    def get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
        """
        根据克隆卷ID得到基本卷信息

        Parameters:
         - clone_volume_id
         - poolType

        """
        pass

    def get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
        """
        根据快照卷ID得到基本卷信息

        Parameters:
         - snap_volume_id
         - poolType

        """
        pass

    def get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
        """
        根据快照卷ID得到pool的信息

        Parameters:
         - snap_volume_id
         - poolType

        """
        pass

    def get_all_base_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有基本卷的信息

        Parameters:
         - poolType

        """
        pass

    def get_all_clone_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有克隆卷的信息

        Parameters:
         - poolType

        """
        pass

    def get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
        """
        容量授权使用，根据卷类型和ID查询占用的容量,单位字节

        Parameters:
         - jobVolumeRequestList
         - poolType

        """
        pass

    def get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
        """
        容量授权使用，根据卷类型和基本卷ID查询占用的容量,单位字节

        Parameters:
         - BaseVolumeIdList
         - poolType

        """
        pass

    def get_all_spaces(self, jobVolumeRequestList, poolType):
        """
        根据卷类型和ID查询快照卷和克隆卷占用的容量,单位字节

        Parameters:
         - jobVolumeRequestList
         - poolType

        """
        pass

    def get_all_snap_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有快照卷的信息

        Parameters:
         - poolType

        """
        pass

    def notify_space_monitor(self):
        """
        通知空间检测

        """
        pass

    def get_node_ip_by_volume_id(self, volumeId, poolType):
        """
        根据volumeId和poolType获取节点Ip


        Parameters:
         - volumeId
         - poolType

        """
        pass

    def get_server_ip_by_pool_id(self, poolId, poolType):
        """
        根据poolId和poolType获取serverIp


        Parameters:
         - poolId
         - poolType

        """
        pass

    def snapshot_volume_sync(self, request):
        """
        快照卷同步


        Parameters:
         - request

        """
        pass

    def stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        """
        停止快照卷同步


        Parameters:
         - snapshotVolumeSyncId
         - srcSnapshotPoolId

        """
        pass

    def get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        """
        查询快照同步状态信息


        Parameters:
         - snapshotVolumeSyncId
         - srcSnapshotPoolId

        """
        pass

    def finish_snapshot_volume_sync(self, request):
        """
        完成快照同步


        Parameters:
         - request

        """
        pass

    def finish_snyc_work(self, request):
        """
        插入快照卷信息


        Parameters:
         - request

        """
        pass

    def get_data_ip_by_pool_id(self, poolId, poolType):
        """
        获取存储池所在节点的数据传输ip


        Parameters:
         - poolId
         - poolType

        """
        pass

    def get_link_info(self, linkId):
        """
        获取链路信息


        Parameters:
         - linkId

        """
        pass

    def select_link(self, request, num):
        """
        选择链路


        Parameters:
         - request
         - num

        """
        pass

    def create_link(self, request):
        """
        创建链路


        Parameters:
         - request

        """
        pass

    def delete_link(self, request):
        """
        删除链路


        Parameters:
         - request

        """
        pass

    def get_fc(self, pool_id):
        """
        获取fc


        Parameters:
         - pool_id

        """
        pass


class Client(Iface):
    """
    CdmStoreMgm服务接口

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def Microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw ncException

        """
        self.send_Microprobe()
        self.recv_Microprobe()

    def send_Microprobe(self):
        self._oprot.writeMessageBegin('Microprobe', TMessageType.CALL, self._seqid)
        args = Microprobe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Microprobe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Microprobe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_volume(self, volume_name, volume_type):
        """
        有卷名卷类型获取卷信息


        Parameters:
         - volume_name
         - volume_type

        """
        self.send_get_volume(volume_name, volume_type)
        return self.recv_get_volume()

    def send_get_volume(self, volume_name, volume_type):
        self._oprot.writeMessageBegin('get_volume', TMessageType.CALL, self._seqid)
        args = get_volume_args()
        args.volume_name = volume_name
        args.volume_type = volume_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume failed: unknown result")

    def get_volume_by_id(self, volume_id, volume_type):
        """
        有卷id卷类型获取卷信息


        Parameters:
         - volume_id
         - volume_type

        """
        self.send_get_volume_by_id(volume_id, volume_type)
        return self.recv_get_volume_by_id()

    def send_get_volume_by_id(self, volume_id, volume_type):
        self._oprot.writeMessageBegin('get_volume_by_id', TMessageType.CALL, self._seqid)
        args = get_volume_by_id_args()
        args.volume_id = volume_id
        args.volume_type = volume_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume_by_id failed: unknown result")

    def get_pool(self, poolId, poolType):
        """
        获取指定存储池信息
        @ throw ncException

        Parameters:
         - poolId
         - poolType

        """
        self.send_get_pool(poolId, poolType)
        return self.recv_get_pool()

    def send_get_pool(self, poolId, poolType):
        self._oprot.writeMessageBegin('get_pool', TMessageType.CALL, self._seqid)
        args = get_pool_args()
        args.poolId = poolId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pool failed: unknown result")

    def get_pools_by(self, request):
        """
        获取条件过滤存储池信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        self.send_get_pools_by(request)
        return self.recv_get_pools_by()

    def send_get_pools_by(self, request):
        self._oprot.writeMessageBegin('get_pools_by', TMessageType.CALL, self._seqid)
        args = get_pools_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_pools_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_pools_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pools_by failed: unknown result")

    def update_snap_pool_mdisk(self, request):
        """
        获取更新块磁盘和快照池状态信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        self.send_update_snap_pool_mdisk(request)
        self.recv_update_snap_pool_mdisk()

    def send_update_snap_pool_mdisk(self, request):
        self._oprot.writeMessageBegin('update_snap_pool_mdisk', TMessageType.CALL, self._seqid)
        args = update_snap_pool_mdisk_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_snap_pool_mdisk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_snap_pool_mdisk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_m_disk_by(self, request):
        """
        获取条件过滤快磁盘信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        self.send_get_m_disk_by(request)
        return self.recv_get_m_disk_by()

    def send_get_m_disk_by(self, request):
        self._oprot.writeMessageBegin('get_m_disk_by', TMessageType.CALL, self._seqid)
        args = get_m_disk_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_m_disk_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_m_disk_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_m_disk_by failed: unknown result")

    def update_m_disk(self, request):
        """
        更新快磁盘信息
        @ throw ncExceptions

        Parameters:
         - request

        """
        self.send_update_m_disk(request)
        self.recv_update_m_disk()

    def send_update_m_disk(self, request):
        self._oprot.writeMessageBegin('update_m_disk', TMessageType.CALL, self._seqid)
        args = update_m_disk_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_m_disk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_m_disk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_pools(self, poolType):
        """
        获取指定类型存储池信息
        @ throw ncExceptions

        Parameters:
         - poolType

        """
        self.send_get_pools(poolType)
        return self.recv_get_pools()

    def send_get_pools(self, poolType):
        self._oprot.writeMessageBegin('get_pools', TMessageType.CALL, self._seqid)
        args = get_pools_args()
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_pools(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_pools_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pools failed: unknown result")

    def create_base_volume(self, request):
        """
        创建基本卷
        @ throw ncException

        Parameters:
         - request

        """
        self.send_create_base_volume(request)
        return self.recv_create_base_volume()

    def send_create_base_volume(self, request):
        self._oprot.writeMessageBegin('create_base_volume', TMessageType.CALL, self._seqid)
        args = create_base_volume_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_base_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_base_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_base_volume failed: unknown result")

    def delete_base_volumes(self, baseVolumeIds, poolType):
        """
        删除基本卷
        @ throw ncException

        Parameters:
         - baseVolumeIds
         - poolType

        """
        self.send_delete_base_volumes(baseVolumeIds, poolType)
        self.recv_delete_base_volumes()

    def send_delete_base_volumes(self, baseVolumeIds, poolType):
        self._oprot.writeMessageBegin('delete_base_volumes', TMessageType.CALL, self._seqid)
        args = delete_base_volumes_args()
        args.baseVolumeIds = baseVolumeIds
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_base_volumes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_base_volumes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def delete_base_volumes_by(self, request):
        """
        通过卷信息删除基本卷
        @ throw ncException

        Parameters:
         - request

        """
        self.send_delete_base_volumes_by(request)
        self.recv_delete_base_volumes_by()

    def send_delete_base_volumes_by(self, request):
        self._oprot.writeMessageBegin('delete_base_volumes_by', TMessageType.CALL, self._seqid)
        args = delete_base_volumes_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_base_volumes_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_base_volumes_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_base_volumes_space_by(self, request):
        """
        通过卷信息批量获取基本卷卷容量
        @ throw ncException

        Parameters:
         - request

        """
        self.send_get_base_volumes_space_by(request)
        return self.recv_get_base_volumes_space_by()

    def send_get_base_volumes_space_by(self, request):
        self._oprot.writeMessageBegin('get_base_volumes_space_by', TMessageType.CALL, self._seqid)
        args = get_base_volumes_space_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_base_volumes_space_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_base_volumes_space_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volumes_space_by failed: unknown result")

    def get_base_volume_space(self, baseVolumeId, poolType):
        """
        获取基本卷卷容量
        @ throw ncException

        Parameters:
         - baseVolumeId
         - poolType

        """
        self.send_get_base_volume_space(baseVolumeId, poolType)
        return self.recv_get_base_volume_space()

    def send_get_base_volume_space(self, baseVolumeId, poolType):
        self._oprot.writeMessageBegin('get_base_volume_space', TMessageType.CALL, self._seqid)
        args = get_base_volume_space_args()
        args.baseVolumeId = baseVolumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_base_volume_space(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_base_volume_space_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_space failed: unknown result")

    def create_snap_volume(self, baseVolumeId, poolType):
        """
        创建快照卷
        @ throw ncException


        Parameters:
         - baseVolumeId
         - poolType

        """
        self.send_create_snap_volume(baseVolumeId, poolType)
        return self.recv_create_snap_volume()

    def send_create_snap_volume(self, baseVolumeId, poolType):
        self._oprot.writeMessageBegin('create_snap_volume', TMessageType.CALL, self._seqid)
        args = create_snap_volume_args()
        args.baseVolumeId = baseVolumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_snap_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_snap_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_snap_volume failed: unknown result")

    def create_snap_volume_by(self, request):
        """
        通过卷信息创建快照卷
        @ throw ncException


        Parameters:
         - request

        """
        self.send_create_snap_volume_by(request)
        return self.recv_create_snap_volume_by()

    def send_create_snap_volume_by(self, request):
        self._oprot.writeMessageBegin('create_snap_volume_by', TMessageType.CALL, self._seqid)
        args = create_snap_volume_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_snap_volume_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_snap_volume_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_snap_volume_by failed: unknown result")

    def get_snap_volumes_space_by(self, request):
        """
        通过卷信息批量获取基本卷卷容量
        @ throw ncException

        Parameters:
         - request

        """
        self.send_get_snap_volumes_space_by(request)
        return self.recv_get_snap_volumes_space_by()

    def send_get_snap_volumes_space_by(self, request):
        self._oprot.writeMessageBegin('get_snap_volumes_space_by', TMessageType.CALL, self._seqid)
        args = get_snap_volumes_space_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_snap_volumes_space_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_snap_volumes_space_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_snap_volumes_space_by failed: unknown result")

    def delete_snap_volumes(self, snapVolumeIds, poolType):
        """
        删除快照卷
        @ throw ncException

        Parameters:
         - snapVolumeIds
         - poolType

        """
        self.send_delete_snap_volumes(snapVolumeIds, poolType)
        self.recv_delete_snap_volumes()

    def send_delete_snap_volumes(self, snapVolumeIds, poolType):
        self._oprot.writeMessageBegin('delete_snap_volumes', TMessageType.CALL, self._seqid)
        args = delete_snap_volumes_args()
        args.snapVolumeIds = snapVolumeIds
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_snap_volumes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_snap_volumes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def delete_snap_volumes_by(self, request):
        """
        通过卷信息删除快照卷
        @ throw ncException

        Parameters:
         - request

        """
        self.send_delete_snap_volumes_by(request)
        self.recv_delete_snap_volumes_by()

    def send_delete_snap_volumes_by(self, request):
        self._oprot.writeMessageBegin('delete_snap_volumes_by', TMessageType.CALL, self._seqid)
        args = delete_snap_volumes_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_snap_volumes_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_snap_volumes_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_snap_volume_space(self, snapVolumeId, poolType):
        """
        获取快照卷容量
        @ throw ncException

        Parameters:
         - snapVolumeId
         - poolType

        """
        self.send_get_snap_volume_space(snapVolumeId, poolType)
        return self.recv_get_snap_volume_space()

    def send_get_snap_volume_space(self, snapVolumeId, poolType):
        self._oprot.writeMessageBegin('get_snap_volume_space', TMessageType.CALL, self._seqid)
        args = get_snap_volume_space_args()
        args.snapVolumeId = snapVolumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_snap_volume_space(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_snap_volume_space_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_snap_volume_space failed: unknown result")

    def create_clone_volume_by(self, request):
        """
        通过卷信息创建克隆卷
        @ throw ncException


        Parameters:
         - request

        """
        self.send_create_clone_volume_by(request)
        return self.recv_create_clone_volume_by()

    def send_create_clone_volume_by(self, request):
        self._oprot.writeMessageBegin('create_clone_volume_by', TMessageType.CALL, self._seqid)
        args = create_clone_volume_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_clone_volume_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_clone_volume_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_clone_volume_by failed: unknown result")

    def get_clone_volumes_space_by(self, request):
        """
        通过卷信息批量获取克隆卷容量
        @ throw ncException

        Parameters:
         - request

        """
        self.send_get_clone_volumes_space_by(request)
        return self.recv_get_clone_volumes_space_by()

    def send_get_clone_volumes_space_by(self, request):
        self._oprot.writeMessageBegin('get_clone_volumes_space_by', TMessageType.CALL, self._seqid)
        args = get_clone_volumes_space_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clone_volumes_space_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clone_volumes_space_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clone_volumes_space_by failed: unknown result")

    def create_clone_volume(self, snapVolumeId, poolType):
        """
        创建克隆卷
        @ throw ncException


        Parameters:
         - snapVolumeId
         - poolType

        """
        self.send_create_clone_volume(snapVolumeId, poolType)
        return self.recv_create_clone_volume()

    def send_create_clone_volume(self, snapVolumeId, poolType):
        self._oprot.writeMessageBegin('create_clone_volume', TMessageType.CALL, self._seqid)
        args = create_clone_volume_args()
        args.snapVolumeId = snapVolumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_clone_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_clone_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_clone_volume failed: unknown result")

    def delete_clone_volumes(self, cloneVolumeIds, poolType):
        """
        删除克隆卷
        @ throw ncException

        Parameters:
         - cloneVolumeIds
         - poolType

        """
        self.send_delete_clone_volumes(cloneVolumeIds, poolType)
        self.recv_delete_clone_volumes()

    def send_delete_clone_volumes(self, cloneVolumeIds, poolType):
        self._oprot.writeMessageBegin('delete_clone_volumes', TMessageType.CALL, self._seqid)
        args = delete_clone_volumes_args()
        args.cloneVolumeIds = cloneVolumeIds
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_clone_volumes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_clone_volumes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def delete_clone_volumes_by(self, request):
        """
        通过卷信息删除克隆卷
        @ throw ncException

        Parameters:
         - request

        """
        self.send_delete_clone_volumes_by(request)
        self.recv_delete_clone_volumes_by()

    def send_delete_clone_volumes_by(self, request):
        self._oprot.writeMessageBegin('delete_clone_volumes_by', TMessageType.CALL, self._seqid)
        args = delete_clone_volumes_by_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_clone_volumes_by(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_clone_volumes_by_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_clone_volume_space(self, cloneVolumeId, poolType):
        """
        获取克隆卷容量
        @ throw ncException

        Parameters:
         - cloneVolumeId
         - poolType

        """
        self.send_get_clone_volume_space(cloneVolumeId, poolType)
        return self.recv_get_clone_volume_space()

    def send_get_clone_volume_space(self, cloneVolumeId, poolType):
        self._oprot.writeMessageBegin('get_clone_volume_space', TMessageType.CALL, self._seqid)
        args = get_clone_volume_space_args()
        args.cloneVolumeId = cloneVolumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clone_volume_space(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clone_volume_space_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clone_volume_space failed: unknown result")

    def create_volume_mapping(self, request):
        """
        创建卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        self.send_create_volume_mapping(request)
        return self.recv_create_volume_mapping()

    def send_create_volume_mapping(self, request):
        self._oprot.writeMessageBegin('create_volume_mapping', TMessageType.CALL, self._seqid)
        args = create_volume_mapping_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume_mapping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_mapping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_volume_mapping failed: unknown result")

    def delete_volume_mapping(self, request):
        """
        删除卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        self.send_delete_volume_mapping(request)
        self.recv_delete_volume_mapping()

    def send_delete_volume_mapping(self, request):
        self._oprot.writeMessageBegin('delete_volume_mapping', TMessageType.CALL, self._seqid)
        args = delete_volume_mapping_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume_mapping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_mapping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def async_create_volume_mappings(self, requests, jobId):
        """
        异步批量创建卷映射
        @ throw ncException

        Parameters:
         - requests
         - jobId

        """
        self.send_async_create_volume_mappings(requests, jobId)
        self.recv_async_create_volume_mappings()

    def send_async_create_volume_mappings(self, requests, jobId):
        self._oprot.writeMessageBegin('async_create_volume_mappings', TMessageType.CALL, self._seqid)
        args = async_create_volume_mappings_args()
        args.requests = requests
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_create_volume_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_create_volume_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def query_create_volume_mappings(self, request):
        """
        同步查询卷映射创建信息
        @ throw ncException

        Parameters:
         - request

        """
        self.send_query_create_volume_mappings(request)
        return self.recv_query_create_volume_mappings()

    def send_query_create_volume_mappings(self, request):
        self._oprot.writeMessageBegin('query_create_volume_mappings', TMessageType.CALL, self._seqid)
        args = query_create_volume_mappings_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_create_volume_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_create_volume_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_create_volume_mappings failed: unknown result")

    def async_delete_volume_mappings(self, requests, jobId):
        """
        异步批量删除卷映射
        @ throw ncException

        Parameters:
         - requests
         - jobId

        """
        self.send_async_delete_volume_mappings(requests, jobId)
        self.recv_async_delete_volume_mappings()

    def send_async_delete_volume_mappings(self, requests, jobId):
        self._oprot.writeMessageBegin('async_delete_volume_mappings', TMessageType.CALL, self._seqid)
        args = async_delete_volume_mappings_args()
        args.requests = requests
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_async_delete_volume_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = async_delete_volume_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def query_delete_volume_mappings(self, request):
        """
        同步查询卷映射删除信息
        @ throw ncException

        Parameters:
         - request

        """
        self.send_query_delete_volume_mappings(request)
        return self.recv_query_delete_volume_mappings()

    def send_query_delete_volume_mappings(self, request):
        self._oprot.writeMessageBegin('query_delete_volume_mappings', TMessageType.CALL, self._seqid)
        args = query_delete_volume_mappings_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_query_delete_volume_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = query_delete_volume_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "query_delete_volume_mappings failed: unknown result")

    def get_volume_mappings(self, request):
        """
        获取卷映射
        @ throw ncExeption

        Parameters:
         - request

        """
        self.send_get_volume_mappings(request)
        return self.recv_get_volume_mappings()

    def send_get_volume_mappings(self, request):
        self._oprot.writeMessageBegin('get_volume_mappings', TMessageType.CALL, self._seqid)
        args = get_volume_mappings_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume_mappings failed: unknown result")

    def get_target_wwn(self, deviceIp, poolType, poolId):
        """
        Parameters:
         - deviceIp
         - poolType
         - poolId

        """
        self.send_get_target_wwn(deviceIp, poolType, poolId)
        return self.recv_get_target_wwn()

    def send_get_target_wwn(self, deviceIp, poolType, poolId):
        self._oprot.writeMessageBegin('get_target_wwn', TMessageType.CALL, self._seqid)
        args = get_target_wwn_args()
        args.deviceIp = deviceIp
        args.poolType = poolType
        args.poolId = poolId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_wwn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_wwn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_wwn failed: unknown result")

    def get_all_target_wwn(self, poolType, poolId, linkId):
        """
        获取集群所有节点的ip以及对应的iqn
        @ throw ncExeption

        Parameters:
         - poolType
         - poolId
         - linkId

        """
        self.send_get_all_target_wwn(poolType, poolId, linkId)
        return self.recv_get_all_target_wwn()

    def send_get_all_target_wwn(self, poolType, poolId, linkId):
        self._oprot.writeMessageBegin('get_all_target_wwn', TMessageType.CALL, self._seqid)
        args = get_all_target_wwn_args()
        args.poolType = poolType
        args.poolId = poolId
        args.linkId = linkId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_target_wwn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_target_wwn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_target_wwn failed: unknown result")

    def get_m_disk(self, path, poolType, nodeIp):
        """
        获取块和存储池映射

        Parameters:
         - path
         - poolType
         - nodeIp

        """
        self.send_get_m_disk(path, poolType, nodeIp)
        return self.recv_get_m_disk()

    def send_get_m_disk(self, path, poolType, nodeIp):
        self._oprot.writeMessageBegin('get_m_disk', TMessageType.CALL, self._seqid)
        args = get_m_disk_args()
        args.path = path
        args.poolType = poolType
        args.nodeIp = nodeIp
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_m_disk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_m_disk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_m_disk failed: unknown result")

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        self.send_get_data_for_ams(kwargs)
        return self.recv_get_data_for_ams()

    def send_get_data_for_ams(self, kwargs):
        self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
        args = get_data_for_ams_args()
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

    def get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
        """
        根据克隆卷ID得到基本卷信息

        Parameters:
         - clone_volume_id
         - poolType

        """
        self.send_get_base_volume_info_by_clone_volume_id(clone_volume_id, poolType)
        return self.recv_get_base_volume_info_by_clone_volume_id()

    def send_get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
        self._oprot.writeMessageBegin('get_base_volume_info_by_clone_volume_id', TMessageType.CALL, self._seqid)
        args = get_base_volume_info_by_clone_volume_id_args()
        args.clone_volume_id = clone_volume_id
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_base_volume_info_by_clone_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_base_volume_info_by_clone_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_info_by_clone_volume_id failed: unknown result")

    def get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
        """
        根据快照卷ID得到基本卷信息

        Parameters:
         - snap_volume_id
         - poolType

        """
        self.send_get_base_volume_info_by_snap_volume_id(snap_volume_id, poolType)
        return self.recv_get_base_volume_info_by_snap_volume_id()

    def send_get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
        self._oprot.writeMessageBegin('get_base_volume_info_by_snap_volume_id', TMessageType.CALL, self._seqid)
        args = get_base_volume_info_by_snap_volume_id_args()
        args.snap_volume_id = snap_volume_id
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_base_volume_info_by_snap_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_base_volume_info_by_snap_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_info_by_snap_volume_id failed: unknown result")

    def get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
        """
        根据快照卷ID得到pool的信息

        Parameters:
         - snap_volume_id
         - poolType

        """
        self.send_get_binding_pool_by_snap_volume_id(snap_volume_id, poolType)
        return self.recv_get_binding_pool_by_snap_volume_id()

    def send_get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
        self._oprot.writeMessageBegin('get_binding_pool_by_snap_volume_id', TMessageType.CALL, self._seqid)
        args = get_binding_pool_by_snap_volume_id_args()
        args.snap_volume_id = snap_volume_id
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_binding_pool_by_snap_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_binding_pool_by_snap_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_binding_pool_by_snap_volume_id failed: unknown result")

    def get_all_base_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有基本卷的信息

        Parameters:
         - poolType

        """
        self.send_get_all_base_volume_ids(poolType)
        return self.recv_get_all_base_volume_ids()

    def send_get_all_base_volume_ids(self, poolType):
        self._oprot.writeMessageBegin('get_all_base_volume_ids', TMessageType.CALL, self._seqid)
        args = get_all_base_volume_ids_args()
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_base_volume_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_base_volume_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_base_volume_ids failed: unknown result")

    def get_all_clone_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有克隆卷的信息

        Parameters:
         - poolType

        """
        self.send_get_all_clone_volume_ids(poolType)
        return self.recv_get_all_clone_volume_ids()

    def send_get_all_clone_volume_ids(self, poolType):
        self._oprot.writeMessageBegin('get_all_clone_volume_ids', TMessageType.CALL, self._seqid)
        args = get_all_clone_volume_ids_args()
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_clone_volume_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_clone_volume_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_clone_volume_ids failed: unknown result")

    def get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
        """
        容量授权使用，根据卷类型和ID查询占用的容量,单位字节

        Parameters:
         - jobVolumeRequestList
         - poolType

        """
        self.send_get_all_spaces_by_volumes(jobVolumeRequestList, poolType)
        return self.recv_get_all_spaces_by_volumes()

    def send_get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
        self._oprot.writeMessageBegin('get_all_spaces_by_volumes', TMessageType.CALL, self._seqid)
        args = get_all_spaces_by_volumes_args()
        args.jobVolumeRequestList = jobVolumeRequestList
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_spaces_by_volumes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_spaces_by_volumes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_spaces_by_volumes failed: unknown result")

    def get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
        """
        容量授权使用，根据卷类型和基本卷ID查询占用的容量,单位字节

        Parameters:
         - BaseVolumeIdList
         - poolType

        """
        self.send_get_spaces_by_base_volume_id(BaseVolumeIdList, poolType)
        return self.recv_get_spaces_by_base_volume_id()

    def send_get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
        self._oprot.writeMessageBegin('get_spaces_by_base_volume_id', TMessageType.CALL, self._seqid)
        args = get_spaces_by_base_volume_id_args()
        args.BaseVolumeIdList = BaseVolumeIdList
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_spaces_by_base_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_spaces_by_base_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_spaces_by_base_volume_id failed: unknown result")

    def get_all_spaces(self, jobVolumeRequestList, poolType):
        """
        根据卷类型和ID查询快照卷和克隆卷占用的容量,单位字节

        Parameters:
         - jobVolumeRequestList
         - poolType

        """
        self.send_get_all_spaces(jobVolumeRequestList, poolType)
        return self.recv_get_all_spaces()

    def send_get_all_spaces(self, jobVolumeRequestList, poolType):
        self._oprot.writeMessageBegin('get_all_spaces', TMessageType.CALL, self._seqid)
        args = get_all_spaces_args()
        args.jobVolumeRequestList = jobVolumeRequestList
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_spaces(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_spaces_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_spaces failed: unknown result")

    def get_all_snap_volume_ids(self, poolType):
        """
        获取相应存储池类型的所有快照卷的信息

        Parameters:
         - poolType

        """
        self.send_get_all_snap_volume_ids(poolType)
        return self.recv_get_all_snap_volume_ids()

    def send_get_all_snap_volume_ids(self, poolType):
        self._oprot.writeMessageBegin('get_all_snap_volume_ids', TMessageType.CALL, self._seqid)
        args = get_all_snap_volume_ids_args()
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_snap_volume_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_snap_volume_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_snap_volume_ids failed: unknown result")

    def notify_space_monitor(self):
        """
        通知空间检测

        """
        self.send_notify_space_monitor()
        self.recv_notify_space_monitor()

    def send_notify_space_monitor(self):
        self._oprot.writeMessageBegin('notify_space_monitor', TMessageType.CALL, self._seqid)
        args = notify_space_monitor_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_notify_space_monitor(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = notify_space_monitor_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_node_ip_by_volume_id(self, volumeId, poolType):
        """
        根据volumeId和poolType获取节点Ip


        Parameters:
         - volumeId
         - poolType

        """
        self.send_get_node_ip_by_volume_id(volumeId, poolType)
        return self.recv_get_node_ip_by_volume_id()

    def send_get_node_ip_by_volume_id(self, volumeId, poolType):
        self._oprot.writeMessageBegin('get_node_ip_by_volume_id', TMessageType.CALL, self._seqid)
        args = get_node_ip_by_volume_id_args()
        args.volumeId = volumeId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_node_ip_by_volume_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_node_ip_by_volume_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_ip_by_volume_id failed: unknown result")

    def get_server_ip_by_pool_id(self, poolId, poolType):
        """
        根据poolId和poolType获取serverIp


        Parameters:
         - poolId
         - poolType

        """
        self.send_get_server_ip_by_pool_id(poolId, poolType)
        return self.recv_get_server_ip_by_pool_id()

    def send_get_server_ip_by_pool_id(self, poolId, poolType):
        self._oprot.writeMessageBegin('get_server_ip_by_pool_id', TMessageType.CALL, self._seqid)
        args = get_server_ip_by_pool_id_args()
        args.poolId = poolId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server_ip_by_pool_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_ip_by_pool_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server_ip_by_pool_id failed: unknown result")

    def snapshot_volume_sync(self, request):
        """
        快照卷同步


        Parameters:
         - request

        """
        self.send_snapshot_volume_sync(request)
        return self.recv_snapshot_volume_sync()

    def send_snapshot_volume_sync(self, request):
        self._oprot.writeMessageBegin('snapshot_volume_sync', TMessageType.CALL, self._seqid)
        args = snapshot_volume_sync_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_volume_sync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_volume_sync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_volume_sync failed: unknown result")

    def stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        """
        停止快照卷同步


        Parameters:
         - snapshotVolumeSyncId
         - srcSnapshotPoolId

        """
        self.send_stop_snapshot_volume_sync(snapshotVolumeSyncId, srcSnapshotPoolId)
        self.recv_stop_snapshot_volume_sync()

    def send_stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        self._oprot.writeMessageBegin('stop_snapshot_volume_sync', TMessageType.CALL, self._seqid)
        args = stop_snapshot_volume_sync_args()
        args.snapshotVolumeSyncId = snapshotVolumeSyncId
        args.srcSnapshotPoolId = srcSnapshotPoolId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_snapshot_volume_sync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_snapshot_volume_sync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        """
        查询快照同步状态信息


        Parameters:
         - snapshotVolumeSyncId
         - srcSnapshotPoolId

        """
        self.send_get_snapshot_volume_sync_status(snapshotVolumeSyncId, srcSnapshotPoolId)
        return self.recv_get_snapshot_volume_sync_status()

    def send_get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
        self._oprot.writeMessageBegin('get_snapshot_volume_sync_status', TMessageType.CALL, self._seqid)
        args = get_snapshot_volume_sync_status_args()
        args.snapshotVolumeSyncId = snapshotVolumeSyncId
        args.srcSnapshotPoolId = srcSnapshotPoolId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_snapshot_volume_sync_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_snapshot_volume_sync_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_snapshot_volume_sync_status failed: unknown result")

    def finish_snapshot_volume_sync(self, request):
        """
        完成快照同步


        Parameters:
         - request

        """
        self.send_finish_snapshot_volume_sync(request)
        return self.recv_finish_snapshot_volume_sync()

    def send_finish_snapshot_volume_sync(self, request):
        self._oprot.writeMessageBegin('finish_snapshot_volume_sync', TMessageType.CALL, self._seqid)
        args = finish_snapshot_volume_sync_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_finish_snapshot_volume_sync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = finish_snapshot_volume_sync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "finish_snapshot_volume_sync failed: unknown result")

    def finish_snyc_work(self, request):
        """
        插入快照卷信息


        Parameters:
         - request

        """
        self.send_finish_snyc_work(request)
        return self.recv_finish_snyc_work()

    def send_finish_snyc_work(self, request):
        self._oprot.writeMessageBegin('finish_snyc_work', TMessageType.CALL, self._seqid)
        args = finish_snyc_work_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_finish_snyc_work(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = finish_snyc_work_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "finish_snyc_work failed: unknown result")

    def get_data_ip_by_pool_id(self, poolId, poolType):
        """
        获取存储池所在节点的数据传输ip


        Parameters:
         - poolId
         - poolType

        """
        self.send_get_data_ip_by_pool_id(poolId, poolType)
        return self.recv_get_data_ip_by_pool_id()

    def send_get_data_ip_by_pool_id(self, poolId, poolType):
        self._oprot.writeMessageBegin('get_data_ip_by_pool_id', TMessageType.CALL, self._seqid)
        args = get_data_ip_by_pool_id_args()
        args.poolId = poolId
        args.poolType = poolType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_ip_by_pool_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_ip_by_pool_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_ip_by_pool_id failed: unknown result")

    def get_link_info(self, linkId):
        """
        获取链路信息


        Parameters:
         - linkId

        """
        self.send_get_link_info(linkId)
        return self.recv_get_link_info()

    def send_get_link_info(self, linkId):
        self._oprot.writeMessageBegin('get_link_info', TMessageType.CALL, self._seqid)
        args = get_link_info_args()
        args.linkId = linkId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_link_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_link_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_link_info failed: unknown result")

    def select_link(self, request, num):
        """
        选择链路


        Parameters:
         - request
         - num

        """
        self.send_select_link(request, num)
        return self.recv_select_link()

    def send_select_link(self, request, num):
        self._oprot.writeMessageBegin('select_link', TMessageType.CALL, self._seqid)
        args = select_link_args()
        args.request = request
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_select_link(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = select_link_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "select_link failed: unknown result")

    def create_link(self, request):
        """
        创建链路


        Parameters:
         - request

        """
        self.send_create_link(request)
        return self.recv_create_link()

    def send_create_link(self, request):
        self._oprot.writeMessageBegin('create_link', TMessageType.CALL, self._seqid)
        args = create_link_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_link(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_link_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_link failed: unknown result")

    def delete_link(self, request):
        """
        删除链路


        Parameters:
         - request

        """
        self.send_delete_link(request)
        self.recv_delete_link()

    def send_delete_link(self, request):
        self._oprot.writeMessageBegin('delete_link', TMessageType.CALL, self._seqid)
        args = delete_link_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_link(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_link_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_fc(self, pool_id):
        """
        获取fc


        Parameters:
         - pool_id

        """
        self.send_get_fc(pool_id)
        return self.recv_get_fc()

    def send_get_fc(self, pool_id):
        self._oprot.writeMessageBegin('get_fc', TMessageType.CALL, self._seqid)
        args = get_fc_args()
        args.pool_id = pool_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fc failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["Microprobe"] = Processor.process_Microprobe
        self._processMap["get_volume"] = Processor.process_get_volume
        self._processMap["get_volume_by_id"] = Processor.process_get_volume_by_id
        self._processMap["get_pool"] = Processor.process_get_pool
        self._processMap["get_pools_by"] = Processor.process_get_pools_by
        self._processMap["update_snap_pool_mdisk"] = Processor.process_update_snap_pool_mdisk
        self._processMap["get_m_disk_by"] = Processor.process_get_m_disk_by
        self._processMap["update_m_disk"] = Processor.process_update_m_disk
        self._processMap["get_pools"] = Processor.process_get_pools
        self._processMap["create_base_volume"] = Processor.process_create_base_volume
        self._processMap["delete_base_volumes"] = Processor.process_delete_base_volumes
        self._processMap["delete_base_volumes_by"] = Processor.process_delete_base_volumes_by
        self._processMap["get_base_volumes_space_by"] = Processor.process_get_base_volumes_space_by
        self._processMap["get_base_volume_space"] = Processor.process_get_base_volume_space
        self._processMap["create_snap_volume"] = Processor.process_create_snap_volume
        self._processMap["create_snap_volume_by"] = Processor.process_create_snap_volume_by
        self._processMap["get_snap_volumes_space_by"] = Processor.process_get_snap_volumes_space_by
        self._processMap["delete_snap_volumes"] = Processor.process_delete_snap_volumes
        self._processMap["delete_snap_volumes_by"] = Processor.process_delete_snap_volumes_by
        self._processMap["get_snap_volume_space"] = Processor.process_get_snap_volume_space
        self._processMap["create_clone_volume_by"] = Processor.process_create_clone_volume_by
        self._processMap["get_clone_volumes_space_by"] = Processor.process_get_clone_volumes_space_by
        self._processMap["create_clone_volume"] = Processor.process_create_clone_volume
        self._processMap["delete_clone_volumes"] = Processor.process_delete_clone_volumes
        self._processMap["delete_clone_volumes_by"] = Processor.process_delete_clone_volumes_by
        self._processMap["get_clone_volume_space"] = Processor.process_get_clone_volume_space
        self._processMap["create_volume_mapping"] = Processor.process_create_volume_mapping
        self._processMap["delete_volume_mapping"] = Processor.process_delete_volume_mapping
        self._processMap["async_create_volume_mappings"] = Processor.process_async_create_volume_mappings
        self._processMap["query_create_volume_mappings"] = Processor.process_query_create_volume_mappings
        self._processMap["async_delete_volume_mappings"] = Processor.process_async_delete_volume_mappings
        self._processMap["query_delete_volume_mappings"] = Processor.process_query_delete_volume_mappings
        self._processMap["get_volume_mappings"] = Processor.process_get_volume_mappings
        self._processMap["get_target_wwn"] = Processor.process_get_target_wwn
        self._processMap["get_all_target_wwn"] = Processor.process_get_all_target_wwn
        self._processMap["get_m_disk"] = Processor.process_get_m_disk
        self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
        self._processMap["get_base_volume_info_by_clone_volume_id"] = Processor.process_get_base_volume_info_by_clone_volume_id
        self._processMap["get_base_volume_info_by_snap_volume_id"] = Processor.process_get_base_volume_info_by_snap_volume_id
        self._processMap["get_binding_pool_by_snap_volume_id"] = Processor.process_get_binding_pool_by_snap_volume_id
        self._processMap["get_all_base_volume_ids"] = Processor.process_get_all_base_volume_ids
        self._processMap["get_all_clone_volume_ids"] = Processor.process_get_all_clone_volume_ids
        self._processMap["get_all_spaces_by_volumes"] = Processor.process_get_all_spaces_by_volumes
        self._processMap["get_spaces_by_base_volume_id"] = Processor.process_get_spaces_by_base_volume_id
        self._processMap["get_all_spaces"] = Processor.process_get_all_spaces
        self._processMap["get_all_snap_volume_ids"] = Processor.process_get_all_snap_volume_ids
        self._processMap["notify_space_monitor"] = Processor.process_notify_space_monitor
        self._processMap["get_node_ip_by_volume_id"] = Processor.process_get_node_ip_by_volume_id
        self._processMap["get_server_ip_by_pool_id"] = Processor.process_get_server_ip_by_pool_id
        self._processMap["snapshot_volume_sync"] = Processor.process_snapshot_volume_sync
        self._processMap["stop_snapshot_volume_sync"] = Processor.process_stop_snapshot_volume_sync
        self._processMap["get_snapshot_volume_sync_status"] = Processor.process_get_snapshot_volume_sync_status
        self._processMap["finish_snapshot_volume_sync"] = Processor.process_finish_snapshot_volume_sync
        self._processMap["finish_snyc_work"] = Processor.process_finish_snyc_work
        self._processMap["get_data_ip_by_pool_id"] = Processor.process_get_data_ip_by_pool_id
        self._processMap["get_link_info"] = Processor.process_get_link_info
        self._processMap["select_link"] = Processor.process_select_link
        self._processMap["create_link"] = Processor.process_create_link
        self._processMap["delete_link"] = Processor.process_delete_link
        self._processMap["get_fc"] = Processor.process_get_fc
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_Microprobe(self, seqid, iprot, oprot):
        args = Microprobe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Microprobe_result()
        try:
            self._handler.Microprobe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Microprobe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume(self, seqid, iprot, oprot):
        args = get_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_result()
        try:
            result.success = self._handler.get_volume(args.volume_name, args.volume_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume_by_id(self, seqid, iprot, oprot):
        args = get_volume_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_by_id_result()
        try:
            result.success = self._handler.get_volume_by_id(args.volume_id, args.volume_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_volume_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_pool(self, seqid, iprot, oprot):
        args = get_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_pool_result()
        try:
            result.success = self._handler.get_pool(args.poolId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_pools_by(self, seqid, iprot, oprot):
        args = get_pools_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_pools_by_result()
        try:
            result.success = self._handler.get_pools_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_pools_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_snap_pool_mdisk(self, seqid, iprot, oprot):
        args = update_snap_pool_mdisk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_snap_pool_mdisk_result()
        try:
            self._handler.update_snap_pool_mdisk(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_snap_pool_mdisk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_m_disk_by(self, seqid, iprot, oprot):
        args = get_m_disk_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_m_disk_by_result()
        try:
            result.success = self._handler.get_m_disk_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_m_disk_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_m_disk(self, seqid, iprot, oprot):
        args = update_m_disk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_m_disk_result()
        try:
            self._handler.update_m_disk(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_m_disk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_pools(self, seqid, iprot, oprot):
        args = get_pools_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_pools_result()
        try:
            result.success = self._handler.get_pools(args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_pools", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_base_volume(self, seqid, iprot, oprot):
        args = create_base_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_base_volume_result()
        try:
            result.success = self._handler.create_base_volume(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_base_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_base_volumes(self, seqid, iprot, oprot):
        args = delete_base_volumes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_base_volumes_result()
        try:
            self._handler.delete_base_volumes(args.baseVolumeIds, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_base_volumes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_base_volumes_by(self, seqid, iprot, oprot):
        args = delete_base_volumes_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_base_volumes_by_result()
        try:
            self._handler.delete_base_volumes_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_base_volumes_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_base_volumes_space_by(self, seqid, iprot, oprot):
        args = get_base_volumes_space_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_base_volumes_space_by_result()
        try:
            result.success = self._handler.get_base_volumes_space_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_base_volumes_space_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_base_volume_space(self, seqid, iprot, oprot):
        args = get_base_volume_space_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_base_volume_space_result()
        try:
            result.success = self._handler.get_base_volume_space(args.baseVolumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_base_volume_space", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_snap_volume(self, seqid, iprot, oprot):
        args = create_snap_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_snap_volume_result()
        try:
            result.success = self._handler.create_snap_volume(args.baseVolumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_snap_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_snap_volume_by(self, seqid, iprot, oprot):
        args = create_snap_volume_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_snap_volume_by_result()
        try:
            result.success = self._handler.create_snap_volume_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_snap_volume_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_snap_volumes_space_by(self, seqid, iprot, oprot):
        args = get_snap_volumes_space_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_snap_volumes_space_by_result()
        try:
            result.success = self._handler.get_snap_volumes_space_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_snap_volumes_space_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_snap_volumes(self, seqid, iprot, oprot):
        args = delete_snap_volumes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_snap_volumes_result()
        try:
            self._handler.delete_snap_volumes(args.snapVolumeIds, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_snap_volumes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_snap_volumes_by(self, seqid, iprot, oprot):
        args = delete_snap_volumes_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_snap_volumes_by_result()
        try:
            self._handler.delete_snap_volumes_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_snap_volumes_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_snap_volume_space(self, seqid, iprot, oprot):
        args = get_snap_volume_space_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_snap_volume_space_result()
        try:
            result.success = self._handler.get_snap_volume_space(args.snapVolumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_snap_volume_space", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_clone_volume_by(self, seqid, iprot, oprot):
        args = create_clone_volume_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_clone_volume_by_result()
        try:
            result.success = self._handler.create_clone_volume_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_clone_volume_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clone_volumes_space_by(self, seqid, iprot, oprot):
        args = get_clone_volumes_space_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clone_volumes_space_by_result()
        try:
            result.success = self._handler.get_clone_volumes_space_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clone_volumes_space_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_clone_volume(self, seqid, iprot, oprot):
        args = create_clone_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_clone_volume_result()
        try:
            result.success = self._handler.create_clone_volume(args.snapVolumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_clone_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_clone_volumes(self, seqid, iprot, oprot):
        args = delete_clone_volumes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_clone_volumes_result()
        try:
            self._handler.delete_clone_volumes(args.cloneVolumeIds, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_clone_volumes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_clone_volumes_by(self, seqid, iprot, oprot):
        args = delete_clone_volumes_by_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_clone_volumes_by_result()
        try:
            self._handler.delete_clone_volumes_by(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_clone_volumes_by", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clone_volume_space(self, seqid, iprot, oprot):
        args = get_clone_volume_space_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clone_volume_space_result()
        try:
            result.success = self._handler.get_clone_volume_space(args.cloneVolumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clone_volume_space", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume_mapping(self, seqid, iprot, oprot):
        args = create_volume_mapping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_mapping_result()
        try:
            result.success = self._handler.create_volume_mapping(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_volume_mapping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume_mapping(self, seqid, iprot, oprot):
        args = delete_volume_mapping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_mapping_result()
        try:
            self._handler.delete_volume_mapping(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_volume_mapping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_create_volume_mappings(self, seqid, iprot, oprot):
        args = async_create_volume_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_create_volume_mappings_result()
        try:
            self._handler.async_create_volume_mappings(args.requests, args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_create_volume_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_create_volume_mappings(self, seqid, iprot, oprot):
        args = query_create_volume_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_create_volume_mappings_result()
        try:
            result.success = self._handler.query_create_volume_mappings(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_create_volume_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_async_delete_volume_mappings(self, seqid, iprot, oprot):
        args = async_delete_volume_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = async_delete_volume_mappings_result()
        try:
            self._handler.async_delete_volume_mappings(args.requests, args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("async_delete_volume_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_query_delete_volume_mappings(self, seqid, iprot, oprot):
        args = query_delete_volume_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = query_delete_volume_mappings_result()
        try:
            result.success = self._handler.query_delete_volume_mappings(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("query_delete_volume_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume_mappings(self, seqid, iprot, oprot):
        args = get_volume_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_mappings_result()
        try:
            result.success = self._handler.get_volume_mappings(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_volume_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_wwn(self, seqid, iprot, oprot):
        args = get_target_wwn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_wwn_result()
        try:
            result.success = self._handler.get_target_wwn(args.deviceIp, args.poolType, args.poolId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_wwn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_target_wwn(self, seqid, iprot, oprot):
        args = get_all_target_wwn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_target_wwn_result()
        try:
            result.success = self._handler.get_all_target_wwn(args.poolType, args.poolId, args.linkId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_target_wwn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_m_disk(self, seqid, iprot, oprot):
        args = get_m_disk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_m_disk_result()
        try:
            result.success = self._handler.get_m_disk(args.path, args.poolType, args.nodeIp)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_m_disk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_for_ams(self, seqid, iprot, oprot):
        args = get_data_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_for_ams_result()
        try:
            result.success = self._handler.get_data_for_ams(args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_base_volume_info_by_clone_volume_id(self, seqid, iprot, oprot):
        args = get_base_volume_info_by_clone_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_base_volume_info_by_clone_volume_id_result()
        try:
            result.success = self._handler.get_base_volume_info_by_clone_volume_id(args.clone_volume_id, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_base_volume_info_by_clone_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_base_volume_info_by_snap_volume_id(self, seqid, iprot, oprot):
        args = get_base_volume_info_by_snap_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_base_volume_info_by_snap_volume_id_result()
        try:
            result.success = self._handler.get_base_volume_info_by_snap_volume_id(args.snap_volume_id, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_base_volume_info_by_snap_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_binding_pool_by_snap_volume_id(self, seqid, iprot, oprot):
        args = get_binding_pool_by_snap_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_binding_pool_by_snap_volume_id_result()
        try:
            result.success = self._handler.get_binding_pool_by_snap_volume_id(args.snap_volume_id, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_binding_pool_by_snap_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_base_volume_ids(self, seqid, iprot, oprot):
        args = get_all_base_volume_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_base_volume_ids_result()
        try:
            result.success = self._handler.get_all_base_volume_ids(args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_base_volume_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_clone_volume_ids(self, seqid, iprot, oprot):
        args = get_all_clone_volume_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_clone_volume_ids_result()
        try:
            result.success = self._handler.get_all_clone_volume_ids(args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_clone_volume_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_spaces_by_volumes(self, seqid, iprot, oprot):
        args = get_all_spaces_by_volumes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_spaces_by_volumes_result()
        try:
            result.success = self._handler.get_all_spaces_by_volumes(args.jobVolumeRequestList, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_spaces_by_volumes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_spaces_by_base_volume_id(self, seqid, iprot, oprot):
        args = get_spaces_by_base_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_spaces_by_base_volume_id_result()
        try:
            result.success = self._handler.get_spaces_by_base_volume_id(args.BaseVolumeIdList, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_spaces_by_base_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_spaces(self, seqid, iprot, oprot):
        args = get_all_spaces_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_spaces_result()
        try:
            result.success = self._handler.get_all_spaces(args.jobVolumeRequestList, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_spaces", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_snap_volume_ids(self, seqid, iprot, oprot):
        args = get_all_snap_volume_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_snap_volume_ids_result()
        try:
            result.success = self._handler.get_all_snap_volume_ids(args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_snap_volume_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_notify_space_monitor(self, seqid, iprot, oprot):
        args = notify_space_monitor_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = notify_space_monitor_result()
        try:
            self._handler.notify_space_monitor()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("notify_space_monitor", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_node_ip_by_volume_id(self, seqid, iprot, oprot):
        args = get_node_ip_by_volume_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_node_ip_by_volume_id_result()
        try:
            result.success = self._handler.get_node_ip_by_volume_id(args.volumeId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_node_ip_by_volume_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server_ip_by_pool_id(self, seqid, iprot, oprot):
        args = get_server_ip_by_pool_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_ip_by_pool_id_result()
        try:
            result.success = self._handler.get_server_ip_by_pool_id(args.poolId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_server_ip_by_pool_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_volume_sync(self, seqid, iprot, oprot):
        args = snapshot_volume_sync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_volume_sync_result()
        try:
            result.success = self._handler.snapshot_volume_sync(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_volume_sync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_snapshot_volume_sync(self, seqid, iprot, oprot):
        args = stop_snapshot_volume_sync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_snapshot_volume_sync_result()
        try:
            self._handler.stop_snapshot_volume_sync(args.snapshotVolumeSyncId, args.srcSnapshotPoolId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_snapshot_volume_sync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_snapshot_volume_sync_status(self, seqid, iprot, oprot):
        args = get_snapshot_volume_sync_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_snapshot_volume_sync_status_result()
        try:
            result.success = self._handler.get_snapshot_volume_sync_status(args.snapshotVolumeSyncId, args.srcSnapshotPoolId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_snapshot_volume_sync_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_finish_snapshot_volume_sync(self, seqid, iprot, oprot):
        args = finish_snapshot_volume_sync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = finish_snapshot_volume_sync_result()
        try:
            result.success = self._handler.finish_snapshot_volume_sync(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("finish_snapshot_volume_sync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_finish_snyc_work(self, seqid, iprot, oprot):
        args = finish_snyc_work_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = finish_snyc_work_result()
        try:
            result.success = self._handler.finish_snyc_work(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("finish_snyc_work", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_ip_by_pool_id(self, seqid, iprot, oprot):
        args = get_data_ip_by_pool_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_ip_by_pool_id_result()
        try:
            result.success = self._handler.get_data_ip_by_pool_id(args.poolId, args.poolType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_ip_by_pool_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_link_info(self, seqid, iprot, oprot):
        args = get_link_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_link_info_result()
        try:
            result.success = self._handler.get_link_info(args.linkId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_link_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_select_link(self, seqid, iprot, oprot):
        args = select_link_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = select_link_result()
        try:
            result.success = self._handler.select_link(args.request, args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("select_link", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_link(self, seqid, iprot, oprot):
        args = create_link_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_link_result()
        try:
            result.success = self._handler.create_link(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_link", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_link(self, seqid, iprot, oprot):
        args = delete_link_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_link_result()
        try:
            self._handler.delete_link(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_link", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fc(self, seqid, iprot, oprot):
        args = get_fc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fc_result()
        try:
            result.success = self._handler.get_fc(args.pool_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class Microprobe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Microprobe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Microprobe_args)
Microprobe_args.thrift_spec = (
)


class Microprobe_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Microprobe_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Microprobe_result)
Microprobe_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_volume_args(object):
    """
    Attributes:
     - volume_name
     - volume_type

    """


    def __init__(self, volume_name=None, volume_type=None,):
        self.volume_name = volume_name
        self.volume_type = volume_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.volume_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_args')
        if self.volume_name is not None:
            oprot.writeFieldBegin('volume_name', TType.STRING, 1)
            oprot.writeString(self.volume_name.encode('utf-8') if sys.version_info[0] == 2 else self.volume_name)
            oprot.writeFieldEnd()
        if self.volume_type is not None:
            oprot.writeFieldBegin('volume_type', TType.I32, 2)
            oprot.writeI32(self.volume_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_args)
get_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'volume_type', None, None, ),  # 2
)


class get_volume_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_result)
get_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo, None], None, ),  # 0
)


class get_volume_by_id_args(object):
    """
    Attributes:
     - volume_id
     - volume_type

    """


    def __init__(self, volume_id=None, volume_type=None,):
        self.volume_id = volume_id
        self.volume_type = volume_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.volume_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_by_id_args')
        if self.volume_id is not None:
            oprot.writeFieldBegin('volume_id', TType.STRING, 1)
            oprot.writeString(self.volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.volume_id)
            oprot.writeFieldEnd()
        if self.volume_type is not None:
            oprot.writeFieldBegin('volume_type', TType.I32, 2)
            oprot.writeI32(self.volume_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_by_id_args)
get_volume_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volume_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'volume_type', None, None, ),  # 2
)


class get_volume_by_id_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_by_id_result)
get_volume_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo, None], None, ),  # 0
)


class get_pool_args(object):
    """
    Attributes:
     - poolId
     - poolType

    """


    def __init__(self, poolId=None, poolType=None,):
        self.poolId = poolId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.poolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pool_args')
        if self.poolId is not None:
            oprot.writeFieldBegin('poolId', TType.STRING, 1)
            oprot.writeString(self.poolId.encode('utf-8') if sys.version_info[0] == 2 else self.poolId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pool_args)
get_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'poolId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_pool_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncTPool()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pool_result)
get_pool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncTPool, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_pools_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncPoolRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pools_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pools_by_args)
get_pools_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncPoolRequest, None], None, ),  # 1
)


class get_pools_by_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = ncCdmStoreMgmProto.ttypes.ncTPool()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pools_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pools_by_result)
get_pools_by_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncTPool, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_snap_pool_mdisk_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncPoolRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_snap_pool_mdisk_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_snap_pool_mdisk_args)
update_snap_pool_mdisk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncPoolRequest, None], None, ),  # 1
)


class update_snap_pool_mdisk_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_snap_pool_mdisk_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_snap_pool_mdisk_result)
update_snap_pool_mdisk_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_m_disk_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmCommon.ttypes.ncMDiskInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_m_disk_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_m_disk_by_args)
get_m_disk_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmCommon.ttypes.ncMDiskInfo, None], None, ),  # 1
)


class get_m_disk_by_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmCommon.ttypes.ncMDiskInfoList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_m_disk_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_m_disk_by_result)
get_m_disk_by_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmCommon.ttypes.ncMDiskInfoList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_m_disk_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmCommon.ttypes.ncMDiskInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_m_disk_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_m_disk_args)
update_m_disk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmCommon.ttypes.ncMDiskInfo, None], None, ),  # 1
)


class update_m_disk_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_m_disk_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_m_disk_result)
update_m_disk_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_pools_args(object):
    """
    Attributes:
     - poolType

    """


    def __init__(self, poolType=None,):
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pools_args')
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 1)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pools_args)
get_pools_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'poolType', None, None, ),  # 1
)


class get_pools_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ncCdmStoreMgmProto.ttypes.ncTPool()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pools_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pools_result)
get_pools_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncTPool, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_base_volume_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncCreateBaseVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_base_volume_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_base_volume_args)
create_base_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncCreateBaseVolumeRequest, None], None, ),  # 1
)


class create_base_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_base_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_base_volume_result)
create_base_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_base_volumes_args(object):
    """
    Attributes:
     - baseVolumeIds
     - poolType

    """


    def __init__(self, baseVolumeIds=None, poolType=None,):
        self.baseVolumeIds = baseVolumeIds
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.baseVolumeIds = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.baseVolumeIds.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_base_volumes_args')
        if self.baseVolumeIds is not None:
            oprot.writeFieldBegin('baseVolumeIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.baseVolumeIds))
            for iter20 in self.baseVolumeIds:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_base_volumes_args)
delete_base_volumes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'baseVolumeIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class delete_base_volumes_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_base_volumes_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_base_volumes_result)
delete_base_volumes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_base_volumes_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_base_volumes_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_base_volumes_by_args)
delete_base_volumes_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest, None], None, ),  # 1
)


class delete_base_volumes_by_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_base_volumes_by_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_base_volumes_by_result)
delete_base_volumes_by_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_base_volumes_space_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volumes_space_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volumes_space_by_args)
get_base_volumes_space_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest, None], None, ),  # 1
)


class get_base_volumes_space_by_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volumes_space_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volumes_space_by_result)
get_base_volumes_space_by_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_base_volume_space_args(object):
    """
    Attributes:
     - baseVolumeId
     - poolType

    """


    def __init__(self, baseVolumeId=None, poolType=None,):
        self.baseVolumeId = baseVolumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.baseVolumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_space_args')
        if self.baseVolumeId is not None:
            oprot.writeFieldBegin('baseVolumeId', TType.STRING, 1)
            oprot.writeString(self.baseVolumeId.encode('utf-8') if sys.version_info[0] == 2 else self.baseVolumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_space_args)
get_base_volume_space_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'baseVolumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_base_volume_space_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_space_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_space_result)
get_base_volume_space_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeSpace, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_snap_volume_args(object):
    """
    Attributes:
     - baseVolumeId
     - poolType

    """


    def __init__(self, baseVolumeId=None, poolType=None,):
        self.baseVolumeId = baseVolumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.baseVolumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snap_volume_args')
        if self.baseVolumeId is not None:
            oprot.writeFieldBegin('baseVolumeId', TType.STRING, 1)
            oprot.writeString(self.baseVolumeId.encode('utf-8') if sys.version_info[0] == 2 else self.baseVolumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snap_volume_args)
create_snap_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'baseVolumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class create_snap_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snap_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snap_volume_result)
create_snap_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_snap_volume_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snap_volume_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snap_volume_by_args)
create_snap_volume_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 1
)


class create_snap_volume_by_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_snap_volume_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_snap_volume_by_result)
create_snap_volume_by_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_snap_volumes_space_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snap_volumes_space_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snap_volumes_space_by_args)
get_snap_volumes_space_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest, None], None, ),  # 1
)


class get_snap_volumes_space_by_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snap_volumes_space_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snap_volumes_space_by_result)
get_snap_volumes_space_by_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_snap_volumes_args(object):
    """
    Attributes:
     - snapVolumeIds
     - poolType

    """


    def __init__(self, snapVolumeIds=None, poolType=None,):
        self.snapVolumeIds = snapVolumeIds
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.snapVolumeIds = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.snapVolumeIds.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_snap_volumes_args')
        if self.snapVolumeIds is not None:
            oprot.writeFieldBegin('snapVolumeIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.snapVolumeIds))
            for iter41 in self.snapVolumeIds:
                oprot.writeString(iter41.encode('utf-8') if sys.version_info[0] == 2 else iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_snap_volumes_args)
delete_snap_volumes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'snapVolumeIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class delete_snap_volumes_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_snap_volumes_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_snap_volumes_result)
delete_snap_volumes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_snap_volumes_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_snap_volumes_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_snap_volumes_by_args)
delete_snap_volumes_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest, None], None, ),  # 1
)


class delete_snap_volumes_by_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_snap_volumes_by_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_snap_volumes_by_result)
delete_snap_volumes_by_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_snap_volume_space_args(object):
    """
    Attributes:
     - snapVolumeId
     - poolType

    """


    def __init__(self, snapVolumeId=None, poolType=None,):
        self.snapVolumeId = snapVolumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapVolumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snap_volume_space_args')
        if self.snapVolumeId is not None:
            oprot.writeFieldBegin('snapVolumeId', TType.STRING, 1)
            oprot.writeString(self.snapVolumeId.encode('utf-8') if sys.version_info[0] == 2 else self.snapVolumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snap_volume_space_args)
get_snap_volume_space_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapVolumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_snap_volume_space_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snap_volume_space_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snap_volume_space_result)
get_snap_volume_space_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeSpace, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_clone_volume_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clone_volume_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clone_volume_by_args)
create_clone_volume_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 1
)


class create_clone_volume_by_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clone_volume_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clone_volume_by_result)
create_clone_volume_by_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clone_volumes_space_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clone_volumes_space_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clone_volumes_space_by_args)
get_clone_volumes_space_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncGetVolumeRequest, None], None, ),  # 1
)


class get_clone_volumes_space_by_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem47.read(iprot)
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clone_volumes_space_by_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter48 in self.success:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clone_volumes_space_by_result)
get_clone_volumes_space_by_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_clone_volume_args(object):
    """
    Attributes:
     - snapVolumeId
     - poolType

    """


    def __init__(self, snapVolumeId=None, poolType=None,):
        self.snapVolumeId = snapVolumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapVolumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clone_volume_args')
        if self.snapVolumeId is not None:
            oprot.writeFieldBegin('snapVolumeId', TType.STRING, 1)
            oprot.writeString(self.snapVolumeId.encode('utf-8') if sys.version_info[0] == 2 else self.snapVolumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clone_volume_args)
create_clone_volume_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapVolumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class create_clone_volume_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clone_volume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clone_volume_result)
create_clone_volume_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_clone_volumes_args(object):
    """
    Attributes:
     - cloneVolumeIds
     - poolType

    """


    def __init__(self, cloneVolumeIds=None, poolType=None,):
        self.cloneVolumeIds = cloneVolumeIds
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cloneVolumeIds = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.cloneVolumeIds.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_clone_volumes_args')
        if self.cloneVolumeIds is not None:
            oprot.writeFieldBegin('cloneVolumeIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.cloneVolumeIds))
            for iter55 in self.cloneVolumeIds:
                oprot.writeString(iter55.encode('utf-8') if sys.version_info[0] == 2 else iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_clone_volumes_args)
delete_clone_volumes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cloneVolumeIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class delete_clone_volumes_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_clone_volumes_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_clone_volumes_result)
delete_clone_volumes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_clone_volumes_by_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_clone_volumes_by_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_clone_volumes_by_args)
delete_clone_volumes_by_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncDelVolumeRequest, None], None, ),  # 1
)


class delete_clone_volumes_by_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_clone_volumes_by_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_clone_volumes_by_result)
delete_clone_volumes_by_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clone_volume_space_args(object):
    """
    Attributes:
     - cloneVolumeId
     - poolType

    """


    def __init__(self, cloneVolumeId=None, poolType=None,):
        self.cloneVolumeId = cloneVolumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cloneVolumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clone_volume_space_args')
        if self.cloneVolumeId is not None:
            oprot.writeFieldBegin('cloneVolumeId', TType.STRING, 1)
            oprot.writeString(self.cloneVolumeId.encode('utf-8') if sys.version_info[0] == 2 else self.cloneVolumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clone_volume_space_args)
get_clone_volume_space_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cloneVolumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_clone_volume_space_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clone_volume_space_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clone_volume_space_result)
get_clone_volume_space_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeSpace, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_volume_mapping_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_volume_mapping_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_volume_mapping_args)
create_volume_mapping_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest, None], None, ),  # 1
)


class create_volume_mapping_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_volume_mapping_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_volume_mapping_result)
create_volume_mapping_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_volume_mapping_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_mapping_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_mapping_args)
delete_volume_mapping_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest, None], None, ),  # 1
)


class delete_volume_mapping_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_volume_mapping_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_volume_mapping_result)
delete_volume_mapping_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class async_create_volume_mappings_args(object):
    """
    Attributes:
     - requests
     - jobId

    """


    def __init__(self, requests=None, jobId=None,):
        self.requests = requests
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest()
                        _elem61.read(iprot)
                        self.requests.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_create_volume_mappings_args')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter62 in self.requests:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 2)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_create_volume_mappings_args)
async_create_volume_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest, None], False), None, ),  # 1
    (2, TType.STRING, 'jobId', 'UTF8', None, ),  # 2
)


class async_create_volume_mappings_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_create_volume_mappings_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_create_volume_mappings_result)
async_create_volume_mappings_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class query_create_volume_mappings_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_create_volume_mappings_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_create_volume_mappings_args)
query_create_volume_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest, None], None, ),  # 1
)


class query_create_volume_mappings_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncQueryCreateMappingResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_create_volume_mappings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_create_volume_mappings_result)
query_create_volume_mappings_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncQueryCreateMappingResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class async_delete_volume_mappings_args(object):
    """
    Attributes:
     - requests
     - jobId

    """


    def __init__(self, requests=None, jobId=None,):
        self.requests = requests
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.requests = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest()
                        _elem68.read(iprot)
                        self.requests.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_delete_volume_mappings_args')
        if self.requests is not None:
            oprot.writeFieldBegin('requests', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.requests))
            for iter69 in self.requests:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 2)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_delete_volume_mappings_args)
async_delete_volume_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'requests', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest, None], False), None, ),  # 1
    (2, TType.STRING, 'jobId', 'UTF8', None, ),  # 2
)


class async_delete_volume_mappings_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('async_delete_volume_mappings_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(async_delete_volume_mappings_result)
async_delete_volume_mappings_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class query_delete_volume_mappings_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_delete_volume_mappings_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_delete_volume_mappings_args)
query_delete_volume_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest, None], None, ),  # 1
)


class query_delete_volume_mappings_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncQueryDelMappingResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('query_delete_volume_mappings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(query_delete_volume_mappings_result)
query_delete_volume_mappings_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncQueryDelMappingResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_volume_mappings_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncGetVolumeMappingRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_mappings_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_mappings_args)
get_volume_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncGetVolumeMappingRequest, None], None, ),  # 1
)


class get_volume_mappings_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo()
                        _elem75.read(iprot)
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_volume_mappings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter76 in self.success:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_volume_mappings_result)
get_volume_mappings_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_target_wwn_args(object):
    """
    Attributes:
     - deviceIp
     - poolType
     - poolId

    """


    def __init__(self, deviceIp=None, poolType=None, poolId=None,):
        self.deviceIp = deviceIp
        self.poolType = poolType
        self.poolId = poolId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.deviceIp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.poolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_wwn_args')
        if self.deviceIp is not None:
            oprot.writeFieldBegin('deviceIp', TType.STRING, 1)
            oprot.writeString(self.deviceIp.encode('utf-8') if sys.version_info[0] == 2 else self.deviceIp)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        if self.poolId is not None:
            oprot.writeFieldBegin('poolId', TType.STRING, 3)
            oprot.writeString(self.poolId.encode('utf-8') if sys.version_info[0] == 2 else self.poolId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_wwn_args)
get_target_wwn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'deviceIp', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
    (3, TType.STRING, 'poolId', 'UTF8', None, ),  # 3
)


class get_target_wwn_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_wwn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_wwn_result)
get_target_wwn_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_target_wwn_args(object):
    """
    Attributes:
     - poolType
     - poolId
     - linkId

    """


    def __init__(self, poolType=None, poolId=None, linkId=None,):
        self.poolType = poolType
        self.poolId = poolId
        self.linkId = linkId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.poolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.linkId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_target_wwn_args')
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 1)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        if self.poolId is not None:
            oprot.writeFieldBegin('poolId', TType.STRING, 2)
            oprot.writeString(self.poolId.encode('utf-8') if sys.version_info[0] == 2 else self.poolId)
            oprot.writeFieldEnd()
        if self.linkId is not None:
            oprot.writeFieldBegin('linkId', TType.STRING, 3)
            oprot.writeString(self.linkId.encode('utf-8') if sys.version_info[0] == 2 else self.linkId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_target_wwn_args)
get_all_target_wwn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'poolType', None, None, ),  # 1
    (2, TType.STRING, 'poolId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'linkId', 'UTF8', None, ),  # 3
)


class get_all_target_wwn_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = ncCdmStoreMgmProto.ttypes.ncGetTargetWwnInfo()
                        _elem82.read(iprot)
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_target_wwn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter83 in self.success:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_target_wwn_result)
get_all_target_wwn_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncGetTargetWwnInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_m_disk_args(object):
    """
    Attributes:
     - path
     - poolType
     - nodeIp

    """


    def __init__(self, path=None, poolType=None, nodeIp=None,):
        self.path = path
        self.poolType = poolType
        self.nodeIp = nodeIp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.nodeIp = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_m_disk_args')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        if self.nodeIp is not None:
            oprot.writeFieldBegin('nodeIp', TType.STRING, 3)
            oprot.writeString(self.nodeIp.encode('utf-8') if sys.version_info[0] == 2 else self.nodeIp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_m_disk_args)
get_m_disk_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
    (3, TType.STRING, 'nodeIp', 'UTF8', None, ),  # 3
)


class get_m_disk_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_m_disk_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_m_disk_result)
get_m_disk_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_data_for_ams_args(object):
    """
    Attributes:
     - kwargs

    """


    def __init__(self, kwargs=None,):
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_args')
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 1)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_args)
get_data_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'kwargs', 'UTF8', None, ),  # 1
)


class get_data_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_result)
get_data_for_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_base_volume_info_by_clone_volume_id_args(object):
    """
    Attributes:
     - clone_volume_id
     - poolType

    """


    def __init__(self, clone_volume_id=None, poolType=None,):
        self.clone_volume_id = clone_volume_id
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clone_volume_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_info_by_clone_volume_id_args')
        if self.clone_volume_id is not None:
            oprot.writeFieldBegin('clone_volume_id', TType.STRING, 1)
            oprot.writeString(self.clone_volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.clone_volume_id)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_info_by_clone_volume_id_args)
get_base_volume_info_by_clone_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clone_volume_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_base_volume_info_by_clone_volume_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_info_by_clone_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_info_by_clone_volume_id_result)
get_base_volume_info_by_clone_volume_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_base_volume_info_by_snap_volume_id_args(object):
    """
    Attributes:
     - snap_volume_id
     - poolType

    """


    def __init__(self, snap_volume_id=None, poolType=None,):
        self.snap_volume_id = snap_volume_id
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snap_volume_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_info_by_snap_volume_id_args')
        if self.snap_volume_id is not None:
            oprot.writeFieldBegin('snap_volume_id', TType.STRING, 1)
            oprot.writeString(self.snap_volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.snap_volume_id)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_info_by_snap_volume_id_args)
get_base_volume_info_by_snap_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snap_volume_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_base_volume_info_by_snap_volume_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_base_volume_info_by_snap_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_base_volume_info_by_snap_volume_id_result)
get_base_volume_info_by_snap_volume_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_binding_pool_by_snap_volume_id_args(object):
    """
    Attributes:
     - snap_volume_id
     - poolType

    """


    def __init__(self, snap_volume_id=None, poolType=None,):
        self.snap_volume_id = snap_volume_id
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snap_volume_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_binding_pool_by_snap_volume_id_args')
        if self.snap_volume_id is not None:
            oprot.writeFieldBegin('snap_volume_id', TType.STRING, 1)
            oprot.writeString(self.snap_volume_id.encode('utf-8') if sys.version_info[0] == 2 else self.snap_volume_id)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_binding_pool_by_snap_volume_id_args)
get_binding_pool_by_snap_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snap_volume_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_binding_pool_by_snap_volume_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncTPool()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_binding_pool_by_snap_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_binding_pool_by_snap_volume_id_result)
get_binding_pool_by_snap_volume_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncTPool, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_base_volume_ids_args(object):
    """
    Attributes:
     - poolType

    """


    def __init__(self, poolType=None,):
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_base_volume_ids_args')
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 1)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_base_volume_ids_args)
get_all_base_volume_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'poolType', None, None, ),  # 1
)


class get_all_base_volume_ids_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem89.read(iprot)
                        self.success.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_base_volume_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter90 in self.success:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_base_volume_ids_result)
get_all_base_volume_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_clone_volume_ids_args(object):
    """
    Attributes:
     - poolType

    """


    def __init__(self, poolType=None,):
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clone_volume_ids_args')
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 1)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clone_volume_ids_args)
get_all_clone_volume_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'poolType', None, None, ),  # 1
)


class get_all_clone_volume_ids_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem96.read(iprot)
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clone_volume_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter97 in self.success:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clone_volume_ids_result)
get_all_clone_volume_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_spaces_by_volumes_args(object):
    """
    Attributes:
     - jobVolumeRequestList
     - poolType

    """


    def __init__(self, jobVolumeRequestList=None, poolType=None,):
        self.jobVolumeRequestList = jobVolumeRequestList
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobVolumeRequestList = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
                        _elem103.read(iprot)
                        self.jobVolumeRequestList.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_spaces_by_volumes_args')
        if self.jobVolumeRequestList is not None:
            oprot.writeFieldBegin('jobVolumeRequestList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.jobVolumeRequestList))
            for iter104 in self.jobVolumeRequestList:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_spaces_by_volumes_args)
get_all_spaces_by_volumes_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobVolumeRequestList', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, None], False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_all_spaces_by_volumes_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_spaces_by_volumes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_spaces_by_volumes_result)
get_all_spaces_by_volumes_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_spaces_by_base_volume_id_args(object):
    """
    Attributes:
     - BaseVolumeIdList
     - poolType

    """


    def __init__(self, BaseVolumeIdList=None, poolType=None,):
        self.BaseVolumeIdList = BaseVolumeIdList
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.BaseVolumeIdList = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
                        _elem110.read(iprot)
                        self.BaseVolumeIdList.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_spaces_by_base_volume_id_args')
        if self.BaseVolumeIdList is not None:
            oprot.writeFieldBegin('BaseVolumeIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.BaseVolumeIdList))
            for iter111 in self.BaseVolumeIdList:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_spaces_by_base_volume_id_args)
get_spaces_by_base_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'BaseVolumeIdList', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, None], False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_spaces_by_base_volume_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_spaces_by_base_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_spaces_by_base_volume_id_result)
get_spaces_by_base_volume_id_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_spaces_args(object):
    """
    Attributes:
     - jobVolumeRequestList
     - poolType

    """


    def __init__(self, jobVolumeRequestList=None, poolType=None,):
        self.jobVolumeRequestList = jobVolumeRequestList
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobVolumeRequestList = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
                        _elem117.read(iprot)
                        self.jobVolumeRequestList.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_spaces_args')
        if self.jobVolumeRequestList is not None:
            oprot.writeFieldBegin('jobVolumeRequestList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.jobVolumeRequestList))
            for iter118 in self.jobVolumeRequestList:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_spaces_args)
get_all_spaces_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobVolumeRequestList', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, None], False), None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_all_spaces_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_spaces_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_spaces_result)
get_all_spaces_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_snap_volume_ids_args(object):
    """
    Attributes:
     - poolType

    """


    def __init__(self, poolType=None,):
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_snap_volume_ids_args')
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 1)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_snap_volume_ids_args)
get_all_snap_volume_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'poolType', None, None, ),  # 1
)


class get_all_snap_volume_ids_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
                        _elem124.read(iprot)
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_snap_volume_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter125 in self.success:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_snap_volume_ids_result)
get_all_snap_volume_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmProto.ttypes.ncVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class notify_space_monitor_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('notify_space_monitor_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(notify_space_monitor_args)
notify_space_monitor_args.thrift_spec = (
)


class notify_space_monitor_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('notify_space_monitor_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(notify_space_monitor_result)
notify_space_monitor_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_node_ip_by_volume_id_args(object):
    """
    Attributes:
     - volumeId
     - poolType

    """


    def __init__(self, volumeId=None, poolType=None,):
        self.volumeId = volumeId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volumeId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_ip_by_volume_id_args')
        if self.volumeId is not None:
            oprot.writeFieldBegin('volumeId', TType.STRING, 1)
            oprot.writeString(self.volumeId.encode('utf-8') if sys.version_info[0] == 2 else self.volumeId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_ip_by_volume_id_args)
get_node_ip_by_volume_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volumeId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_node_ip_by_volume_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_node_ip_by_volume_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_node_ip_by_volume_id_result)
get_node_ip_by_volume_id_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_server_ip_by_pool_id_args(object):
    """
    Attributes:
     - poolId
     - poolType

    """


    def __init__(self, poolId=None, poolType=None,):
        self.poolId = poolId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.poolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_ip_by_pool_id_args')
        if self.poolId is not None:
            oprot.writeFieldBegin('poolId', TType.STRING, 1)
            oprot.writeString(self.poolId.encode('utf-8') if sys.version_info[0] == 2 else self.poolId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_ip_by_pool_id_args)
get_server_ip_by_pool_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'poolId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_server_ip_by_pool_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_ip_by_pool_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_ip_by_pool_id_result)
get_server_ip_by_pool_id_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class snapshot_volume_sync_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_volume_sync_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_volume_sync_args)
snapshot_volume_sync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest, None], None, ),  # 1
)


class snapshot_volume_sync_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncReply()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_volume_sync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_volume_sync_result)
snapshot_volume_sync_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncReply, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class stop_snapshot_volume_sync_args(object):
    """
    Attributes:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId

    """


    def __init__(self, snapshotVolumeSyncId=None, srcSnapshotPoolId=None,):
        self.snapshotVolumeSyncId = snapshotVolumeSyncId
        self.srcSnapshotPoolId = srcSnapshotPoolId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotVolumeSyncId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.srcSnapshotPoolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_snapshot_volume_sync_args')
        if self.snapshotVolumeSyncId is not None:
            oprot.writeFieldBegin('snapshotVolumeSyncId', TType.STRING, 1)
            oprot.writeString(self.snapshotVolumeSyncId.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotVolumeSyncId)
            oprot.writeFieldEnd()
        if self.srcSnapshotPoolId is not None:
            oprot.writeFieldBegin('srcSnapshotPoolId', TType.STRING, 2)
            oprot.writeString(self.srcSnapshotPoolId.encode('utf-8') if sys.version_info[0] == 2 else self.srcSnapshotPoolId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_snapshot_volume_sync_args)
stop_snapshot_volume_sync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotVolumeSyncId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'srcSnapshotPoolId', 'UTF8', None, ),  # 2
)


class stop_snapshot_volume_sync_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_snapshot_volume_sync_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_snapshot_volume_sync_result)
stop_snapshot_volume_sync_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_snapshot_volume_sync_status_args(object):
    """
    Attributes:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId

    """


    def __init__(self, snapshotVolumeSyncId=None, srcSnapshotPoolId=None,):
        self.snapshotVolumeSyncId = snapshotVolumeSyncId
        self.srcSnapshotPoolId = srcSnapshotPoolId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotVolumeSyncId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.srcSnapshotPoolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snapshot_volume_sync_status_args')
        if self.snapshotVolumeSyncId is not None:
            oprot.writeFieldBegin('snapshotVolumeSyncId', TType.STRING, 1)
            oprot.writeString(self.snapshotVolumeSyncId.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotVolumeSyncId)
            oprot.writeFieldEnd()
        if self.srcSnapshotPoolId is not None:
            oprot.writeFieldBegin('srcSnapshotPoolId', TType.STRING, 2)
            oprot.writeString(self.srcSnapshotPoolId.encode('utf-8') if sys.version_info[0] == 2 else self.srcSnapshotPoolId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snapshot_volume_sync_status_args)
get_snapshot_volume_sync_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotVolumeSyncId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'srcSnapshotPoolId', 'UTF8', None, ),  # 2
)


class get_snapshot_volume_sync_status_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncSnapStoreProto.ttypes.ncSyncSnapVolumeProgress()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_snapshot_volume_sync_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_snapshot_volume_sync_status_result)
get_snapshot_volume_sync_status_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncSnapStoreProto.ttypes.ncSyncSnapVolumeProgress, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class finish_snapshot_volume_sync_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('finish_snapshot_volume_sync_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(finish_snapshot_volume_sync_args)
finish_snapshot_volume_sync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest, None], None, ),  # 1
)


class finish_snapshot_volume_sync_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('finish_snapshot_volume_sync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(finish_snapshot_volume_sync_result)
finish_snapshot_volume_sync_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class finish_snyc_work_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('finish_snyc_work_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(finish_snyc_work_args)
finish_snyc_work_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail, None], None, ),  # 1
)


class finish_snyc_work_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('finish_snyc_work_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(finish_snyc_work_result)
finish_snyc_work_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_data_ip_by_pool_id_args(object):
    """
    Attributes:
     - poolId
     - poolType

    """


    def __init__(self, poolId=None, poolType=None,):
        self.poolId = poolId
        self.poolType = poolType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.poolId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poolType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_ip_by_pool_id_args')
        if self.poolId is not None:
            oprot.writeFieldBegin('poolId', TType.STRING, 1)
            oprot.writeString(self.poolId.encode('utf-8') if sys.version_info[0] == 2 else self.poolId)
            oprot.writeFieldEnd()
        if self.poolType is not None:
            oprot.writeFieldBegin('poolType', TType.I32, 2)
            oprot.writeI32(self.poolType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_ip_by_pool_id_args)
get_data_ip_by_pool_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'poolId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'poolType', None, None, ),  # 2
)


class get_data_ip_by_pool_id_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_ip_by_pool_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_ip_by_pool_id_result)
get_data_ip_by_pool_id_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_link_info_args(object):
    """
    Attributes:
     - linkId

    """


    def __init__(self, linkId=None,):
        self.linkId = linkId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.linkId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_link_info_args')
        if self.linkId is not None:
            oprot.writeFieldBegin('linkId', TType.STRING, 1)
            oprot.writeString(self.linkId.encode('utf-8') if sys.version_info[0] == 2 else self.linkId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_link_info_args)
get_link_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'linkId', 'UTF8', None, ),  # 1
)


class get_link_info_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_link_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_link_info_result)
get_link_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmCommon.ttypes.ncLinkInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class select_link_args(object):
    """
    Attributes:
     - request
     - num

    """


    def __init__(self, request=None, num=1,):
        self.request = request
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmProto.ttypes.ncSelectLinkRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('select_link_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 2)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(select_link_args)
select_link_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmProto.ttypes.ncSelectLinkRequest, None], None, ),  # 1
    (2, TType.I32, 'num', None, 1, ),  # 2
)


class select_link_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
                        _elem131.read(iprot)
                        self.success.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('select_link_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter132 in self.success:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(select_link_result)
select_link_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmStoreMgmCommon.ttypes.ncLinkInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_link_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_link_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_link_args)
create_link_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmCommon.ttypes.ncLinkInfo, None], None, ),  # 1
)


class create_link_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_link_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_link_result)
create_link_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmStoreMgmCommon.ttypes.ncLinkInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_link_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_link_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_link_args)
delete_link_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncCdmStoreMgmCommon.ttypes.ncLinkInfo, None], None, ),  # 1
)


class delete_link_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_link_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_link_result)
delete_link_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fc_args(object):
    """
    Attributes:
     - pool_id

    """


    def __init__(self, pool_id=None,):
        self.pool_id = pool_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fc_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fc_args)
get_fc_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
)


class get_fc_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter139 in self.success:
                oprot.writeString(iter139.encode('utf-8') if sys.version_info[0] == 2 else iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fc_result)
get_fc_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

