# -*- coding: UTF-8 -*-
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=UTF-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def microprobe(self):
        """
        服务探针，测试服务可用性

        @ throw ncException

        """
        pass

    def get_all_jobs(self):
        pass

    def get_all_mount_jobs(self):
        pass

    def get_all_mounted_images(self):
        pass

    def get_backup_jobs_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        pass

    def get_mount_jobs_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        pass

    def get_residue_mount_jobs_by_pool(self, pool_id):
        """
        根据存储池Ip获取有残留的克隆卷的mount任务
        @param pool_id 存储池ID
        @return  有残留的克隆卷的mount任务 list<ncJob.ncTJob>

        Parameters:
         - pool_id

        """
        pass

    def get_images_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        pass

    def get_job(self, jobId):
        """
        Parameters:
         - jobId

        """
        pass

    def update_jobs_nstart_time(self, jobs_params):
        """
        Parameters:
         - jobs_params

        """
        pass

    def get_jobs_like_for_schedule(self, jobName, clientIds):
        """
        Parameters:
         - jobName
         - clientIds

        """
        pass

    def get_jobs_for_schedule_by_ids(self, jobIds):
        """
        根据id组获取job

        @return

        @throw ncException

        Parameters:
         - jobIds

        """
        pass

    def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        """
        Parameters:
         - jobId
         - customer
         - backupType
         - desc
         - is_auto_execute
         - nstart_time
         - strategy_id

        """
        pass

    def get_support_backup_type(self, job_id):
        """
        Parameters:
         - job_id

        """
        pass

    def get_jobs_by_instance_name(self, instance_name):
        """
        Parameters:
         - instance_name

        """
        pass

    def client_exsit_job(self, clientId):
        """
        检测客户端是否关联任务

        @param clientId: 客户端ID

        Parameters:
         - clientId

        """
        pass

    def get_db_job_instances(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_db_job_mappings(self, request):
        """
        Parameters:
         - request

        """
        pass

    def ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
        """
        对存储卷执行一次快照

        @param poolUuid: 存储池Uuid
        @param volUuids: 虚拟卷Uuid集合
        @param copiesNum: 快照保留副本数
        @param timePoint: windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

        @return 执行结果，0：代表不需要删除日志时间点，大于零需删除最旧快照点之前的所有日志时间点

        Parameters:
         - lunUuids
         - copiesNum
         - timePoint

        """
        pass

    def ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
        """
        Parameters:
         - lunUuids
         - copiesNum
         - timePoint

        """
        pass

    def del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
        """
        Parameters:
         - lunUuids
         - copiesNum

        """
        pass

    def ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
        """
         @param lunUuids:虚拟卷ID集合
          @param backupType:备份方式 全备(1) 增备(2)
          @param jobCid:jobcid
          @param protocol:FC/ISCSI FC(1) ISCSI(0)
          @return 执行结果 mirrorRelationShip
        mirrorRelationShip = backup_volid + "#"+back_snapshotid+"#" + createTime + "#" +base_snapshotid+"#"+volid+"#"+"volname"+"*"
        createTime可以传回执行快照时间，保证同一个任务中所有数据源中的时间一致
        basevolid 需要备份的快照volid
        back_snapshotid需要备份的快照id
        base_snapshotid 增量备份需要的，上一个快照的id,如果是全量备份，传递空值
        volid 源LUN的void
        volname 源LUN的volname

        Parameters:
         - lunUuids
         - backupType
         - jobCid
         - protocol

        """
        pass

    def UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
        """
        更新snapshot mapping数据库
        @param clientInfo:客户短信息
        @param snapshotName:快照名字
        @param drivername:挂载后的盘符名字
        @return 执行结果

        Parameters:
         - clientMac
         - connector
         - snapshotName
         - drivername

        """
        pass

    def GetLunCopyStatus(self, volId, lunCopyId):
        """
        获取卷拷贝的执行进度
        @param volId:源卷ID
        @param lunCopyId:拷贝任务ID
        @return 执行进度

        Parameters:
         - volId
         - lunCopyId

        """
        pass

    def CreateTimepoint(self, lunUuids, timePoint):
        """
        将任务中的卷快照间隔的CDP时间戳存入服务器中

        @param lunUuids:虚拟镜像卷ID集合
        @param timePoint:windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

        @return null

        Parameters:
         - lunUuids
         - timePoint

        """
        pass

    def remove_all_jobs_by_client_ids(self, clientIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - clientIds

        """
        pass

    def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - vplatformIds

        """
        pass

    def stop_backup_jobs_by_pool(self, pool_id, pool_name):
        """
        停止存储池相关的备份任务


        Parameters:
         - pool_id
         - pool_name

        """
        pass

    def getTaskCdmLuns(self, jobid):
        """
        获取任务的信息

        @param jobid 任务id

        @return list <string> 任务关联的基本卷


        Parameters:
         - jobid

        """
        pass

    def createCdmLun(self, size, jobId):
        """
        创建CDM卷

        @param size,       申请的空间大小

        @return ncReplyVmDiskInfo,        返回CDM卷

        Parameters:
         - size
         - jobId

        """
        pass

    def updateCdmLunInfo(self, cdmLuns, jobId):
        """
        更新CDM卷容量信息

        @param cdmLuns,

        @return

        Parameters:
         - cdmLuns
         - jobId

        """
        pass

    def createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
        """
        记录虚拟机与CDM卷信息

        @param cdmLuns,

        @return

        Parameters:
         - vmVolumes
         - job_id
         - timepoint

        """
        pass

    def getVmCdmLunInfo(self, job_id, vmuuid):
        """
        查询虚拟机与CDM卷信息

        @param cdmLuns,

        @return

        Parameters:
         - job_id
         - vmuuid

        """
        pass

    def createVmwareTimePoint(self, vminfos, timepoint, job_id):
        """
        记录虚拟机备份成功信息

        @param ncRequestVmInfo,

        @return

        Parameters:
         - vminfos
         - timepoint
         - job_id

        """
        pass

    def get_all_backup_jobs_historys_for_ams(self):
        """
        获取任务执行记录，用来与AMS消息推送

        @return 任务执行记录

        """
        pass

    def get_all_backup_jobs_for_ams(self):
        """
        获取所有任务,用来推送给AMS

        @return 任务对象列表

        """
        pass

    def get_all_mount_job_for_ams(self):
        """
        获取数据访问任务,用来推送给AMS

        @return 任务对象列表

        """
        pass

    def get_all_mount_jobInstance_for_ams(self):
        """
        获取数据访问任务的执行记录,用来推送给AMS

        @return 任务对象列表

        """
        pass

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        pass

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        pass

    def is_exists_running_job_on_client(self, clientId):
        """
        *  客户端上是否存在正则运行的任务
           @ return True:存在正在运行的任务, False： 不存在正在运行的任务
        *

        Parameters:
         - clientId

        """
        pass

    def is_exists_time_points_by_backup_job_id(self, backup_job_id):
        """
        *  根据备份任务id是否存在时间点
           @ return True:存在时间点, False： 不存在时间点
        *

        Parameters:
         - backup_job_id

        """
        pass

    def is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
        """
        *  根据备份任务id是否存在基本卷
           @ return True:存在基本卷, False： 不存在基本卷
        *

        Parameters:
         - backup_job_id

        """
        pass

    def get_origin_job_by_id(self, originJobId):
        """
        获取本地的同步任务信息，源端最原始的backupJobId,
         @ return ncCanSyncJobResponseData


        Parameters:
         - originJobId

        """
        pass

    def get_time_points_by_origin_job_id(self, TimePointReq):
        """
        获取最原始的backupJobId的时间点，默认按照时间戳降序
         @ return list<ncTimePointInfo>


        Parameters:
         - TimePointReq

        """
        pass

    def create_sync_job(self, createSyncJobReq):
        """
        根据createSyncJobReq创建在目的端创建任务同步任务


        Parameters:
         - createSyncJobReq

        """
        pass

    def get_can_sync_jobs(self, canSyncJobReq):
        """
        根据canSyncJobReq获取可以被远程复制的任务，包括拷贝的备份任务的数据和远程复制过来的任务
         @ return ncCdmDispatchProto.ncCanSyncJobResponse


        Parameters:
         - canSyncJobReq

        """
        pass

    def create_sync_time_point(self, createSyncTimePointReq):
        """
        根据时间点信息在目的端创建同步任务的时间点


        Parameters:
         - createSyncTimePointReq

        """
        pass

    def is_exists_origin_job_by_id(self, originJobId):
        """
        根据最原始的backupJobId，判断目的端是否已经同步过
         @ return bool


        Parameters:
         - originJobId

        """
        pass

    def create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
        """
        远程复制开始的时候根据时间点的信息在目的端创建未完成的时间点
        @ return ncCdmDispatchProto.ncCreateSyncTimePointResponse


        Parameters:
         - createSyncTimePointReq

        """
        pass

    def update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
        """
        远程复制结束的时候根据时间点的信息在目的端更新时间点信息为已完成的时间点


        Parameters:
         - updateSyncTimePointReq

        """
        pass

    def update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
        """
        远程复制中途的时候根据时间点快照卷的信息更新同步的时间点的快照卷的信息


        Parameters:
         - updateSyncTimePointVolumeReq

        """
        pass

    def delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
        """
        远程复制删除未完成的时间点
         @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


        Parameters:
         - deleteSyncTimePointIds

        """
        pass

    def update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
        """
        远程复制过程中更新任务的状态
         @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


        Parameters:
         - UpdateJobStatusReq

        """
        pass

    def check_time_point_is_exist(self, timePointId):
        """
        检测时间点是否存在，只检测状态是完成状态的时间点，其他状态视为不存在时间点
        @ return True:存在时间点, False： 不存在时间点


        Parameters:
         - timePointId

        """
        pass

    def get_dict_export(self, body, jobInstanceId, userId):
        """
        获取image的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        pass

    def mount_get_dict_export(self, body, jobInstanceId, userId):
        """
        获取mount任务的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        pass

    def backup_get_dict_export(self, body, jobInstanceId, userId):
        """
        获取备份任务的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        pass

    def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        """
        生产资源类型 sourceType
        服务类型     svcType
        生产资源标识 sourceId
        @ return


        Parameters:
         - sourceType
         - svcType
         - sourceId
         - relation

        """
        pass

    def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        """
        数据源       datasource
        客户端ID     clientId
        数据源的用户名(适用于多用户场景)   dbRunUserName
        @ return


        Parameters:
         - datasource
         - clientId
         - dbRunUserName

        """
        pass

    def get_sync_job_origin_job_by_id(self, originJobId):
        """
        根据originJobId获取同步任务的信息
        @ return


        Parameters:
         - originJobId

        """
        pass

    def check_user_has_data(self, user_list):
        """
        检测用户是否存在存储数据
        @ return 返回有存储数据的用户列表


        Parameters:
         - user_list

        """
        pass

    def resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id, login_ip):
        """
         清理CDM数据清理任务的时间点
        input:清理任务的id,清理类型,时间点,当前登陆用户
         @ return


        Parameters:
         - job_id
         - clean_type
         - time_points
         - user
         - clean_job_id
         - login_ip

        """
        pass

    def get_job_count_info(self, startTime, userId):
        """
        获取CDM备份任务数
        @ return 备份任务的数量


        Parameters:
         - startTime
         - userId

        """
        pass

    def run_backup_job_handler(self, job_instance_id, user_id):
        """
        运行备份任务转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        pass

    def run_mount_job_handler(self, job_instance_id, user_id):
        """
        运行挂载任务转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        pass

    def image_mount_handler(self, job_instance_id, user_id):
        """
        image mount操作转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        pass

    def image_unmount_handler(self, job_instance_id, user_id):
        """
        image unmount操作转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        pass

    def delete_extra_resource_by_username(self, user_names):
        """
        根据用户名删除用户对应的资源
        @ return


        Parameters:
         - user_names

        """
        pass

    def get_task_src_from_DB(self, job_id):
        """
        获取数据库中的任务的数据源
        @ return list<string>


        Parameters:
         - job_id

        """
        pass

    def get_all_jobs_by_pages(self, BaseReq):
        """
        分页获取指定用户下的备份任务
        @ return list<ncJob.ncTJob>


        Parameters:
         - BaseReq

        """
        pass

    def get_cdmdatasource_by_client(self, client_id, job_is_backup):
        """
        获取cdm一个客户端下所有数据源
        @ return list<string>


        Parameters:
         - client_id
         - job_is_backup

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def microprobe(self):
        """
        服务探针，测试服务可用性

        @ throw ncException

        """
        self.send_microprobe()
        self.recv_microprobe()

    def send_microprobe(self):
        self._oprot.writeMessageBegin('microprobe', TMessageType.CALL, self._seqid)
        args = microprobe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_microprobe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = microprobe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_all_jobs(self):
        self.send_get_all_jobs()
        return self.recv_get_all_jobs()

    def send_get_all_jobs(self):
        self._oprot.writeMessageBegin('get_all_jobs', TMessageType.CALL, self._seqid)
        args = get_all_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs failed: unknown result")

    def get_all_mount_jobs(self):
        self.send_get_all_mount_jobs()
        return self.recv_get_all_mount_jobs()

    def send_get_all_mount_jobs(self):
        self._oprot.writeMessageBegin('get_all_mount_jobs', TMessageType.CALL, self._seqid)
        args = get_all_mount_jobs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_mount_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_mount_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_jobs failed: unknown result")

    def get_all_mounted_images(self):
        self.send_get_all_mounted_images()
        return self.recv_get_all_mounted_images()

    def send_get_all_mounted_images(self):
        self._oprot.writeMessageBegin('get_all_mounted_images', TMessageType.CALL, self._seqid)
        args = get_all_mounted_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_mounted_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_mounted_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mounted_images failed: unknown result")

    def get_backup_jobs_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        self.send_get_backup_jobs_by_pool(pool_id)
        return self.recv_get_backup_jobs_by_pool()

    def send_get_backup_jobs_by_pool(self, pool_id):
        self._oprot.writeMessageBegin('get_backup_jobs_by_pool', TMessageType.CALL, self._seqid)
        args = get_backup_jobs_by_pool_args()
        args.pool_id = pool_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backup_jobs_by_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backup_jobs_by_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backup_jobs_by_pool failed: unknown result")

    def get_mount_jobs_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        self.send_get_mount_jobs_by_pool(pool_id)
        return self.recv_get_mount_jobs_by_pool()

    def send_get_mount_jobs_by_pool(self, pool_id):
        self._oprot.writeMessageBegin('get_mount_jobs_by_pool', TMessageType.CALL, self._seqid)
        args = get_mount_jobs_by_pool_args()
        args.pool_id = pool_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_mount_jobs_by_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_mount_jobs_by_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_mount_jobs_by_pool failed: unknown result")

    def get_residue_mount_jobs_by_pool(self, pool_id):
        """
        根据存储池Ip获取有残留的克隆卷的mount任务
        @param pool_id 存储池ID
        @return  有残留的克隆卷的mount任务 list<ncJob.ncTJob>

        Parameters:
         - pool_id

        """
        self.send_get_residue_mount_jobs_by_pool(pool_id)
        return self.recv_get_residue_mount_jobs_by_pool()

    def send_get_residue_mount_jobs_by_pool(self, pool_id):
        self._oprot.writeMessageBegin('get_residue_mount_jobs_by_pool', TMessageType.CALL, self._seqid)
        args = get_residue_mount_jobs_by_pool_args()
        args.pool_id = pool_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_residue_mount_jobs_by_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_residue_mount_jobs_by_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_residue_mount_jobs_by_pool failed: unknown result")

    def get_images_by_pool(self, pool_id):
        """
        Parameters:
         - pool_id

        """
        self.send_get_images_by_pool(pool_id)
        return self.recv_get_images_by_pool()

    def send_get_images_by_pool(self, pool_id):
        self._oprot.writeMessageBegin('get_images_by_pool', TMessageType.CALL, self._seqid)
        args = get_images_by_pool_args()
        args.pool_id = pool_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_images_by_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_images_by_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_images_by_pool failed: unknown result")

    def get_job(self, jobId):
        """
        Parameters:
         - jobId

        """
        self.send_get_job(jobId)
        return self.recv_get_job()

    def send_get_job(self, jobId):
        self._oprot.writeMessageBegin('get_job', TMessageType.CALL, self._seqid)
        args = get_job_args()
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job failed: unknown result")

    def update_jobs_nstart_time(self, jobs_params):
        """
        Parameters:
         - jobs_params

        """
        self.send_update_jobs_nstart_time(jobs_params)
        self.recv_update_jobs_nstart_time()

    def send_update_jobs_nstart_time(self, jobs_params):
        self._oprot.writeMessageBegin('update_jobs_nstart_time', TMessageType.CALL, self._seqid)
        args = update_jobs_nstart_time_args()
        args.jobs_params = jobs_params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_jobs_nstart_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_jobs_nstart_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_jobs_like_for_schedule(self, jobName, clientIds):
        """
        Parameters:
         - jobName
         - clientIds

        """
        self.send_get_jobs_like_for_schedule(jobName, clientIds)
        return self.recv_get_jobs_like_for_schedule()

    def send_get_jobs_like_for_schedule(self, jobName, clientIds):
        self._oprot.writeMessageBegin('get_jobs_like_for_schedule', TMessageType.CALL, self._seqid)
        args = get_jobs_like_for_schedule_args()
        args.jobName = jobName
        args.clientIds = clientIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_like_for_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_like_for_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_like_for_schedule failed: unknown result")

    def get_jobs_for_schedule_by_ids(self, jobIds):
        """
        根据id组获取job

        @return

        @throw ncException

        Parameters:
         - jobIds

        """
        self.send_get_jobs_for_schedule_by_ids(jobIds)
        return self.recv_get_jobs_for_schedule_by_ids()

    def send_get_jobs_for_schedule_by_ids(self, jobIds):
        self._oprot.writeMessageBegin('get_jobs_for_schedule_by_ids', TMessageType.CALL, self._seqid)
        args = get_jobs_for_schedule_by_ids_args()
        args.jobIds = jobIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_for_schedule_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_for_schedule_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_for_schedule_by_ids failed: unknown result")

    def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        """
        Parameters:
         - jobId
         - customer
         - backupType
         - desc
         - is_auto_execute
         - nstart_time
         - strategy_id

        """
        self.send_commit_job(jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id)
        self.recv_commit_job()

    def send_commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
        self._oprot.writeMessageBegin('commit_job', TMessageType.CALL, self._seqid)
        args = commit_job_args()
        args.jobId = jobId
        args.customer = customer
        args.backupType = backupType
        args.desc = desc
        args.is_auto_execute = is_auto_execute
        args.nstart_time = nstart_time
        args.strategy_id = strategy_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_support_backup_type(self, job_id):
        """
        Parameters:
         - job_id

        """
        self.send_get_support_backup_type(job_id)
        return self.recv_get_support_backup_type()

    def send_get_support_backup_type(self, job_id):
        self._oprot.writeMessageBegin('get_support_backup_type', TMessageType.CALL, self._seqid)
        args = get_support_backup_type_args()
        args.job_id = job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_support_backup_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_support_backup_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_support_backup_type failed: unknown result")

    def get_jobs_by_instance_name(self, instance_name):
        """
        Parameters:
         - instance_name

        """
        self.send_get_jobs_by_instance_name(instance_name)
        return self.recv_get_jobs_by_instance_name()

    def send_get_jobs_by_instance_name(self, instance_name):
        self._oprot.writeMessageBegin('get_jobs_by_instance_name', TMessageType.CALL, self._seqid)
        args = get_jobs_by_instance_name_args()
        args.instance_name = instance_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_instance_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_instance_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_instance_name failed: unknown result")

    def client_exsit_job(self, clientId):
        """
        检测客户端是否关联任务

        @param clientId: 客户端ID

        Parameters:
         - clientId

        """
        self.send_client_exsit_job(clientId)
        return self.recv_client_exsit_job()

    def send_client_exsit_job(self, clientId):
        self._oprot.writeMessageBegin('client_exsit_job', TMessageType.CALL, self._seqid)
        args = client_exsit_job_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_exsit_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_exsit_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "client_exsit_job failed: unknown result")

    def get_db_job_instances(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_job_instances(request)
        return self.recv_get_db_job_instances()

    def send_get_db_job_instances(self, request):
        self._oprot.writeMessageBegin('get_db_job_instances', TMessageType.CALL, self._seqid)
        args = get_db_job_instances_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_job_instances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_job_instances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_instances failed: unknown result")

    def get_db_job_mappings(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_job_mappings(request)
        return self.recv_get_db_job_mappings()

    def send_get_db_job_mappings(self, request):
        self._oprot.writeMessageBegin('get_db_job_mappings', TMessageType.CALL, self._seqid)
        args = get_db_job_mappings_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_job_mappings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_job_mappings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_mappings failed: unknown result")

    def ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
        """
        对存储卷执行一次快照

        @param poolUuid: 存储池Uuid
        @param volUuids: 虚拟卷Uuid集合
        @param copiesNum: 快照保留副本数
        @param timePoint: windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

        @return 执行结果，0：代表不需要删除日志时间点，大于零需删除最旧快照点之前的所有日志时间点

        Parameters:
         - lunUuids
         - copiesNum
         - timePoint

        """
        self.send_ExcuteSnapshot(lunUuids, copiesNum, timePoint)
        self.recv_ExcuteSnapshot()

    def send_ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
        self._oprot.writeMessageBegin('ExcuteSnapshot', TMessageType.CALL, self._seqid)
        args = ExcuteSnapshot_args()
        args.lunUuids = lunUuids
        args.copiesNum = copiesNum
        args.timePoint = timePoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExcuteSnapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExcuteSnapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
        """
        Parameters:
         - lunUuids
         - copiesNum
         - timePoint

        """
        self.send_ExcuteSnapshotHw(lunUuids, copiesNum, timePoint)
        self.recv_ExcuteSnapshotHw()

    def send_ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
        self._oprot.writeMessageBegin('ExcuteSnapshotHw', TMessageType.CALL, self._seqid)
        args = ExcuteSnapshotHw_args()
        args.lunUuids = lunUuids
        args.copiesNum = copiesNum
        args.timePoint = timePoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExcuteSnapshotHw(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExcuteSnapshotHw_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
        """
        Parameters:
         - lunUuids
         - copiesNum

        """
        self.send_del_exceeded_snapshot_copies(lunUuids, copiesNum)
        return self.recv_del_exceeded_snapshot_copies()

    def send_del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
        self._oprot.writeMessageBegin('del_exceeded_snapshot_copies', TMessageType.CALL, self._seqid)
        args = del_exceeded_snapshot_copies_args()
        args.lunUuids = lunUuids
        args.copiesNum = copiesNum
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_exceeded_snapshot_copies(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_exceeded_snapshot_copies_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "del_exceeded_snapshot_copies failed: unknown result")

    def ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
        """
         @param lunUuids:虚拟卷ID集合
          @param backupType:备份方式 全备(1) 增备(2)
          @param jobCid:jobcid
          @param protocol:FC/ISCSI FC(1) ISCSI(0)
          @return 执行结果 mirrorRelationShip
        mirrorRelationShip = backup_volid + "#"+back_snapshotid+"#" + createTime + "#" +base_snapshotid+"#"+volid+"#"+"volname"+"*"
        createTime可以传回执行快照时间，保证同一个任务中所有数据源中的时间一致
        basevolid 需要备份的快照volid
        back_snapshotid需要备份的快照id
        base_snapshotid 增量备份需要的，上一个快照的id,如果是全量备份，传递空值
        volid 源LUN的void
        volname 源LUN的volname

        Parameters:
         - lunUuids
         - backupType
         - jobCid
         - protocol

        """
        self.send_ExcuteSnapshot_mount(lunUuids, backupType, jobCid, protocol)
        return self.recv_ExcuteSnapshot_mount()

    def send_ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
        self._oprot.writeMessageBegin('ExcuteSnapshot_mount', TMessageType.CALL, self._seqid)
        args = ExcuteSnapshot_mount_args()
        args.lunUuids = lunUuids
        args.backupType = backupType
        args.jobCid = jobCid
        args.protocol = protocol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExcuteSnapshot_mount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExcuteSnapshot_mount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ExcuteSnapshot_mount failed: unknown result")

    def UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
        """
        更新snapshot mapping数据库
        @param clientInfo:客户短信息
        @param snapshotName:快照名字
        @param drivername:挂载后的盘符名字
        @return 执行结果

        Parameters:
         - clientMac
         - connector
         - snapshotName
         - drivername

        """
        self.send_UpdateMountPoint(clientMac, connector, snapshotName, drivername)
        self.recv_UpdateMountPoint()

    def send_UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
        self._oprot.writeMessageBegin('UpdateMountPoint', TMessageType.CALL, self._seqid)
        args = UpdateMountPoint_args()
        args.clientMac = clientMac
        args.connector = connector
        args.snapshotName = snapshotName
        args.drivername = drivername
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_UpdateMountPoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = UpdateMountPoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def GetLunCopyStatus(self, volId, lunCopyId):
        """
        获取卷拷贝的执行进度
        @param volId:源卷ID
        @param lunCopyId:拷贝任务ID
        @return 执行进度

        Parameters:
         - volId
         - lunCopyId

        """
        self.send_GetLunCopyStatus(volId, lunCopyId)
        return self.recv_GetLunCopyStatus()

    def send_GetLunCopyStatus(self, volId, lunCopyId):
        self._oprot.writeMessageBegin('GetLunCopyStatus', TMessageType.CALL, self._seqid)
        args = GetLunCopyStatus_args()
        args.volId = volId
        args.lunCopyId = lunCopyId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLunCopyStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLunCopyStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLunCopyStatus failed: unknown result")

    def CreateTimepoint(self, lunUuids, timePoint):
        """
        将任务中的卷快照间隔的CDP时间戳存入服务器中

        @param lunUuids:虚拟镜像卷ID集合
        @param timePoint:windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

        @return null

        Parameters:
         - lunUuids
         - timePoint

        """
        self.send_CreateTimepoint(lunUuids, timePoint)
        self.recv_CreateTimepoint()

    def send_CreateTimepoint(self, lunUuids, timePoint):
        self._oprot.writeMessageBegin('CreateTimepoint', TMessageType.CALL, self._seqid)
        args = CreateTimepoint_args()
        args.lunUuids = lunUuids
        args.timePoint = timePoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateTimepoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateTimepoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def remove_all_jobs_by_client_ids(self, clientIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - clientIds

        """
        self.send_remove_all_jobs_by_client_ids(clientIds)
        return self.recv_remove_all_jobs_by_client_ids()

    def send_remove_all_jobs_by_client_ids(self, clientIds):
        self._oprot.writeMessageBegin('remove_all_jobs_by_client_ids', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_client_ids_args()
        args.clientIds = clientIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_client_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_client_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_client_ids failed: unknown result")

    def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        """
        批量删除任务 根据权限用户


        Parameters:
         - vplatformIds

        """
        self.send_remove_all_jobs_by_vplatform_ids(vplatformIds)
        return self.recv_remove_all_jobs_by_vplatform_ids()

    def send_remove_all_jobs_by_vplatform_ids(self, vplatformIds):
        self._oprot.writeMessageBegin('remove_all_jobs_by_vplatform_ids', TMessageType.CALL, self._seqid)
        args = remove_all_jobs_by_vplatform_ids_args()
        args.vplatformIds = vplatformIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_jobs_by_vplatform_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_jobs_by_vplatform_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_vplatform_ids failed: unknown result")

    def stop_backup_jobs_by_pool(self, pool_id, pool_name):
        """
        停止存储池相关的备份任务


        Parameters:
         - pool_id
         - pool_name

        """
        self.send_stop_backup_jobs_by_pool(pool_id, pool_name)
        self.recv_stop_backup_jobs_by_pool()

    def send_stop_backup_jobs_by_pool(self, pool_id, pool_name):
        self._oprot.writeMessageBegin('stop_backup_jobs_by_pool', TMessageType.CALL, self._seqid)
        args = stop_backup_jobs_by_pool_args()
        args.pool_id = pool_id
        args.pool_name = pool_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_backup_jobs_by_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_backup_jobs_by_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def getTaskCdmLuns(self, jobid):
        """
        获取任务的信息

        @param jobid 任务id

        @return list <string> 任务关联的基本卷


        Parameters:
         - jobid

        """
        self.send_getTaskCdmLuns(jobid)
        return self.recv_getTaskCdmLuns()

    def send_getTaskCdmLuns(self, jobid):
        self._oprot.writeMessageBegin('getTaskCdmLuns', TMessageType.CALL, self._seqid)
        args = getTaskCdmLuns_args()
        args.jobid = jobid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getTaskCdmLuns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getTaskCdmLuns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTaskCdmLuns failed: unknown result")

    def createCdmLun(self, size, jobId):
        """
        创建CDM卷

        @param size,       申请的空间大小

        @return ncReplyVmDiskInfo,        返回CDM卷

        Parameters:
         - size
         - jobId

        """
        self.send_createCdmLun(size, jobId)
        return self.recv_createCdmLun()

    def send_createCdmLun(self, size, jobId):
        self._oprot.writeMessageBegin('createCdmLun', TMessageType.CALL, self._seqid)
        args = createCdmLun_args()
        args.size = size
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createCdmLun(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createCdmLun_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createCdmLun failed: unknown result")

    def updateCdmLunInfo(self, cdmLuns, jobId):
        """
        更新CDM卷容量信息

        @param cdmLuns,

        @return

        Parameters:
         - cdmLuns
         - jobId

        """
        self.send_updateCdmLunInfo(cdmLuns, jobId)
        self.recv_updateCdmLunInfo()

    def send_updateCdmLunInfo(self, cdmLuns, jobId):
        self._oprot.writeMessageBegin('updateCdmLunInfo', TMessageType.CALL, self._seqid)
        args = updateCdmLunInfo_args()
        args.cdmLuns = cdmLuns
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateCdmLunInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateCdmLunInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
        """
        记录虚拟机与CDM卷信息

        @param cdmLuns,

        @return

        Parameters:
         - vmVolumes
         - job_id
         - timepoint

        """
        self.send_createVmCdmLunInfo(vmVolumes, job_id, timepoint)
        self.recv_createVmCdmLunInfo()

    def send_createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
        self._oprot.writeMessageBegin('createVmCdmLunInfo', TMessageType.CALL, self._seqid)
        args = createVmCdmLunInfo_args()
        args.vmVolumes = vmVolumes
        args.job_id = job_id
        args.timepoint = timepoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createVmCdmLunInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createVmCdmLunInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def getVmCdmLunInfo(self, job_id, vmuuid):
        """
        查询虚拟机与CDM卷信息

        @param cdmLuns,

        @return

        Parameters:
         - job_id
         - vmuuid

        """
        self.send_getVmCdmLunInfo(job_id, vmuuid)
        return self.recv_getVmCdmLunInfo()

    def send_getVmCdmLunInfo(self, job_id, vmuuid):
        self._oprot.writeMessageBegin('getVmCdmLunInfo', TMessageType.CALL, self._seqid)
        args = getVmCdmLunInfo_args()
        args.job_id = job_id
        args.vmuuid = vmuuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getVmCdmLunInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getVmCdmLunInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getVmCdmLunInfo failed: unknown result")

    def createVmwareTimePoint(self, vminfos, timepoint, job_id):
        """
        记录虚拟机备份成功信息

        @param ncRequestVmInfo,

        @return

        Parameters:
         - vminfos
         - timepoint
         - job_id

        """
        self.send_createVmwareTimePoint(vminfos, timepoint, job_id)
        self.recv_createVmwareTimePoint()

    def send_createVmwareTimePoint(self, vminfos, timepoint, job_id):
        self._oprot.writeMessageBegin('createVmwareTimePoint', TMessageType.CALL, self._seqid)
        args = createVmwareTimePoint_args()
        args.vminfos = vminfos
        args.timepoint = timepoint
        args.job_id = job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createVmwareTimePoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createVmwareTimePoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def get_all_backup_jobs_historys_for_ams(self):
        """
        获取任务执行记录，用来与AMS消息推送

        @return 任务执行记录

        """
        self.send_get_all_backup_jobs_historys_for_ams()
        return self.recv_get_all_backup_jobs_historys_for_ams()

    def send_get_all_backup_jobs_historys_for_ams(self):
        self._oprot.writeMessageBegin('get_all_backup_jobs_historys_for_ams', TMessageType.CALL, self._seqid)
        args = get_all_backup_jobs_historys_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_backup_jobs_historys_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_backup_jobs_historys_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_backup_jobs_historys_for_ams failed: unknown result")

    def get_all_backup_jobs_for_ams(self):
        """
        获取所有任务,用来推送给AMS

        @return 任务对象列表

        """
        self.send_get_all_backup_jobs_for_ams()
        return self.recv_get_all_backup_jobs_for_ams()

    def send_get_all_backup_jobs_for_ams(self):
        self._oprot.writeMessageBegin('get_all_backup_jobs_for_ams', TMessageType.CALL, self._seqid)
        args = get_all_backup_jobs_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_backup_jobs_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_backup_jobs_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_backup_jobs_for_ams failed: unknown result")

    def get_all_mount_job_for_ams(self):
        """
        获取数据访问任务,用来推送给AMS

        @return 任务对象列表

        """
        self.send_get_all_mount_job_for_ams()
        return self.recv_get_all_mount_job_for_ams()

    def send_get_all_mount_job_for_ams(self):
        self._oprot.writeMessageBegin('get_all_mount_job_for_ams', TMessageType.CALL, self._seqid)
        args = get_all_mount_job_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_mount_job_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_mount_job_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_job_for_ams failed: unknown result")

    def get_all_mount_jobInstance_for_ams(self):
        """
        获取数据访问任务的执行记录,用来推送给AMS

        @return 任务对象列表

        """
        self.send_get_all_mount_jobInstance_for_ams()
        return self.recv_get_all_mount_jobInstance_for_ams()

    def send_get_all_mount_jobInstance_for_ams(self):
        self._oprot.writeMessageBegin('get_all_mount_jobInstance_for_ams', TMessageType.CALL, self._seqid)
        args = get_all_mount_jobInstance_for_ams_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_mount_jobInstance_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_mount_jobInstance_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_jobInstance_for_ams failed: unknown result")

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        self.send_get_data_for_ams(kwargs)
        return self.recv_get_data_for_ams()

    def send_get_data_for_ams(self, kwargs):
        self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
        args = get_data_for_ams_args()
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        self.send_do_operation_from_ams(target, method, kwargs)
        return self.recv_do_operation_from_ams()

    def send_do_operation_from_ams(self, target, method, kwargs):
        self._oprot.writeMessageBegin('do_operation_from_ams', TMessageType.CALL, self._seqid)
        args = do_operation_from_ams_args()
        args.target = target
        args.method = method
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_do_operation_from_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = do_operation_from_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "do_operation_from_ams failed: unknown result")

    def is_exists_running_job_on_client(self, clientId):
        """
        *  客户端上是否存在正则运行的任务
           @ return True:存在正在运行的任务, False： 不存在正在运行的任务
        *

        Parameters:
         - clientId

        """
        self.send_is_exists_running_job_on_client(clientId)
        return self.recv_is_exists_running_job_on_client()

    def send_is_exists_running_job_on_client(self, clientId):
        self._oprot.writeMessageBegin('is_exists_running_job_on_client', TMessageType.CALL, self._seqid)
        args = is_exists_running_job_on_client_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_exists_running_job_on_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_exists_running_job_on_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_running_job_on_client failed: unknown result")

    def is_exists_time_points_by_backup_job_id(self, backup_job_id):
        """
        *  根据备份任务id是否存在时间点
           @ return True:存在时间点, False： 不存在时间点
        *

        Parameters:
         - backup_job_id

        """
        self.send_is_exists_time_points_by_backup_job_id(backup_job_id)
        return self.recv_is_exists_time_points_by_backup_job_id()

    def send_is_exists_time_points_by_backup_job_id(self, backup_job_id):
        self._oprot.writeMessageBegin('is_exists_time_points_by_backup_job_id', TMessageType.CALL, self._seqid)
        args = is_exists_time_points_by_backup_job_id_args()
        args.backup_job_id = backup_job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_exists_time_points_by_backup_job_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_exists_time_points_by_backup_job_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_time_points_by_backup_job_id failed: unknown result")

    def is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
        """
        *  根据备份任务id是否存在基本卷
           @ return True:存在基本卷, False： 不存在基本卷
        *

        Parameters:
         - backup_job_id

        """
        self.send_is_exists_base_volumes_by_backup_job_id(backup_job_id)
        return self.recv_is_exists_base_volumes_by_backup_job_id()

    def send_is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
        self._oprot.writeMessageBegin('is_exists_base_volumes_by_backup_job_id', TMessageType.CALL, self._seqid)
        args = is_exists_base_volumes_by_backup_job_id_args()
        args.backup_job_id = backup_job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_exists_base_volumes_by_backup_job_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_exists_base_volumes_by_backup_job_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_base_volumes_by_backup_job_id failed: unknown result")

    def get_origin_job_by_id(self, originJobId):
        """
        获取本地的同步任务信息，源端最原始的backupJobId,
         @ return ncCanSyncJobResponseData


        Parameters:
         - originJobId

        """
        self.send_get_origin_job_by_id(originJobId)
        return self.recv_get_origin_job_by_id()

    def send_get_origin_job_by_id(self, originJobId):
        self._oprot.writeMessageBegin('get_origin_job_by_id', TMessageType.CALL, self._seqid)
        args = get_origin_job_by_id_args()
        args.originJobId = originJobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_origin_job_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_origin_job_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_origin_job_by_id failed: unknown result")

    def get_time_points_by_origin_job_id(self, TimePointReq):
        """
        获取最原始的backupJobId的时间点，默认按照时间戳降序
         @ return list<ncTimePointInfo>


        Parameters:
         - TimePointReq

        """
        self.send_get_time_points_by_origin_job_id(TimePointReq)
        return self.recv_get_time_points_by_origin_job_id()

    def send_get_time_points_by_origin_job_id(self, TimePointReq):
        self._oprot.writeMessageBegin('get_time_points_by_origin_job_id', TMessageType.CALL, self._seqid)
        args = get_time_points_by_origin_job_id_args()
        args.TimePointReq = TimePointReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_time_points_by_origin_job_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_time_points_by_origin_job_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_time_points_by_origin_job_id failed: unknown result")

    def create_sync_job(self, createSyncJobReq):
        """
        根据createSyncJobReq创建在目的端创建任务同步任务


        Parameters:
         - createSyncJobReq

        """
        self.send_create_sync_job(createSyncJobReq)
        self.recv_create_sync_job()

    def send_create_sync_job(self, createSyncJobReq):
        self._oprot.writeMessageBegin('create_sync_job', TMessageType.CALL, self._seqid)
        args = create_sync_job_args()
        args.createSyncJobReq = createSyncJobReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_sync_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_sync_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_can_sync_jobs(self, canSyncJobReq):
        """
        根据canSyncJobReq获取可以被远程复制的任务，包括拷贝的备份任务的数据和远程复制过来的任务
         @ return ncCdmDispatchProto.ncCanSyncJobResponse


        Parameters:
         - canSyncJobReq

        """
        self.send_get_can_sync_jobs(canSyncJobReq)
        return self.recv_get_can_sync_jobs()

    def send_get_can_sync_jobs(self, canSyncJobReq):
        self._oprot.writeMessageBegin('get_can_sync_jobs', TMessageType.CALL, self._seqid)
        args = get_can_sync_jobs_args()
        args.canSyncJobReq = canSyncJobReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_can_sync_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_can_sync_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_can_sync_jobs failed: unknown result")

    def create_sync_time_point(self, createSyncTimePointReq):
        """
        根据时间点信息在目的端创建同步任务的时间点


        Parameters:
         - createSyncTimePointReq

        """
        self.send_create_sync_time_point(createSyncTimePointReq)
        self.recv_create_sync_time_point()

    def send_create_sync_time_point(self, createSyncTimePointReq):
        self._oprot.writeMessageBegin('create_sync_time_point', TMessageType.CALL, self._seqid)
        args = create_sync_time_point_args()
        args.createSyncTimePointReq = createSyncTimePointReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_sync_time_point(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_sync_time_point_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def is_exists_origin_job_by_id(self, originJobId):
        """
        根据最原始的backupJobId，判断目的端是否已经同步过
         @ return bool


        Parameters:
         - originJobId

        """
        self.send_is_exists_origin_job_by_id(originJobId)
        return self.recv_is_exists_origin_job_by_id()

    def send_is_exists_origin_job_by_id(self, originJobId):
        self._oprot.writeMessageBegin('is_exists_origin_job_by_id', TMessageType.CALL, self._seqid)
        args = is_exists_origin_job_by_id_args()
        args.originJobId = originJobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_exists_origin_job_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_exists_origin_job_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_origin_job_by_id failed: unknown result")

    def create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
        """
        远程复制开始的时候根据时间点的信息在目的端创建未完成的时间点
        @ return ncCdmDispatchProto.ncCreateSyncTimePointResponse


        Parameters:
         - createSyncTimePointReq

        """
        self.send_create_sync_time_point_on_sync_start(createSyncTimePointReq)
        return self.recv_create_sync_time_point_on_sync_start()

    def send_create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
        self._oprot.writeMessageBegin('create_sync_time_point_on_sync_start', TMessageType.CALL, self._seqid)
        args = create_sync_time_point_on_sync_start_args()
        args.createSyncTimePointReq = createSyncTimePointReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_sync_time_point_on_sync_start(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_sync_time_point_on_sync_start_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_sync_time_point_on_sync_start failed: unknown result")

    def update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
        """
        远程复制结束的时候根据时间点的信息在目的端更新时间点信息为已完成的时间点


        Parameters:
         - updateSyncTimePointReq

        """
        self.send_update_sync_time_point_on_sync_finish(updateSyncTimePointReq)
        self.recv_update_sync_time_point_on_sync_finish()

    def send_update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
        self._oprot.writeMessageBegin('update_sync_time_point_on_sync_finish', TMessageType.CALL, self._seqid)
        args = update_sync_time_point_on_sync_finish_args()
        args.updateSyncTimePointReq = updateSyncTimePointReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_sync_time_point_on_sync_finish(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_sync_time_point_on_sync_finish_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
        """
        远程复制中途的时候根据时间点快照卷的信息更新同步的时间点的快照卷的信息


        Parameters:
         - updateSyncTimePointVolumeReq

        """
        self.send_update_sync_time_point_base_map_snap(updateSyncTimePointVolumeReq)
        self.recv_update_sync_time_point_base_map_snap()

    def send_update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
        self._oprot.writeMessageBegin('update_sync_time_point_base_map_snap', TMessageType.CALL, self._seqid)
        args = update_sync_time_point_base_map_snap_args()
        args.updateSyncTimePointVolumeReq = updateSyncTimePointVolumeReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_sync_time_point_base_map_snap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_sync_time_point_base_map_snap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
        """
        远程复制删除未完成的时间点
         @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


        Parameters:
         - deleteSyncTimePointIds

        """
        self.send_delete_sync_time_point_by_id(deleteSyncTimePointIds)
        return self.recv_delete_sync_time_point_by_id()

    def send_delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
        self._oprot.writeMessageBegin('delete_sync_time_point_by_id', TMessageType.CALL, self._seqid)
        args = delete_sync_time_point_by_id_args()
        args.deleteSyncTimePointIds = deleteSyncTimePointIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_sync_time_point_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_sync_time_point_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_sync_time_point_by_id failed: unknown result")

    def update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
        """
        远程复制过程中更新任务的状态
         @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


        Parameters:
         - UpdateJobStatusReq

        """
        self.send_update_job_status_origin_job_by_id(UpdateJobStatusReq)
        self.recv_update_job_status_origin_job_by_id()

    def send_update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
        self._oprot.writeMessageBegin('update_job_status_origin_job_by_id', TMessageType.CALL, self._seqid)
        args = update_job_status_origin_job_by_id_args()
        args.UpdateJobStatusReq = UpdateJobStatusReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_job_status_origin_job_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_job_status_origin_job_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def check_time_point_is_exist(self, timePointId):
        """
        检测时间点是否存在，只检测状态是完成状态的时间点，其他状态视为不存在时间点
        @ return True:存在时间点, False： 不存在时间点


        Parameters:
         - timePointId

        """
        self.send_check_time_point_is_exist(timePointId)
        return self.recv_check_time_point_is_exist()

    def send_check_time_point_is_exist(self, timePointId):
        self._oprot.writeMessageBegin('check_time_point_is_exist', TMessageType.CALL, self._seqid)
        args = check_time_point_is_exist_args()
        args.timePointId = timePointId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_time_point_is_exist(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_time_point_is_exist_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_time_point_is_exist failed: unknown result")

    def get_dict_export(self, body, jobInstanceId, userId):
        """
        获取image的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        self.send_get_dict_export(body, jobInstanceId, userId)
        return self.recv_get_dict_export()

    def send_get_dict_export(self, body, jobInstanceId, userId):
        self._oprot.writeMessageBegin('get_dict_export', TMessageType.CALL, self._seqid)
        args = get_dict_export_args()
        args.body = body
        args.jobInstanceId = jobInstanceId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dict_export(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dict_export_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dict_export failed: unknown result")

    def mount_get_dict_export(self, body, jobInstanceId, userId):
        """
        获取mount任务的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        self.send_mount_get_dict_export(body, jobInstanceId, userId)
        return self.recv_mount_get_dict_export()

    def send_mount_get_dict_export(self, body, jobInstanceId, userId):
        self._oprot.writeMessageBegin('mount_get_dict_export', TMessageType.CALL, self._seqid)
        args = mount_get_dict_export_args()
        args.body = body
        args.jobInstanceId = jobInstanceId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mount_get_dict_export(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mount_get_dict_export_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mount_get_dict_export failed: unknown result")

    def backup_get_dict_export(self, body, jobInstanceId, userId):
        """
        获取备份任务的执行输出，并导出日志
        @ return


        Parameters:
         - body
         - jobInstanceId
         - userId

        """
        self.send_backup_get_dict_export(body, jobInstanceId, userId)
        return self.recv_backup_get_dict_export()

    def send_backup_get_dict_export(self, body, jobInstanceId, userId):
        self._oprot.writeMessageBegin('backup_get_dict_export', TMessageType.CALL, self._seqid)
        args = backup_get_dict_export_args()
        args.body = body
        args.jobInstanceId = jobInstanceId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_backup_get_dict_export(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = backup_get_dict_export_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "backup_get_dict_export failed: unknown result")

    def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        """
        生产资源类型 sourceType
        服务类型     svcType
        生产资源标识 sourceId
        @ return


        Parameters:
         - sourceType
         - svcType
         - sourceId
         - relation

        """
        self.send_get_jobs_by_sourceId(sourceType, svcType, sourceId, relation)
        return self.recv_get_jobs_by_sourceId()

    def send_get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
        self._oprot.writeMessageBegin('get_jobs_by_sourceId', TMessageType.CALL, self._seqid)
        args = get_jobs_by_sourceId_args()
        args.sourceType = sourceType
        args.svcType = svcType
        args.sourceId = sourceId
        args.relation = relation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_sourceId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_sourceId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_sourceId failed: unknown result")

    def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        """
        数据源       datasource
        客户端ID     clientId
        数据源的用户名(适用于多用户场景)   dbRunUserName
        @ return


        Parameters:
         - datasource
         - clientId
         - dbRunUserName

        """
        self.send_get_jobs_by_datasource(datasource, clientId, dbRunUserName)
        return self.recv_get_jobs_by_datasource()

    def send_get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
        self._oprot.writeMessageBegin('get_jobs_by_datasource', TMessageType.CALL, self._seqid)
        args = get_jobs_by_datasource_args()
        args.datasource = datasource
        args.clientId = clientId
        args.dbRunUserName = dbRunUserName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_jobs_by_datasource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_jobs_by_datasource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_datasource failed: unknown result")

    def get_sync_job_origin_job_by_id(self, originJobId):
        """
        根据originJobId获取同步任务的信息
        @ return


        Parameters:
         - originJobId

        """
        self.send_get_sync_job_origin_job_by_id(originJobId)
        return self.recv_get_sync_job_origin_job_by_id()

    def send_get_sync_job_origin_job_by_id(self, originJobId):
        self._oprot.writeMessageBegin('get_sync_job_origin_job_by_id', TMessageType.CALL, self._seqid)
        args = get_sync_job_origin_job_by_id_args()
        args.originJobId = originJobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_sync_job_origin_job_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_sync_job_origin_job_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sync_job_origin_job_by_id failed: unknown result")

    def check_user_has_data(self, user_list):
        """
        检测用户是否存在存储数据
        @ return 返回有存储数据的用户列表


        Parameters:
         - user_list

        """
        self.send_check_user_has_data(user_list)
        return self.recv_check_user_has_data()

    def send_check_user_has_data(self, user_list):
        self._oprot.writeMessageBegin('check_user_has_data', TMessageType.CALL, self._seqid)
        args = check_user_has_data_args()
        args.user_list = user_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_user_has_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_user_has_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_user_has_data failed: unknown result")

    def resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id, login_ip):
        """
         清理CDM数据清理任务的时间点
        input:清理任务的id,清理类型,时间点,当前登陆用户
         @ return


        Parameters:
         - job_id
         - clean_type
         - time_points
         - user
         - clean_job_id
         - login_ip

        """
        self.send_resolve_clean_job_time_points(job_id, clean_type, time_points, user, clean_job_id, login_ip)
        self.recv_resolve_clean_job_time_points()

    def send_resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id, login_ip):
        self._oprot.writeMessageBegin('resolve_clean_job_time_points', TMessageType.CALL, self._seqid)
        args = resolve_clean_job_time_points_args()
        args.job_id = job_id
        args.clean_type = clean_type
        args.time_points = time_points
        args.user = user
        args.clean_job_id = clean_job_id
        args.login_ip = login_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resolve_clean_job_time_points(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resolve_clean_job_time_points_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_job_count_info(self, startTime, userId):
        """
        获取CDM备份任务数
        @ return 备份任务的数量


        Parameters:
         - startTime
         - userId

        """
        self.send_get_job_count_info(startTime, userId)
        return self.recv_get_job_count_info()

    def send_get_job_count_info(self, startTime, userId):
        self._oprot.writeMessageBegin('get_job_count_info', TMessageType.CALL, self._seqid)
        args = get_job_count_info_args()
        args.startTime = startTime
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_job_count_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_job_count_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job_count_info failed: unknown result")

    def run_backup_job_handler(self, job_instance_id, user_id):
        """
        运行备份任务转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        self.send_run_backup_job_handler(job_instance_id, user_id)
        self.recv_run_backup_job_handler()

    def send_run_backup_job_handler(self, job_instance_id, user_id):
        self._oprot.writeMessageBegin('run_backup_job_handler', TMessageType.CALL, self._seqid)
        args = run_backup_job_handler_args()
        args.job_instance_id = job_instance_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_run_backup_job_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = run_backup_job_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def run_mount_job_handler(self, job_instance_id, user_id):
        """
        运行挂载任务转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        self.send_run_mount_job_handler(job_instance_id, user_id)
        self.recv_run_mount_job_handler()

    def send_run_mount_job_handler(self, job_instance_id, user_id):
        self._oprot.writeMessageBegin('run_mount_job_handler', TMessageType.CALL, self._seqid)
        args = run_mount_job_handler_args()
        args.job_instance_id = job_instance_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_run_mount_job_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = run_mount_job_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def image_mount_handler(self, job_instance_id, user_id):
        """
        image mount操作转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        self.send_image_mount_handler(job_instance_id, user_id)
        self.recv_image_mount_handler()

    def send_image_mount_handler(self, job_instance_id, user_id):
        self._oprot.writeMessageBegin('image_mount_handler', TMessageType.CALL, self._seqid)
        args = image_mount_handler_args()
        args.job_instance_id = job_instance_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_image_mount_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = image_mount_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def image_unmount_handler(self, job_instance_id, user_id):
        """
        image unmount操作转接接口
        @ return


        Parameters:
         - job_instance_id
         - user_id

        """
        self.send_image_unmount_handler(job_instance_id, user_id)
        self.recv_image_unmount_handler()

    def send_image_unmount_handler(self, job_instance_id, user_id):
        self._oprot.writeMessageBegin('image_unmount_handler', TMessageType.CALL, self._seqid)
        args = image_unmount_handler_args()
        args.job_instance_id = job_instance_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_image_unmount_handler(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = image_unmount_handler_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_extra_resource_by_username(self, user_names):
        """
        根据用户名删除用户对应的资源
        @ return


        Parameters:
         - user_names

        """
        self.send_delete_extra_resource_by_username(user_names)
        self.recv_delete_extra_resource_by_username()

    def send_delete_extra_resource_by_username(self, user_names):
        self._oprot.writeMessageBegin('delete_extra_resource_by_username', TMessageType.CALL, self._seqid)
        args = delete_extra_resource_by_username_args()
        args.user_names = user_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_extra_resource_by_username(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_extra_resource_by_username_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_task_src_from_DB(self, job_id):
        """
        获取数据库中的任务的数据源
        @ return list<string>


        Parameters:
         - job_id

        """
        self.send_get_task_src_from_DB(job_id)
        return self.recv_get_task_src_from_DB()

    def send_get_task_src_from_DB(self, job_id):
        self._oprot.writeMessageBegin('get_task_src_from_DB', TMessageType.CALL, self._seqid)
        args = get_task_src_from_DB_args()
        args.job_id = job_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_task_src_from_DB(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_task_src_from_DB_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_task_src_from_DB failed: unknown result")

    def get_all_jobs_by_pages(self, BaseReq):
        """
        分页获取指定用户下的备份任务
        @ return list<ncJob.ncTJob>


        Parameters:
         - BaseReq

        """
        self.send_get_all_jobs_by_pages(BaseReq)
        return self.recv_get_all_jobs_by_pages()

    def send_get_all_jobs_by_pages(self, BaseReq):
        self._oprot.writeMessageBegin('get_all_jobs_by_pages', TMessageType.CALL, self._seqid)
        args = get_all_jobs_by_pages_args()
        args.BaseReq = BaseReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_jobs_by_pages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_jobs_by_pages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs_by_pages failed: unknown result")

    def get_cdmdatasource_by_client(self, client_id, job_is_backup):
        """
        获取cdm一个客户端下所有数据源
        @ return list<string>


        Parameters:
         - client_id
         - job_is_backup

        """
        self.send_get_cdmdatasource_by_client(client_id, job_is_backup)
        return self.recv_get_cdmdatasource_by_client()

    def send_get_cdmdatasource_by_client(self, client_id, job_is_backup):
        self._oprot.writeMessageBegin('get_cdmdatasource_by_client', TMessageType.CALL, self._seqid)
        args = get_cdmdatasource_by_client_args()
        args.client_id = client_id
        args.job_is_backup = job_is_backup
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cdmdatasource_by_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cdmdatasource_by_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cdmdatasource_by_client failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["microprobe"] = Processor.process_microprobe
        self._processMap["get_all_jobs"] = Processor.process_get_all_jobs
        self._processMap["get_all_mount_jobs"] = Processor.process_get_all_mount_jobs
        self._processMap["get_all_mounted_images"] = Processor.process_get_all_mounted_images
        self._processMap["get_backup_jobs_by_pool"] = Processor.process_get_backup_jobs_by_pool
        self._processMap["get_mount_jobs_by_pool"] = Processor.process_get_mount_jobs_by_pool
        self._processMap["get_residue_mount_jobs_by_pool"] = Processor.process_get_residue_mount_jobs_by_pool
        self._processMap["get_images_by_pool"] = Processor.process_get_images_by_pool
        self._processMap["get_job"] = Processor.process_get_job
        self._processMap["update_jobs_nstart_time"] = Processor.process_update_jobs_nstart_time
        self._processMap["get_jobs_like_for_schedule"] = Processor.process_get_jobs_like_for_schedule
        self._processMap["get_jobs_for_schedule_by_ids"] = Processor.process_get_jobs_for_schedule_by_ids
        self._processMap["commit_job"] = Processor.process_commit_job
        self._processMap["get_support_backup_type"] = Processor.process_get_support_backup_type
        self._processMap["get_jobs_by_instance_name"] = Processor.process_get_jobs_by_instance_name
        self._processMap["client_exsit_job"] = Processor.process_client_exsit_job
        self._processMap["get_db_job_instances"] = Processor.process_get_db_job_instances
        self._processMap["get_db_job_mappings"] = Processor.process_get_db_job_mappings
        self._processMap["ExcuteSnapshot"] = Processor.process_ExcuteSnapshot
        self._processMap["ExcuteSnapshotHw"] = Processor.process_ExcuteSnapshotHw
        self._processMap["del_exceeded_snapshot_copies"] = Processor.process_del_exceeded_snapshot_copies
        self._processMap["ExcuteSnapshot_mount"] = Processor.process_ExcuteSnapshot_mount
        self._processMap["UpdateMountPoint"] = Processor.process_UpdateMountPoint
        self._processMap["GetLunCopyStatus"] = Processor.process_GetLunCopyStatus
        self._processMap["CreateTimepoint"] = Processor.process_CreateTimepoint
        self._processMap["remove_all_jobs_by_client_ids"] = Processor.process_remove_all_jobs_by_client_ids
        self._processMap["remove_all_jobs_by_vplatform_ids"] = Processor.process_remove_all_jobs_by_vplatform_ids
        self._processMap["stop_backup_jobs_by_pool"] = Processor.process_stop_backup_jobs_by_pool
        self._processMap["getTaskCdmLuns"] = Processor.process_getTaskCdmLuns
        self._processMap["createCdmLun"] = Processor.process_createCdmLun
        self._processMap["updateCdmLunInfo"] = Processor.process_updateCdmLunInfo
        self._processMap["createVmCdmLunInfo"] = Processor.process_createVmCdmLunInfo
        self._processMap["getVmCdmLunInfo"] = Processor.process_getVmCdmLunInfo
        self._processMap["createVmwareTimePoint"] = Processor.process_createVmwareTimePoint
        self._processMap["get_all_backup_jobs_historys_for_ams"] = Processor.process_get_all_backup_jobs_historys_for_ams
        self._processMap["get_all_backup_jobs_for_ams"] = Processor.process_get_all_backup_jobs_for_ams
        self._processMap["get_all_mount_job_for_ams"] = Processor.process_get_all_mount_job_for_ams
        self._processMap["get_all_mount_jobInstance_for_ams"] = Processor.process_get_all_mount_jobInstance_for_ams
        self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
        self._processMap["do_operation_from_ams"] = Processor.process_do_operation_from_ams
        self._processMap["is_exists_running_job_on_client"] = Processor.process_is_exists_running_job_on_client
        self._processMap["is_exists_time_points_by_backup_job_id"] = Processor.process_is_exists_time_points_by_backup_job_id
        self._processMap["is_exists_base_volumes_by_backup_job_id"] = Processor.process_is_exists_base_volumes_by_backup_job_id
        self._processMap["get_origin_job_by_id"] = Processor.process_get_origin_job_by_id
        self._processMap["get_time_points_by_origin_job_id"] = Processor.process_get_time_points_by_origin_job_id
        self._processMap["create_sync_job"] = Processor.process_create_sync_job
        self._processMap["get_can_sync_jobs"] = Processor.process_get_can_sync_jobs
        self._processMap["create_sync_time_point"] = Processor.process_create_sync_time_point
        self._processMap["is_exists_origin_job_by_id"] = Processor.process_is_exists_origin_job_by_id
        self._processMap["create_sync_time_point_on_sync_start"] = Processor.process_create_sync_time_point_on_sync_start
        self._processMap["update_sync_time_point_on_sync_finish"] = Processor.process_update_sync_time_point_on_sync_finish
        self._processMap["update_sync_time_point_base_map_snap"] = Processor.process_update_sync_time_point_base_map_snap
        self._processMap["delete_sync_time_point_by_id"] = Processor.process_delete_sync_time_point_by_id
        self._processMap["update_job_status_origin_job_by_id"] = Processor.process_update_job_status_origin_job_by_id
        self._processMap["check_time_point_is_exist"] = Processor.process_check_time_point_is_exist
        self._processMap["get_dict_export"] = Processor.process_get_dict_export
        self._processMap["mount_get_dict_export"] = Processor.process_mount_get_dict_export
        self._processMap["backup_get_dict_export"] = Processor.process_backup_get_dict_export
        self._processMap["get_jobs_by_sourceId"] = Processor.process_get_jobs_by_sourceId
        self._processMap["get_jobs_by_datasource"] = Processor.process_get_jobs_by_datasource
        self._processMap["get_sync_job_origin_job_by_id"] = Processor.process_get_sync_job_origin_job_by_id
        self._processMap["check_user_has_data"] = Processor.process_check_user_has_data
        self._processMap["resolve_clean_job_time_points"] = Processor.process_resolve_clean_job_time_points
        self._processMap["get_job_count_info"] = Processor.process_get_job_count_info
        self._processMap["run_backup_job_handler"] = Processor.process_run_backup_job_handler
        self._processMap["run_mount_job_handler"] = Processor.process_run_mount_job_handler
        self._processMap["image_mount_handler"] = Processor.process_image_mount_handler
        self._processMap["image_unmount_handler"] = Processor.process_image_unmount_handler
        self._processMap["delete_extra_resource_by_username"] = Processor.process_delete_extra_resource_by_username
        self._processMap["get_task_src_from_DB"] = Processor.process_get_task_src_from_DB
        self._processMap["get_all_jobs_by_pages"] = Processor.process_get_all_jobs_by_pages
        self._processMap["get_cdmdatasource_by_client"] = Processor.process_get_cdmdatasource_by_client
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_microprobe(self, seqid, iprot, oprot):
        args = microprobe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = microprobe_result()
        try:
            self._handler.microprobe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("microprobe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_jobs(self, seqid, iprot, oprot):
        args = get_all_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_jobs_result()
        try:
            result.success = self._handler.get_all_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_mount_jobs(self, seqid, iprot, oprot):
        args = get_all_mount_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_mount_jobs_result()
        try:
            result.success = self._handler.get_all_mount_jobs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_mount_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_mounted_images(self, seqid, iprot, oprot):
        args = get_all_mounted_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_mounted_images_result()
        try:
            result.success = self._handler.get_all_mounted_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_mounted_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backup_jobs_by_pool(self, seqid, iprot, oprot):
        args = get_backup_jobs_by_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backup_jobs_by_pool_result()
        try:
            result.success = self._handler.get_backup_jobs_by_pool(args.pool_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backup_jobs_by_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_mount_jobs_by_pool(self, seqid, iprot, oprot):
        args = get_mount_jobs_by_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_mount_jobs_by_pool_result()
        try:
            result.success = self._handler.get_mount_jobs_by_pool(args.pool_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_mount_jobs_by_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_residue_mount_jobs_by_pool(self, seqid, iprot, oprot):
        args = get_residue_mount_jobs_by_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_residue_mount_jobs_by_pool_result()
        try:
            result.success = self._handler.get_residue_mount_jobs_by_pool(args.pool_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_residue_mount_jobs_by_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_images_by_pool(self, seqid, iprot, oprot):
        args = get_images_by_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_images_by_pool_result()
        try:
            result.success = self._handler.get_images_by_pool(args.pool_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_images_by_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_job(self, seqid, iprot, oprot):
        args = get_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_job_result()
        try:
            result.success = self._handler.get_job(args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_jobs_nstart_time(self, seqid, iprot, oprot):
        args = update_jobs_nstart_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_jobs_nstart_time_result()
        try:
            self._handler.update_jobs_nstart_time(args.jobs_params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_jobs_nstart_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_like_for_schedule(self, seqid, iprot, oprot):
        args = get_jobs_like_for_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_like_for_schedule_result()
        try:
            result.success = self._handler.get_jobs_like_for_schedule(args.jobName, args.clientIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_like_for_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_for_schedule_by_ids(self, seqid, iprot, oprot):
        args = get_jobs_for_schedule_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_for_schedule_by_ids_result()
        try:
            result.success = self._handler.get_jobs_for_schedule_by_ids(args.jobIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_for_schedule_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_job(self, seqid, iprot, oprot):
        args = commit_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_job_result()
        try:
            self._handler.commit_job(args.jobId, args.customer, args.backupType, args.desc, args.is_auto_execute, args.nstart_time, args.strategy_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_support_backup_type(self, seqid, iprot, oprot):
        args = get_support_backup_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_support_backup_type_result()
        try:
            result.success = self._handler.get_support_backup_type(args.job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_support_backup_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_instance_name(self, seqid, iprot, oprot):
        args = get_jobs_by_instance_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_instance_name_result()
        try:
            result.success = self._handler.get_jobs_by_instance_name(args.instance_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_instance_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_exsit_job(self, seqid, iprot, oprot):
        args = client_exsit_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_exsit_job_result()
        try:
            result.success = self._handler.client_exsit_job(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_exsit_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_job_instances(self, seqid, iprot, oprot):
        args = get_db_job_instances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_job_instances_result()
        try:
            result.success = self._handler.get_db_job_instances(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_job_instances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_job_mappings(self, seqid, iprot, oprot):
        args = get_db_job_mappings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_job_mappings_result()
        try:
            result.success = self._handler.get_db_job_mappings(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_job_mappings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExcuteSnapshot(self, seqid, iprot, oprot):
        args = ExcuteSnapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExcuteSnapshot_result()
        try:
            self._handler.ExcuteSnapshot(args.lunUuids, args.copiesNum, args.timePoint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExcuteSnapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExcuteSnapshotHw(self, seqid, iprot, oprot):
        args = ExcuteSnapshotHw_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExcuteSnapshotHw_result()
        try:
            self._handler.ExcuteSnapshotHw(args.lunUuids, args.copiesNum, args.timePoint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExcuteSnapshotHw", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_exceeded_snapshot_copies(self, seqid, iprot, oprot):
        args = del_exceeded_snapshot_copies_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_exceeded_snapshot_copies_result()
        try:
            result.success = self._handler.del_exceeded_snapshot_copies(args.lunUuids, args.copiesNum)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_exceeded_snapshot_copies", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExcuteSnapshot_mount(self, seqid, iprot, oprot):
        args = ExcuteSnapshot_mount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExcuteSnapshot_mount_result()
        try:
            result.success = self._handler.ExcuteSnapshot_mount(args.lunUuids, args.backupType, args.jobCid, args.protocol)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExcuteSnapshot_mount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_UpdateMountPoint(self, seqid, iprot, oprot):
        args = UpdateMountPoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = UpdateMountPoint_result()
        try:
            self._handler.UpdateMountPoint(args.clientMac, args.connector, args.snapshotName, args.drivername)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("UpdateMountPoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLunCopyStatus(self, seqid, iprot, oprot):
        args = GetLunCopyStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLunCopyStatus_result()
        try:
            result.success = self._handler.GetLunCopyStatus(args.volId, args.lunCopyId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLunCopyStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateTimepoint(self, seqid, iprot, oprot):
        args = CreateTimepoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateTimepoint_result()
        try:
            self._handler.CreateTimepoint(args.lunUuids, args.timePoint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateTimepoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_client_ids(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_client_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_client_ids_result()
        try:
            result.success = self._handler.remove_all_jobs_by_client_ids(args.clientIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_client_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_jobs_by_vplatform_ids(self, seqid, iprot, oprot):
        args = remove_all_jobs_by_vplatform_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_jobs_by_vplatform_ids_result()
        try:
            result.success = self._handler.remove_all_jobs_by_vplatform_ids(args.vplatformIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_jobs_by_vplatform_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_backup_jobs_by_pool(self, seqid, iprot, oprot):
        args = stop_backup_jobs_by_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_backup_jobs_by_pool_result()
        try:
            self._handler.stop_backup_jobs_by_pool(args.pool_id, args.pool_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_backup_jobs_by_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getTaskCdmLuns(self, seqid, iprot, oprot):
        args = getTaskCdmLuns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getTaskCdmLuns_result()
        try:
            result.success = self._handler.getTaskCdmLuns(args.jobid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getTaskCdmLuns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createCdmLun(self, seqid, iprot, oprot):
        args = createCdmLun_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createCdmLun_result()
        try:
            result.success = self._handler.createCdmLun(args.size, args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createCdmLun", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateCdmLunInfo(self, seqid, iprot, oprot):
        args = updateCdmLunInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateCdmLunInfo_result()
        try:
            self._handler.updateCdmLunInfo(args.cdmLuns, args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateCdmLunInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createVmCdmLunInfo(self, seqid, iprot, oprot):
        args = createVmCdmLunInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createVmCdmLunInfo_result()
        try:
            self._handler.createVmCdmLunInfo(args.vmVolumes, args.job_id, args.timepoint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createVmCdmLunInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getVmCdmLunInfo(self, seqid, iprot, oprot):
        args = getVmCdmLunInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getVmCdmLunInfo_result()
        try:
            result.success = self._handler.getVmCdmLunInfo(args.job_id, args.vmuuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getVmCdmLunInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createVmwareTimePoint(self, seqid, iprot, oprot):
        args = createVmwareTimePoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createVmwareTimePoint_result()
        try:
            self._handler.createVmwareTimePoint(args.vminfos, args.timepoint, args.job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createVmwareTimePoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_backup_jobs_historys_for_ams(self, seqid, iprot, oprot):
        args = get_all_backup_jobs_historys_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_backup_jobs_historys_for_ams_result()
        try:
            result.success = self._handler.get_all_backup_jobs_historys_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_backup_jobs_historys_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_backup_jobs_for_ams(self, seqid, iprot, oprot):
        args = get_all_backup_jobs_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_backup_jobs_for_ams_result()
        try:
            result.success = self._handler.get_all_backup_jobs_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_backup_jobs_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_mount_job_for_ams(self, seqid, iprot, oprot):
        args = get_all_mount_job_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_mount_job_for_ams_result()
        try:
            result.success = self._handler.get_all_mount_job_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_mount_job_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_mount_jobInstance_for_ams(self, seqid, iprot, oprot):
        args = get_all_mount_jobInstance_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_mount_jobInstance_for_ams_result()
        try:
            result.success = self._handler.get_all_mount_jobInstance_for_ams()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_mount_jobInstance_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_for_ams(self, seqid, iprot, oprot):
        args = get_data_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_for_ams_result()
        try:
            result.success = self._handler.get_data_for_ams(args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_do_operation_from_ams(self, seqid, iprot, oprot):
        args = do_operation_from_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = do_operation_from_ams_result()
        try:
            result.success = self._handler.do_operation_from_ams(args.target, args.method, args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("do_operation_from_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_exists_running_job_on_client(self, seqid, iprot, oprot):
        args = is_exists_running_job_on_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_exists_running_job_on_client_result()
        try:
            result.success = self._handler.is_exists_running_job_on_client(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_exists_running_job_on_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_exists_time_points_by_backup_job_id(self, seqid, iprot, oprot):
        args = is_exists_time_points_by_backup_job_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_exists_time_points_by_backup_job_id_result()
        try:
            result.success = self._handler.is_exists_time_points_by_backup_job_id(args.backup_job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_exists_time_points_by_backup_job_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_exists_base_volumes_by_backup_job_id(self, seqid, iprot, oprot):
        args = is_exists_base_volumes_by_backup_job_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_exists_base_volumes_by_backup_job_id_result()
        try:
            result.success = self._handler.is_exists_base_volumes_by_backup_job_id(args.backup_job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_exists_base_volumes_by_backup_job_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_origin_job_by_id(self, seqid, iprot, oprot):
        args = get_origin_job_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_origin_job_by_id_result()
        try:
            result.success = self._handler.get_origin_job_by_id(args.originJobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_origin_job_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_time_points_by_origin_job_id(self, seqid, iprot, oprot):
        args = get_time_points_by_origin_job_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_time_points_by_origin_job_id_result()
        try:
            result.success = self._handler.get_time_points_by_origin_job_id(args.TimePointReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_time_points_by_origin_job_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_sync_job(self, seqid, iprot, oprot):
        args = create_sync_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_sync_job_result()
        try:
            self._handler.create_sync_job(args.createSyncJobReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_sync_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_can_sync_jobs(self, seqid, iprot, oprot):
        args = get_can_sync_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_can_sync_jobs_result()
        try:
            result.success = self._handler.get_can_sync_jobs(args.canSyncJobReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_can_sync_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_sync_time_point(self, seqid, iprot, oprot):
        args = create_sync_time_point_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_sync_time_point_result()
        try:
            self._handler.create_sync_time_point(args.createSyncTimePointReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_sync_time_point", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_exists_origin_job_by_id(self, seqid, iprot, oprot):
        args = is_exists_origin_job_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_exists_origin_job_by_id_result()
        try:
            result.success = self._handler.is_exists_origin_job_by_id(args.originJobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("is_exists_origin_job_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_sync_time_point_on_sync_start(self, seqid, iprot, oprot):
        args = create_sync_time_point_on_sync_start_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_sync_time_point_on_sync_start_result()
        try:
            result.success = self._handler.create_sync_time_point_on_sync_start(args.createSyncTimePointReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_sync_time_point_on_sync_start", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_sync_time_point_on_sync_finish(self, seqid, iprot, oprot):
        args = update_sync_time_point_on_sync_finish_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_sync_time_point_on_sync_finish_result()
        try:
            self._handler.update_sync_time_point_on_sync_finish(args.updateSyncTimePointReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_sync_time_point_on_sync_finish", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_sync_time_point_base_map_snap(self, seqid, iprot, oprot):
        args = update_sync_time_point_base_map_snap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_sync_time_point_base_map_snap_result()
        try:
            self._handler.update_sync_time_point_base_map_snap(args.updateSyncTimePointVolumeReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_sync_time_point_base_map_snap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_sync_time_point_by_id(self, seqid, iprot, oprot):
        args = delete_sync_time_point_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_sync_time_point_by_id_result()
        try:
            result.success = self._handler.delete_sync_time_point_by_id(args.deleteSyncTimePointIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_sync_time_point_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_job_status_origin_job_by_id(self, seqid, iprot, oprot):
        args = update_job_status_origin_job_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_job_status_origin_job_by_id_result()
        try:
            self._handler.update_job_status_origin_job_by_id(args.UpdateJobStatusReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_job_status_origin_job_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_time_point_is_exist(self, seqid, iprot, oprot):
        args = check_time_point_is_exist_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_time_point_is_exist_result()
        try:
            result.success = self._handler.check_time_point_is_exist(args.timePointId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_time_point_is_exist", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dict_export(self, seqid, iprot, oprot):
        args = get_dict_export_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dict_export_result()
        try:
            result.success = self._handler.get_dict_export(args.body, args.jobInstanceId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dict_export", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mount_get_dict_export(self, seqid, iprot, oprot):
        args = mount_get_dict_export_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mount_get_dict_export_result()
        try:
            result.success = self._handler.mount_get_dict_export(args.body, args.jobInstanceId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mount_get_dict_export", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_backup_get_dict_export(self, seqid, iprot, oprot):
        args = backup_get_dict_export_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = backup_get_dict_export_result()
        try:
            result.success = self._handler.backup_get_dict_export(args.body, args.jobInstanceId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("backup_get_dict_export", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_sourceId(self, seqid, iprot, oprot):
        args = get_jobs_by_sourceId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_sourceId_result()
        try:
            result.success = self._handler.get_jobs_by_sourceId(args.sourceType, args.svcType, args.sourceId, args.relation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_sourceId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_jobs_by_datasource(self, seqid, iprot, oprot):
        args = get_jobs_by_datasource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_jobs_by_datasource_result()
        try:
            result.success = self._handler.get_jobs_by_datasource(args.datasource, args.clientId, args.dbRunUserName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_jobs_by_datasource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_sync_job_origin_job_by_id(self, seqid, iprot, oprot):
        args = get_sync_job_origin_job_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_sync_job_origin_job_by_id_result()
        try:
            result.success = self._handler.get_sync_job_origin_job_by_id(args.originJobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_sync_job_origin_job_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_user_has_data(self, seqid, iprot, oprot):
        args = check_user_has_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_user_has_data_result()
        try:
            result.success = self._handler.check_user_has_data(args.user_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_user_has_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resolve_clean_job_time_points(self, seqid, iprot, oprot):
        args = resolve_clean_job_time_points_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resolve_clean_job_time_points_result()
        try:
            self._handler.resolve_clean_job_time_points(args.job_id, args.clean_type, args.time_points, args.user, args.clean_job_id, args.login_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resolve_clean_job_time_points", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_job_count_info(self, seqid, iprot, oprot):
        args = get_job_count_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_job_count_info_result()
        try:
            result.success = self._handler.get_job_count_info(args.startTime, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_job_count_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_run_backup_job_handler(self, seqid, iprot, oprot):
        args = run_backup_job_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = run_backup_job_handler_result()
        try:
            self._handler.run_backup_job_handler(args.job_instance_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("run_backup_job_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_run_mount_job_handler(self, seqid, iprot, oprot):
        args = run_mount_job_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = run_mount_job_handler_result()
        try:
            self._handler.run_mount_job_handler(args.job_instance_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("run_mount_job_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_image_mount_handler(self, seqid, iprot, oprot):
        args = image_mount_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = image_mount_handler_result()
        try:
            self._handler.image_mount_handler(args.job_instance_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("image_mount_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_image_unmount_handler(self, seqid, iprot, oprot):
        args = image_unmount_handler_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = image_unmount_handler_result()
        try:
            self._handler.image_unmount_handler(args.job_instance_id, args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("image_unmount_handler", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_extra_resource_by_username(self, seqid, iprot, oprot):
        args = delete_extra_resource_by_username_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_extra_resource_by_username_result()
        try:
            self._handler.delete_extra_resource_by_username(args.user_names)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_extra_resource_by_username", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_task_src_from_DB(self, seqid, iprot, oprot):
        args = get_task_src_from_DB_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_task_src_from_DB_result()
        try:
            result.success = self._handler.get_task_src_from_DB(args.job_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_task_src_from_DB", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_jobs_by_pages(self, seqid, iprot, oprot):
        args = get_all_jobs_by_pages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_jobs_by_pages_result()
        try:
            result.success = self._handler.get_all_jobs_by_pages(args.BaseReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_jobs_by_pages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cdmdatasource_by_client(self, seqid, iprot, oprot):
        args = get_cdmdatasource_by_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cdmdatasource_by_client_result()
        try:
            result.success = self._handler.get_cdmdatasource_by_client(args.client_id, args.job_is_backup)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cdmdatasource_by_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class microprobe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_args)
microprobe_args.thrift_spec = (
)


class microprobe_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_result)
microprobe_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_args)
get_all_jobs_args.thrift_spec = (
)


class get_all_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = ncJob.ttypes.ncTJob()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_result)
get_all_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_mount_jobs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_jobs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_jobs_args)
get_all_mount_jobs_args.thrift_spec = (
)


class get_all_mount_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ncJob.ttypes.ncTJob()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_jobs_result)
get_all_mount_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_mounted_images_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mounted_images_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mounted_images_args)
get_all_mounted_images_args.thrift_spec = (
)


class get_all_mounted_images_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = ncJob.ttypes.ncTJob()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mounted_images_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mounted_images_result)
get_all_mounted_images_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_backup_jobs_by_pool_args(object):
    """
    Attributes:
     - pool_id

    """


    def __init__(self, pool_id=None,):
        self.pool_id = pool_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_pool_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_pool_args)
get_backup_jobs_by_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
)


class get_backup_jobs_by_pool_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ncJob.ttypes.ncTJob()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_jobs_by_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_jobs_by_pool_result)
get_backup_jobs_by_pool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_mount_jobs_by_pool_args(object):
    """
    Attributes:
     - pool_id

    """


    def __init__(self, pool_id=None,):
        self.pool_id = pool_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_mount_jobs_by_pool_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_mount_jobs_by_pool_args)
get_mount_jobs_by_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
)


class get_mount_jobs_by_pool_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = ncJob.ttypes.ncTJob()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_mount_jobs_by_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_mount_jobs_by_pool_result)
get_mount_jobs_by_pool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_residue_mount_jobs_by_pool_args(object):
    """
    Attributes:
     - pool_id

    """


    def __init__(self, pool_id=None,):
        self.pool_id = pool_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_residue_mount_jobs_by_pool_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_residue_mount_jobs_by_pool_args)
get_residue_mount_jobs_by_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
)


class get_residue_mount_jobs_by_pool_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = ncJob.ttypes.ncTJob()
                        _elem40.read(iprot)
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_residue_mount_jobs_by_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter41 in self.success:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_residue_mount_jobs_by_pool_result)
get_residue_mount_jobs_by_pool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_images_by_pool_args(object):
    """
    Attributes:
     - pool_id

    """


    def __init__(self, pool_id=None,):
        self.pool_id = pool_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_by_pool_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_by_pool_args)
get_images_by_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
)


class get_images_by_pool_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = ncCdmDispatchProto.ttypes.ncImage()
                        _elem47.read(iprot)
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_images_by_pool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter48 in self.success:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_images_by_pool_result)
get_images_by_pool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncImage, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_job_args(object):
    """
    Attributes:
     - jobId

    """


    def __init__(self, jobId=None,):
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_args)
get_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
)


class get_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncJob.ttypes.ncTJob()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_result)
get_job_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncJob.ttypes.ncTJob, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_jobs_nstart_time_args(object):
    """
    Attributes:
     - jobs_params

    """


    def __init__(self, jobs_params=None,):
        self.jobs_params = jobs_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.jobs_params = {}
                    (_ktype50, _vtype51, _size49) = iprot.readMapBegin()
                    for _i53 in range(_size49):
                        _key54 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val55 = iprot.readI64()
                        self.jobs_params[_key54] = _val55
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_jobs_nstart_time_args')
        if self.jobs_params is not None:
            oprot.writeFieldBegin('jobs_params', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.jobs_params))
            for kiter56, viter57 in self.jobs_params.items():
                oprot.writeString(kiter56.encode('utf-8') if sys.version_info[0] == 2 else kiter56)
                oprot.writeI64(viter57)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jobs_params is None:
            raise TProtocolException(message='Required field jobs_params is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_jobs_nstart_time_args)
update_jobs_nstart_time_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'jobs_params', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 1
)


class update_jobs_nstart_time_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_jobs_nstart_time_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_jobs_nstart_time_result)
update_jobs_nstart_time_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_like_for_schedule_args(object):
    """
    Attributes:
     - jobName
     - clientIds

    """


    def __init__(self, jobName=None, clientIds=None,):
        self.jobName = jobName
        self.clientIds = clientIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.clientIds = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.clientIds.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_like_for_schedule_args')
        if self.jobName is not None:
            oprot.writeFieldBegin('jobName', TType.STRING, 1)
            oprot.writeString(self.jobName.encode('utf-8') if sys.version_info[0] == 2 else self.jobName)
            oprot.writeFieldEnd()
        if self.clientIds is not None:
            oprot.writeFieldBegin('clientIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.clientIds))
            for iter64 in self.clientIds:
                oprot.writeString(iter64.encode('utf-8') if sys.version_info[0] == 2 else iter64)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_like_for_schedule_args)
get_jobs_like_for_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'clientIds', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class get_jobs_like_for_schedule_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = ncJob.ttypes.ncTJob()
                        _elem70.read(iprot)
                        self.success.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_like_for_schedule_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter71 in self.success:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_like_for_schedule_result)
get_jobs_like_for_schedule_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_for_schedule_by_ids_args(object):
    """
    Attributes:
     - jobIds

    """


    def __init__(self, jobIds=None,):
        self.jobIds = jobIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobIds = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobIds.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_for_schedule_by_ids_args')
        if self.jobIds is not None:
            oprot.writeFieldBegin('jobIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jobIds))
            for iter78 in self.jobIds:
                oprot.writeString(iter78.encode('utf-8') if sys.version_info[0] == 2 else iter78)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_for_schedule_by_ids_args)
get_jobs_for_schedule_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_jobs_for_schedule_by_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = ncJob.ttypes.ncTJob()
                        _elem84.read(iprot)
                        self.success.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_for_schedule_by_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter85 in self.success:
                iter85.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_for_schedule_by_ids_result)
get_jobs_for_schedule_by_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class commit_job_args(object):
    """
    Attributes:
     - jobId
     - customer
     - backupType
     - desc
     - is_auto_execute
     - nstart_time
     - strategy_id

    """


    def __init__(self, jobId=None, customer=None, backupType=None, desc=None, is_auto_execute=None, nstart_time=None, strategy_id=None,):
        self.jobId = jobId
        self.customer = customer
        self.backupType = backupType
        self.desc = desc
        self.is_auto_execute = is_auto_execute
        self.nstart_time = nstart_time
        self.strategy_id = strategy_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.customer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.backupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.desc = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_auto_execute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.nstart_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.strategy_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.customer is not None:
            oprot.writeFieldBegin('customer', TType.STRING, 2)
            oprot.writeString(self.customer.encode('utf-8') if sys.version_info[0] == 2 else self.customer)
            oprot.writeFieldEnd()
        if self.backupType is not None:
            oprot.writeFieldBegin('backupType', TType.I32, 3)
            oprot.writeI32(self.backupType)
            oprot.writeFieldEnd()
        if self.desc is not None:
            oprot.writeFieldBegin('desc', TType.STRING, 4)
            oprot.writeString(self.desc.encode('utf-8') if sys.version_info[0] == 2 else self.desc)
            oprot.writeFieldEnd()
        if self.is_auto_execute is not None:
            oprot.writeFieldBegin('is_auto_execute', TType.BOOL, 5)
            oprot.writeBool(self.is_auto_execute)
            oprot.writeFieldEnd()
        if self.nstart_time is not None:
            oprot.writeFieldBegin('nstart_time', TType.I64, 6)
            oprot.writeI64(self.nstart_time)
            oprot.writeFieldEnd()
        if self.strategy_id is not None:
            oprot.writeFieldBegin('strategy_id', TType.STRING, 7)
            oprot.writeString(self.strategy_id.encode('utf-8') if sys.version_info[0] == 2 else self.strategy_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_args)
commit_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'customer', 'UTF8', None, ),  # 2
    (3, TType.I32, 'backupType', None, None, ),  # 3
    (4, TType.STRING, 'desc', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'is_auto_execute', None, None, ),  # 5
    (6, TType.I64, 'nstart_time', None, None, ),  # 6
    (7, TType.STRING, 'strategy_id', 'UTF8', None, ),  # 7
)


class commit_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_result)
commit_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_support_backup_type_args(object):
    """
    Attributes:
     - job_id

    """


    def __init__(self, job_id=None,):
        self.job_id = job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_support_backup_type_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_support_backup_type_args)
get_support_backup_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
)


class get_support_backup_type_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = iprot.readI32()
                        self.success.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_support_backup_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter92 in self.success:
                oprot.writeI32(iter92)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_support_backup_type_result)
get_support_backup_type_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_instance_name_args(object):
    """
    Attributes:
     - instance_name

    """


    def __init__(self, instance_name=None,):
        self.instance_name = instance_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instance_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_instance_name_args')
        if self.instance_name is not None:
            oprot.writeFieldBegin('instance_name', TType.STRING, 1)
            oprot.writeString(self.instance_name.encode('utf-8') if sys.version_info[0] == 2 else self.instance_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_instance_name_args)
get_jobs_by_instance_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'instance_name', 'UTF8', None, ),  # 1
)


class get_jobs_by_instance_name_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = ncJob.ttypes.ncDBJobInstance()
                        _elem98.read(iprot)
                        self.success.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_instance_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter99 in self.success:
                iter99.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_instance_name_result)
get_jobs_by_instance_name_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class client_exsit_job_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_job_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_job_args)
client_exsit_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class client_exsit_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_exsit_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_exsit_job_result)
client_exsit_job_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_job_instances_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncDBJobInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_instances_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_instances_args)
get_db_job_instances_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncDBJobInstanceRequest, None], None, ),  # 1
)


class get_db_job_instances_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = ncJob.ttypes.ncDBJobInstance()
                        _elem105.read(iprot)
                        self.success.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_instances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter106 in self.success:
                iter106.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_instances_result)
get_db_job_instances_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_job_mappings_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncJob.ttypes.ncDBJobInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_mappings_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_mappings_args)
get_db_job_mappings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncJob.ttypes.ncDBJobInstanceRequest, None], None, ),  # 1
)


class get_db_job_mappings_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = ncJob.ttypes.ncDBJobInstance()
                        _elem112.read(iprot)
                        self.success.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_job_mappings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter113 in self.success:
                iter113.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_job_mappings_result)
get_db_job_mappings_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncDBJobInstance, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class ExcuteSnapshot_args(object):
    """
    Attributes:
     - lunUuids
     - copiesNum
     - timePoint

    """


    def __init__(self, lunUuids=None, copiesNum=None, timePoint=None,):
        self.lunUuids = lunUuids
        self.copiesNum = copiesNum
        self.timePoint = timePoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lunUuids = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lunUuids.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.copiesNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timePoint = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshot_args')
        if self.lunUuids is not None:
            oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lunUuids))
            for iter120 in self.lunUuids:
                oprot.writeString(iter120.encode('utf-8') if sys.version_info[0] == 2 else iter120)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.copiesNum is not None:
            oprot.writeFieldBegin('copiesNum', TType.I32, 2)
            oprot.writeI32(self.copiesNum)
            oprot.writeFieldEnd()
        if self.timePoint is not None:
            oprot.writeFieldBegin('timePoint', TType.I64, 3)
            oprot.writeI64(self.timePoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshot_args)
ExcuteSnapshot_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'copiesNum', None, None, ),  # 2
    (3, TType.I64, 'timePoint', None, None, ),  # 3
)


class ExcuteSnapshot_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshot_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshot_result)
ExcuteSnapshot_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class ExcuteSnapshotHw_args(object):
    """
    Attributes:
     - lunUuids
     - copiesNum
     - timePoint

    """


    def __init__(self, lunUuids=None, copiesNum=None, timePoint=None,):
        self.lunUuids = lunUuids
        self.copiesNum = copiesNum
        self.timePoint = timePoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lunUuids = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lunUuids.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.copiesNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timePoint = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshotHw_args')
        if self.lunUuids is not None:
            oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lunUuids))
            for iter127 in self.lunUuids:
                oprot.writeString(iter127.encode('utf-8') if sys.version_info[0] == 2 else iter127)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.copiesNum is not None:
            oprot.writeFieldBegin('copiesNum', TType.I32, 2)
            oprot.writeI32(self.copiesNum)
            oprot.writeFieldEnd()
        if self.timePoint is not None:
            oprot.writeFieldBegin('timePoint', TType.I64, 3)
            oprot.writeI64(self.timePoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshotHw_args)
ExcuteSnapshotHw_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'copiesNum', None, None, ),  # 2
    (3, TType.I64, 'timePoint', None, None, ),  # 3
)


class ExcuteSnapshotHw_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshotHw_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshotHw_result)
ExcuteSnapshotHw_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class del_exceeded_snapshot_copies_args(object):
    """
    Attributes:
     - lunUuids
     - copiesNum

    """


    def __init__(self, lunUuids=None, copiesNum=None,):
        self.lunUuids = lunUuids
        self.copiesNum = copiesNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lunUuids = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lunUuids.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.copiesNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_exceeded_snapshot_copies_args')
        if self.lunUuids is not None:
            oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lunUuids))
            for iter134 in self.lunUuids:
                oprot.writeString(iter134.encode('utf-8') if sys.version_info[0] == 2 else iter134)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.copiesNum is not None:
            oprot.writeFieldBegin('copiesNum', TType.I32, 2)
            oprot.writeI32(self.copiesNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_exceeded_snapshot_copies_args)
del_exceeded_snapshot_copies_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'copiesNum', None, None, ),  # 2
)


class del_exceeded_snapshot_copies_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_exceeded_snapshot_copies_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_exceeded_snapshot_copies_result)
del_exceeded_snapshot_copies_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class ExcuteSnapshot_mount_args(object):
    """
    Attributes:
     - lunUuids
     - backupType
     - jobCid
     - protocol

    """


    def __init__(self, lunUuids=None, backupType=None, jobCid=None, protocol=None,):
        self.lunUuids = lunUuids
        self.backupType = backupType
        self.jobCid = jobCid
        self.protocol = protocol

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lunUuids = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lunUuids.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.backupType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.jobCid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.protocol = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshot_mount_args')
        if self.lunUuids is not None:
            oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lunUuids))
            for iter141 in self.lunUuids:
                oprot.writeString(iter141.encode('utf-8') if sys.version_info[0] == 2 else iter141)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.backupType is not None:
            oprot.writeFieldBegin('backupType', TType.I32, 2)
            oprot.writeI32(self.backupType)
            oprot.writeFieldEnd()
        if self.jobCid is not None:
            oprot.writeFieldBegin('jobCid', TType.STRING, 3)
            oprot.writeString(self.jobCid.encode('utf-8') if sys.version_info[0] == 2 else self.jobCid)
            oprot.writeFieldEnd()
        if self.protocol is not None:
            oprot.writeFieldBegin('protocol', TType.I32, 4)
            oprot.writeI32(self.protocol)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshot_mount_args)
ExcuteSnapshot_mount_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'backupType', None, None, ),  # 2
    (3, TType.STRING, 'jobCid', 'UTF8', None, ),  # 3
    (4, TType.I32, 'protocol', None, None, ),  # 4
)


class ExcuteSnapshot_mount_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExcuteSnapshot_mount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExcuteSnapshot_mount_result)
ExcuteSnapshot_mount_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class UpdateMountPoint_args(object):
    """
    Attributes:
     - clientMac
     - connector
     - snapshotName
     - drivername

    """


    def __init__(self, clientMac=None, connector=None, snapshotName=None, drivername=None,):
        self.clientMac = clientMac
        self.connector = connector
        self.snapshotName = snapshotName
        self.drivername = drivername

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientMac = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.connector = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.snapshotName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.drivername = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateMountPoint_args')
        if self.clientMac is not None:
            oprot.writeFieldBegin('clientMac', TType.STRING, 1)
            oprot.writeString(self.clientMac.encode('utf-8') if sys.version_info[0] == 2 else self.clientMac)
            oprot.writeFieldEnd()
        if self.connector is not None:
            oprot.writeFieldBegin('connector', TType.STRING, 2)
            oprot.writeString(self.connector.encode('utf-8') if sys.version_info[0] == 2 else self.connector)
            oprot.writeFieldEnd()
        if self.snapshotName is not None:
            oprot.writeFieldBegin('snapshotName', TType.STRING, 3)
            oprot.writeString(self.snapshotName.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotName)
            oprot.writeFieldEnd()
        if self.drivername is not None:
            oprot.writeFieldBegin('drivername', TType.STRING, 4)
            oprot.writeString(self.drivername.encode('utf-8') if sys.version_info[0] == 2 else self.drivername)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateMountPoint_args)
UpdateMountPoint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientMac', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'connector', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'snapshotName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'drivername', 'UTF8', None, ),  # 4
)


class UpdateMountPoint_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateMountPoint_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateMountPoint_result)
UpdateMountPoint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class GetLunCopyStatus_args(object):
    """
    Attributes:
     - volId
     - lunCopyId

    """


    def __init__(self, volId=None, lunCopyId=None,):
        self.volId = volId
        self.lunCopyId = lunCopyId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.lunCopyId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLunCopyStatus_args')
        if self.volId is not None:
            oprot.writeFieldBegin('volId', TType.STRING, 1)
            oprot.writeString(self.volId.encode('utf-8') if sys.version_info[0] == 2 else self.volId)
            oprot.writeFieldEnd()
        if self.lunCopyId is not None:
            oprot.writeFieldBegin('lunCopyId', TType.STRING, 2)
            oprot.writeString(self.lunCopyId.encode('utf-8') if sys.version_info[0] == 2 else self.lunCopyId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLunCopyStatus_args)
GetLunCopyStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'volId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'lunCopyId', 'UTF8', None, ),  # 2
)


class GetLunCopyStatus_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLunCopyStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLunCopyStatus_result)
GetLunCopyStatus_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CreateTimepoint_args(object):
    """
    Attributes:
     - lunUuids
     - timePoint

    """


    def __init__(self, lunUuids=None, timePoint=None,):
        self.lunUuids = lunUuids
        self.timePoint = timePoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lunUuids = []
                    (_etype145, _size142) = iprot.readListBegin()
                    for _i146 in range(_size142):
                        _elem147 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lunUuids.append(_elem147)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timePoint = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateTimepoint_args')
        if self.lunUuids is not None:
            oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.lunUuids))
            for iter148 in self.lunUuids:
                oprot.writeString(iter148.encode('utf-8') if sys.version_info[0] == 2 else iter148)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timePoint is not None:
            oprot.writeFieldBegin('timePoint', TType.I64, 2)
            oprot.writeI64(self.timePoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateTimepoint_args)
CreateTimepoint_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I64, 'timePoint', None, None, ),  # 2
)


class CreateTimepoint_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateTimepoint_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateTimepoint_result)
CreateTimepoint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_client_ids_args(object):
    """
    Attributes:
     - clientIds

    """


    def __init__(self, clientIds=None,):
        self.clientIds = clientIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.clientIds = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.clientIds.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_client_ids_args')
        if self.clientIds is not None:
            oprot.writeFieldBegin('clientIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.clientIds))
            for iter155 in self.clientIds:
                oprot.writeString(iter155.encode('utf-8') if sys.version_info[0] == 2 else iter155)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_client_ids_args)
remove_all_jobs_by_client_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'clientIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_all_jobs_by_client_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_client_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_client_ids_result)
remove_all_jobs_by_client_ids_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_jobs_by_vplatform_ids_args(object):
    """
    Attributes:
     - vplatformIds

    """


    def __init__(self, vplatformIds=None,):
        self.vplatformIds = vplatformIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vplatformIds = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vplatformIds.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_args')
        if self.vplatformIds is not None:
            oprot.writeFieldBegin('vplatformIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.vplatformIds))
            for iter162 in self.vplatformIds:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_vplatform_ids_args)
remove_all_jobs_by_vplatform_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vplatformIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_all_jobs_by_vplatform_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCommonType.ttypes.ncTwoStringList()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_jobs_by_vplatform_ids_result)
remove_all_jobs_by_vplatform_ids_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCommonType.ttypes.ncTwoStringList, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class stop_backup_jobs_by_pool_args(object):
    """
    Attributes:
     - pool_id
     - pool_name

    """


    def __init__(self, pool_id=None, pool_name=None,):
        self.pool_id = pool_id
        self.pool_name = pool_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pool_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_backup_jobs_by_pool_args')
        if self.pool_id is not None:
            oprot.writeFieldBegin('pool_id', TType.STRING, 1)
            oprot.writeString(self.pool_id.encode('utf-8') if sys.version_info[0] == 2 else self.pool_id)
            oprot.writeFieldEnd()
        if self.pool_name is not None:
            oprot.writeFieldBegin('pool_name', TType.STRING, 2)
            oprot.writeString(self.pool_name.encode('utf-8') if sys.version_info[0] == 2 else self.pool_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_backup_jobs_by_pool_args)
stop_backup_jobs_by_pool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'pool_name', 'UTF8', None, ),  # 2
)


class stop_backup_jobs_by_pool_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_backup_jobs_by_pool_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_backup_jobs_by_pool_result)
stop_backup_jobs_by_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class getTaskCdmLuns_args(object):
    """
    Attributes:
     - jobid

    """


    def __init__(self, jobid=None,):
        self.jobid = jobid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaskCdmLuns_args')
        if self.jobid is not None:
            oprot.writeFieldBegin('jobid', TType.STRING, 1)
            oprot.writeString(self.jobid.encode('utf-8') if sys.version_info[0] == 2 else self.jobid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaskCdmLuns_args)
getTaskCdmLuns_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobid', 'UTF8', None, ),  # 1
)


class getTaskCdmLuns_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype166, _size163) = iprot.readListBegin()
                    for _i167 in range(_size163):
                        _elem168 = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
                        _elem168.read(iprot)
                        self.success.append(_elem168)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getTaskCdmLuns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter169 in self.success:
                iter169.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getTaskCdmLuns_result)
getTaskCdmLuns_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class createCdmLun_args(object):
    """
    Attributes:
     - size
     - jobId

    """


    def __init__(self, size=None, jobId=None,):
        self.size = size
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCdmLun_args')
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I64, 1)
            oprot.writeI64(self.size)
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 2)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCdmLun_args)
createCdmLun_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'size', None, None, ),  # 1
    (2, TType.STRING, 'jobId', 'UTF8', None, ),  # 2
)


class createCdmLun_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createCdmLun_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createCdmLun_result)
createCdmLun_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class updateCdmLunInfo_args(object):
    """
    Attributes:
     - cdmLuns
     - jobId

    """


    def __init__(self, cdmLuns=None, jobId=None,):
        self.cdmLuns = cdmLuns
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cdmLuns = []
                    (_etype173, _size170) = iprot.readListBegin()
                    for _i174 in range(_size170):
                        _elem175 = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
                        _elem175.read(iprot)
                        self.cdmLuns.append(_elem175)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCdmLunInfo_args')
        if self.cdmLuns is not None:
            oprot.writeFieldBegin('cdmLuns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.cdmLuns))
            for iter176 in self.cdmLuns:
                iter176.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 2)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCdmLunInfo_args)
updateCdmLunInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cdmLuns', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, None], False), None, ),  # 1
    (2, TType.STRING, 'jobId', 'UTF8', None, ),  # 2
)


class updateCdmLunInfo_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateCdmLunInfo_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateCdmLunInfo_result)
updateCdmLunInfo_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class createVmCdmLunInfo_args(object):
    """
    Attributes:
     - vmVolumes
     - job_id
     - timepoint

    """


    def __init__(self, vmVolumes=None, job_id=None, timepoint=None,):
        self.vmVolumes = vmVolumes
        self.job_id = job_id
        self.timepoint = timepoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vmVolumes = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
                        _elem182.read(iprot)
                        self.vmVolumes.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timepoint = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createVmCdmLunInfo_args')
        if self.vmVolumes is not None:
            oprot.writeFieldBegin('vmVolumes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.vmVolumes))
            for iter183 in self.vmVolumes:
                iter183.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 2)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.timepoint is not None:
            oprot.writeFieldBegin('timepoint', TType.STRING, 3)
            oprot.writeString(self.timepoint.encode('utf-8') if sys.version_info[0] == 2 else self.timepoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createVmCdmLunInfo_args)
createVmCdmLunInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vmVolumes', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, None], False), None, ),  # 1
    (2, TType.STRING, 'job_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'timepoint', 'UTF8', None, ),  # 3
)


class createVmCdmLunInfo_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createVmCdmLunInfo_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createVmCdmLunInfo_result)
createVmCdmLunInfo_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class getVmCdmLunInfo_args(object):
    """
    Attributes:
     - job_id
     - vmuuid

    """


    def __init__(self, job_id=None, vmuuid=None,):
        self.job_id = job_id
        self.vmuuid = vmuuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.vmuuid = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vmuuid.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getVmCdmLunInfo_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.vmuuid is not None:
            oprot.writeFieldBegin('vmuuid', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.vmuuid))
            for iter190 in self.vmuuid:
                oprot.writeString(iter190.encode('utf-8') if sys.version_info[0] == 2 else iter190)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getVmCdmLunInfo_args)
getVmCdmLunInfo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'vmuuid', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class getVmCdmLunInfo_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype194, _size191) = iprot.readListBegin()
                    for _i195 in range(_size191):
                        _elem196 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
                        _elem196.read(iprot)
                        self.success.append(_elem196)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getVmCdmLunInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter197 in self.success:
                iter197.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getVmCdmLunInfo_result)
getVmCdmLunInfo_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class createVmwareTimePoint_args(object):
    """
    Attributes:
     - vminfos
     - timepoint
     - job_id

    """


    def __init__(self, vminfos=None, timepoint=None, job_id=None,):
        self.vminfos = vminfos
        self.timepoint = timepoint
        self.job_id = job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.vminfos = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
                        _elem203.read(iprot)
                        self.vminfos.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timepoint = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createVmwareTimePoint_args')
        if self.vminfos is not None:
            oprot.writeFieldBegin('vminfos', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.vminfos))
            for iter204 in self.vminfos:
                iter204.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timepoint is not None:
            oprot.writeFieldBegin('timepoint', TType.STRING, 2)
            oprot.writeString(self.timepoint.encode('utf-8') if sys.version_info[0] == 2 else self.timepoint)
            oprot.writeFieldEnd()
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 3)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createVmwareTimePoint_args)
createVmwareTimePoint_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'vminfos', (TType.STRUCT, [ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, None], False), None, ),  # 1
    (2, TType.STRING, 'timepoint', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'job_id', 'UTF8', None, ),  # 3
)


class createVmwareTimePoint_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createVmwareTimePoint_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createVmwareTimePoint_result)
createVmwareTimePoint_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_backup_jobs_historys_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_backup_jobs_historys_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_backup_jobs_historys_for_ams_args)
get_all_backup_jobs_historys_for_ams_args.thrift_spec = (
)


class get_all_backup_jobs_historys_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = ncAmsJob.ttypes.ncJobLog()
                        _elem210.read(iprot)
                        self.success.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_backup_jobs_historys_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter211 in self.success:
                iter211.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_backup_jobs_historys_for_ams_result)
get_all_backup_jobs_historys_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncJobLog, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_backup_jobs_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_backup_jobs_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_backup_jobs_for_ams_args)
get_all_backup_jobs_for_ams_args.thrift_spec = (
)


class get_all_backup_jobs_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype215, _size212) = iprot.readListBegin()
                    for _i216 in range(_size212):
                        _elem217 = ncAmsJob.ttypes.ncAmsJobType()
                        _elem217.read(iprot)
                        self.success.append(_elem217)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_backup_jobs_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter218 in self.success:
                iter218.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_backup_jobs_for_ams_result)
get_all_backup_jobs_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncAmsJobType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_mount_job_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_job_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_job_for_ams_args)
get_all_mount_job_for_ams_args.thrift_spec = (
)


class get_all_mount_job_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = ncAmsJob.ttypes.ncAmsJobType()
                        _elem224.read(iprot)
                        self.success.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_job_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter225 in self.success:
                iter225.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_job_for_ams_result)
get_all_mount_job_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncAmsJobType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_mount_jobInstance_for_ams_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_jobInstance_for_ams_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_jobInstance_for_ams_args)
get_all_mount_jobInstance_for_ams_args.thrift_spec = (
)


class get_all_mount_jobInstance_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = ncAmsJob.ttypes.ncJobLog()
                        _elem231.read(iprot)
                        self.success.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_mount_jobInstance_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter232 in self.success:
                iter232.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_mount_jobInstance_for_ams_result)
get_all_mount_jobInstance_for_ams_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncAmsJob.ttypes.ncJobLog, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_data_for_ams_args(object):
    """
    Attributes:
     - kwargs

    """


    def __init__(self, kwargs=None,):
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_args')
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 1)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_args)
get_data_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'kwargs', 'UTF8', None, ),  # 1
)


class get_data_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_result)
get_data_for_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class do_operation_from_ams_args(object):
    """
    Attributes:
     - target
     - method
     - kwargs

    """


    def __init__(self, target=None, method=None, kwargs=None,):
        self.target = target
        self.method = method
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.target = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_args')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.STRING, 1)
            oprot.writeString(self.target.encode('utf-8') if sys.version_info[0] == 2 else self.target)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 3)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_args)
do_operation_from_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'target', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'kwargs', 'UTF8', None, ),  # 3
)


class do_operation_from_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_result)
do_operation_from_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class is_exists_running_job_on_client_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_running_job_on_client_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_running_job_on_client_args)
is_exists_running_job_on_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class is_exists_running_job_on_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_running_job_on_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_running_job_on_client_result)
is_exists_running_job_on_client_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class is_exists_time_points_by_backup_job_id_args(object):
    """
    Attributes:
     - backup_job_id

    """


    def __init__(self, backup_job_id=None,):
        self.backup_job_id = backup_job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.backup_job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_time_points_by_backup_job_id_args')
        if self.backup_job_id is not None:
            oprot.writeFieldBegin('backup_job_id', TType.STRING, 1)
            oprot.writeString(self.backup_job_id.encode('utf-8') if sys.version_info[0] == 2 else self.backup_job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_time_points_by_backup_job_id_args)
is_exists_time_points_by_backup_job_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'backup_job_id', 'UTF8', None, ),  # 1
)


class is_exists_time_points_by_backup_job_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_time_points_by_backup_job_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_time_points_by_backup_job_id_result)
is_exists_time_points_by_backup_job_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class is_exists_base_volumes_by_backup_job_id_args(object):
    """
    Attributes:
     - backup_job_id

    """


    def __init__(self, backup_job_id=None,):
        self.backup_job_id = backup_job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.backup_job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_base_volumes_by_backup_job_id_args')
        if self.backup_job_id is not None:
            oprot.writeFieldBegin('backup_job_id', TType.STRING, 1)
            oprot.writeString(self.backup_job_id.encode('utf-8') if sys.version_info[0] == 2 else self.backup_job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_base_volumes_by_backup_job_id_args)
is_exists_base_volumes_by_backup_job_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'backup_job_id', 'UTF8', None, ),  # 1
)


class is_exists_base_volumes_by_backup_job_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_base_volumes_by_backup_job_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_base_volumes_by_backup_job_id_result)
is_exists_base_volumes_by_backup_job_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_origin_job_by_id_args(object):
    """
    Attributes:
     - originJobId

    """


    def __init__(self, originJobId=None,):
        self.originJobId = originJobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.originJobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_origin_job_by_id_args')
        if self.originJobId is not None:
            oprot.writeFieldBegin('originJobId', TType.STRING, 1)
            oprot.writeString(self.originJobId.encode('utf-8') if sys.version_info[0] == 2 else self.originJobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_origin_job_by_id_args)
get_origin_job_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'originJobId', 'UTF8', None, ),  # 1
)


class get_origin_job_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncCanSyncJobResponseData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_origin_job_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_origin_job_by_id_result)
get_origin_job_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncCanSyncJobResponseData, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_time_points_by_origin_job_id_args(object):
    """
    Attributes:
     - TimePointReq

    """


    def __init__(self, TimePointReq=None,):
        self.TimePointReq = TimePointReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.TimePointReq = ncCdmDispatchProto.ttypes.ncTimePointsRequest()
                    self.TimePointReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_time_points_by_origin_job_id_args')
        if self.TimePointReq is not None:
            oprot.writeFieldBegin('TimePointReq', TType.STRUCT, 1)
            self.TimePointReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_time_points_by_origin_job_id_args)
get_time_points_by_origin_job_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'TimePointReq', [ncCdmDispatchProto.ttypes.ncTimePointsRequest, None], None, ),  # 1
)


class get_time_points_by_origin_job_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncTimePointsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_time_points_by_origin_job_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_time_points_by_origin_job_id_result)
get_time_points_by_origin_job_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncTimePointsResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_sync_job_args(object):
    """
    Attributes:
     - createSyncJobReq

    """


    def __init__(self, createSyncJobReq=None,):
        self.createSyncJobReq = createSyncJobReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.createSyncJobReq = ncCdmDispatchProto.ttypes.ncCreateSyncJobRequest()
                    self.createSyncJobReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_job_args')
        if self.createSyncJobReq is not None:
            oprot.writeFieldBegin('createSyncJobReq', TType.STRUCT, 1)
            self.createSyncJobReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_job_args)
create_sync_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'createSyncJobReq', [ncCdmDispatchProto.ttypes.ncCreateSyncJobRequest, None], None, ),  # 1
)


class create_sync_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_job_result)
create_sync_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_can_sync_jobs_args(object):
    """
    Attributes:
     - canSyncJobReq

    """


    def __init__(self, canSyncJobReq=None,):
        self.canSyncJobReq = canSyncJobReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.canSyncJobReq = ncCdmDispatchProto.ttypes.ncCanSyncJobRequest()
                    self.canSyncJobReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_can_sync_jobs_args')
        if self.canSyncJobReq is not None:
            oprot.writeFieldBegin('canSyncJobReq', TType.STRUCT, 1)
            self.canSyncJobReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_can_sync_jobs_args)
get_can_sync_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'canSyncJobReq', [ncCdmDispatchProto.ttypes.ncCanSyncJobRequest, None], None, ),  # 1
)


class get_can_sync_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncCanSyncJobResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_can_sync_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_can_sync_jobs_result)
get_can_sync_jobs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncCanSyncJobResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_sync_time_point_args(object):
    """
    Attributes:
     - createSyncTimePointReq

    """


    def __init__(self, createSyncTimePointReq=None,):
        self.createSyncTimePointReq = createSyncTimePointReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.createSyncTimePointReq = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest()
                    self.createSyncTimePointReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_time_point_args')
        if self.createSyncTimePointReq is not None:
            oprot.writeFieldBegin('createSyncTimePointReq', TType.STRUCT, 1)
            self.createSyncTimePointReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_time_point_args)
create_sync_time_point_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'createSyncTimePointReq', [ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest, None], None, ),  # 1
)


class create_sync_time_point_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_time_point_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_time_point_result)
create_sync_time_point_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class is_exists_origin_job_by_id_args(object):
    """
    Attributes:
     - originJobId

    """


    def __init__(self, originJobId=None,):
        self.originJobId = originJobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.originJobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_origin_job_by_id_args')
        if self.originJobId is not None:
            oprot.writeFieldBegin('originJobId', TType.STRING, 1)
            oprot.writeString(self.originJobId.encode('utf-8') if sys.version_info[0] == 2 else self.originJobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_origin_job_by_id_args)
is_exists_origin_job_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'originJobId', 'UTF8', None, ),  # 1
)


class is_exists_origin_job_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('is_exists_origin_job_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(is_exists_origin_job_by_id_result)
is_exists_origin_job_by_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_sync_time_point_on_sync_start_args(object):
    """
    Attributes:
     - createSyncTimePointReq

    """


    def __init__(self, createSyncTimePointReq=None,):
        self.createSyncTimePointReq = createSyncTimePointReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.createSyncTimePointReq = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest()
                    self.createSyncTimePointReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_time_point_on_sync_start_args')
        if self.createSyncTimePointReq is not None:
            oprot.writeFieldBegin('createSyncTimePointReq', TType.STRUCT, 1)
            self.createSyncTimePointReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_time_point_on_sync_start_args)
create_sync_time_point_on_sync_start_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'createSyncTimePointReq', [ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest, None], None, ),  # 1
)


class create_sync_time_point_on_sync_start_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_sync_time_point_on_sync_start_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_sync_time_point_on_sync_start_result)
create_sync_time_point_on_sync_start_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncCreateSyncTimePointResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_sync_time_point_on_sync_finish_args(object):
    """
    Attributes:
     - updateSyncTimePointReq

    """


    def __init__(self, updateSyncTimePointReq=None,):
        self.updateSyncTimePointReq = updateSyncTimePointReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.updateSyncTimePointReq = ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointRequest()
                    self.updateSyncTimePointReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_sync_time_point_on_sync_finish_args')
        if self.updateSyncTimePointReq is not None:
            oprot.writeFieldBegin('updateSyncTimePointReq', TType.STRUCT, 1)
            self.updateSyncTimePointReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_sync_time_point_on_sync_finish_args)
update_sync_time_point_on_sync_finish_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'updateSyncTimePointReq', [ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointRequest, None], None, ),  # 1
)


class update_sync_time_point_on_sync_finish_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_sync_time_point_on_sync_finish_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_sync_time_point_on_sync_finish_result)
update_sync_time_point_on_sync_finish_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_sync_time_point_base_map_snap_args(object):
    """
    Attributes:
     - updateSyncTimePointVolumeReq

    """


    def __init__(self, updateSyncTimePointVolumeReq=None,):
        self.updateSyncTimePointVolumeReq = updateSyncTimePointVolumeReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.updateSyncTimePointVolumeReq = ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointVolumeRequest()
                    self.updateSyncTimePointVolumeReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_sync_time_point_base_map_snap_args')
        if self.updateSyncTimePointVolumeReq is not None:
            oprot.writeFieldBegin('updateSyncTimePointVolumeReq', TType.STRUCT, 1)
            self.updateSyncTimePointVolumeReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_sync_time_point_base_map_snap_args)
update_sync_time_point_base_map_snap_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'updateSyncTimePointVolumeReq', [ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointVolumeRequest, None], None, ),  # 1
)


class update_sync_time_point_base_map_snap_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_sync_time_point_base_map_snap_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_sync_time_point_base_map_snap_result)
update_sync_time_point_base_map_snap_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_sync_time_point_by_id_args(object):
    """
    Attributes:
     - deleteSyncTimePointIds

    """


    def __init__(self, deleteSyncTimePointIds=None,):
        self.deleteSyncTimePointIds = deleteSyncTimePointIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.deleteSyncTimePointIds = ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointRequest()
                    self.deleteSyncTimePointIds.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_sync_time_point_by_id_args')
        if self.deleteSyncTimePointIds is not None:
            oprot.writeFieldBegin('deleteSyncTimePointIds', TType.STRUCT, 1)
            self.deleteSyncTimePointIds.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_sync_time_point_by_id_args)
delete_sync_time_point_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'deleteSyncTimePointIds', [ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointRequest, None], None, ),  # 1
)


class delete_sync_time_point_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_sync_time_point_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_sync_time_point_by_id_result)
delete_sync_time_point_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_job_status_origin_job_by_id_args(object):
    """
    Attributes:
     - UpdateJobStatusReq

    """


    def __init__(self, UpdateJobStatusReq=None,):
        self.UpdateJobStatusReq = UpdateJobStatusReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.UpdateJobStatusReq = ncCdmDispatchProto.ttypes.ncUpdateJobStatusRequest()
                    self.UpdateJobStatusReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_job_status_origin_job_by_id_args')
        if self.UpdateJobStatusReq is not None:
            oprot.writeFieldBegin('UpdateJobStatusReq', TType.STRUCT, 1)
            self.UpdateJobStatusReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_job_status_origin_job_by_id_args)
update_job_status_origin_job_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'UpdateJobStatusReq', [ncCdmDispatchProto.ttypes.ncUpdateJobStatusRequest, None], None, ),  # 1
)


class update_job_status_origin_job_by_id_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_job_status_origin_job_by_id_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_job_status_origin_job_by_id_result)
update_job_status_origin_job_by_id_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_time_point_is_exist_args(object):
    """
    Attributes:
     - timePointId

    """


    def __init__(self, timePointId=None,):
        self.timePointId = timePointId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.timePointId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_time_point_is_exist_args')
        if self.timePointId is not None:
            oprot.writeFieldBegin('timePointId', TType.STRING, 1)
            oprot.writeString(self.timePointId.encode('utf-8') if sys.version_info[0] == 2 else self.timePointId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_time_point_is_exist_args)
check_time_point_is_exist_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'timePointId', 'UTF8', None, ),  # 1
)


class check_time_point_is_exist_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_time_point_is_exist_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_time_point_is_exist_result)
check_time_point_is_exist_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_dict_export_args(object):
    """
    Attributes:
     - body
     - jobInstanceId
     - userId

    """


    def __init__(self, body=None, jobInstanceId=None, userId=None,):
        self.body = body
        self.jobInstanceId = jobInstanceId
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.body = {}
                    (_ktype234, _vtype235, _size233) = iprot.readMapBegin()
                    for _i237 in range(_size233):
                        _key238 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val239 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.body[_key238] = _val239
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobInstanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dict_export_args')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
            for kiter240, viter241 in self.body.items():
                oprot.writeString(kiter240.encode('utf-8') if sys.version_info[0] == 2 else kiter240)
                oprot.writeString(viter241.encode('utf-8') if sys.version_info[0] == 2 else viter241)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.jobInstanceId is not None:
            oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
            oprot.writeString(self.jobInstanceId.encode('utf-8') if sys.version_info[0] == 2 else self.jobInstanceId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 3)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dict_export_args)
get_dict_export_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'body', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'jobInstanceId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'userId', 'UTF8', None, ),  # 3
)


class get_dict_export_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype243, _vtype244, _size242) = iprot.readMapBegin()
                    for _i246 in range(_size242):
                        _key247 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val248 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key247] = _val248
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dict_export_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter249, viter250 in self.success.items():
                oprot.writeString(kiter249.encode('utf-8') if sys.version_info[0] == 2 else kiter249)
                oprot.writeString(viter250.encode('utf-8') if sys.version_info[0] == 2 else viter250)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dict_export_result)
get_dict_export_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class mount_get_dict_export_args(object):
    """
    Attributes:
     - body
     - jobInstanceId
     - userId

    """


    def __init__(self, body=None, jobInstanceId=None, userId=None,):
        self.body = body
        self.jobInstanceId = jobInstanceId
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.body = {}
                    (_ktype252, _vtype253, _size251) = iprot.readMapBegin()
                    for _i255 in range(_size251):
                        _key256 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val257 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.body[_key256] = _val257
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobInstanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mount_get_dict_export_args')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
            for kiter258, viter259 in self.body.items():
                oprot.writeString(kiter258.encode('utf-8') if sys.version_info[0] == 2 else kiter258)
                oprot.writeString(viter259.encode('utf-8') if sys.version_info[0] == 2 else viter259)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.jobInstanceId is not None:
            oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
            oprot.writeString(self.jobInstanceId.encode('utf-8') if sys.version_info[0] == 2 else self.jobInstanceId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 3)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mount_get_dict_export_args)
mount_get_dict_export_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'body', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'jobInstanceId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'userId', 'UTF8', None, ),  # 3
)


class mount_get_dict_export_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype261, _vtype262, _size260) = iprot.readMapBegin()
                    for _i264 in range(_size260):
                        _key265 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val266 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key265] = _val266
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mount_get_dict_export_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter267, viter268 in self.success.items():
                oprot.writeString(kiter267.encode('utf-8') if sys.version_info[0] == 2 else kiter267)
                oprot.writeString(viter268.encode('utf-8') if sys.version_info[0] == 2 else viter268)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mount_get_dict_export_result)
mount_get_dict_export_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class backup_get_dict_export_args(object):
    """
    Attributes:
     - body
     - jobInstanceId
     - userId

    """


    def __init__(self, body=None, jobInstanceId=None, userId=None,):
        self.body = body
        self.jobInstanceId = jobInstanceId
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.body = {}
                    (_ktype270, _vtype271, _size269) = iprot.readMapBegin()
                    for _i273 in range(_size269):
                        _key274 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val275 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.body[_key274] = _val275
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.jobInstanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backup_get_dict_export_args')
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
            for kiter276, viter277 in self.body.items():
                oprot.writeString(kiter276.encode('utf-8') if sys.version_info[0] == 2 else kiter276)
                oprot.writeString(viter277.encode('utf-8') if sys.version_info[0] == 2 else viter277)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.jobInstanceId is not None:
            oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
            oprot.writeString(self.jobInstanceId.encode('utf-8') if sys.version_info[0] == 2 else self.jobInstanceId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 3)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backup_get_dict_export_args)
backup_get_dict_export_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'body', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'jobInstanceId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'userId', 'UTF8', None, ),  # 3
)


class backup_get_dict_export_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype279, _vtype280, _size278) = iprot.readMapBegin()
                    for _i282 in range(_size278):
                        _key283 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val284 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key283] = _val284
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('backup_get_dict_export_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter285, viter286 in self.success.items():
                oprot.writeString(kiter285.encode('utf-8') if sys.version_info[0] == 2 else kiter285)
                oprot.writeString(viter286.encode('utf-8') if sys.version_info[0] == 2 else viter286)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(backup_get_dict_export_result)
backup_get_dict_export_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_sourceId_args(object):
    """
    Attributes:
     - sourceType
     - svcType
     - sourceId
     - relation

    """


    def __init__(self, sourceType=None, svcType=None, sourceId=None, relation=1,):
        self.sourceType = sourceType
        self.svcType = svcType
        self.sourceId = sourceId
        self.relation = relation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sourceType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sourceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.relation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_sourceId_args')
        if self.sourceType is not None:
            oprot.writeFieldBegin('sourceType', TType.I32, 1)
            oprot.writeI32(self.sourceType)
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        if self.sourceId is not None:
            oprot.writeFieldBegin('sourceId', TType.STRING, 3)
            oprot.writeString(self.sourceId.encode('utf-8') if sys.version_info[0] == 2 else self.sourceId)
            oprot.writeFieldEnd()
        if self.relation is not None:
            oprot.writeFieldBegin('relation', TType.I32, 4)
            oprot.writeI32(self.relation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_sourceId_args)
get_jobs_by_sourceId_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sourceType', None, None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
    (3, TType.STRING, 'sourceId', 'UTF8', None, ),  # 3
    (4, TType.I32, 'relation', None, 1, ),  # 4
)


class get_jobs_by_sourceId_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = ncJob.ttypes.ncTJob()
                        _elem292.read(iprot)
                        self.success.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_sourceId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter293 in self.success:
                iter293.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_sourceId_result)
get_jobs_by_sourceId_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncTJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_jobs_by_datasource_args(object):
    """
    Attributes:
     - datasource
     - clientId
     - dbRunUserName

    """


    def __init__(self, datasource=None, clientId=None, dbRunUserName=None,):
        self.datasource = datasource
        self.clientId = clientId
        self.dbRunUserName = dbRunUserName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.datasource = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.dbRunUserName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_datasource_args')
        if self.datasource is not None:
            oprot.writeFieldBegin('datasource', TType.STRING, 1)
            oprot.writeString(self.datasource.encode('utf-8') if sys.version_info[0] == 2 else self.datasource)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 2)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.dbRunUserName is not None:
            oprot.writeFieldBegin('dbRunUserName', TType.STRING, 3)
            oprot.writeString(self.dbRunUserName.encode('utf-8') if sys.version_info[0] == 2 else self.dbRunUserName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_datasource_args)
get_jobs_by_datasource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'datasource', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'dbRunUserName', 'UTF8', None, ),  # 3
)


class get_jobs_by_datasource_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype297, _size294) = iprot.readListBegin()
                    for _i298 in range(_size294):
                        _elem299 = ncJob.ttypes.ncBackupJob()
                        _elem299.read(iprot)
                        self.success.append(_elem299)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_jobs_by_datasource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter300 in self.success:
                iter300.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_jobs_by_datasource_result)
get_jobs_by_datasource_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncJob.ttypes.ncBackupJob, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_sync_job_origin_job_by_id_args(object):
    """
    Attributes:
     - originJobId

    """


    def __init__(self, originJobId=None,):
        self.originJobId = originJobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.originJobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sync_job_origin_job_by_id_args')
        if self.originJobId is not None:
            oprot.writeFieldBegin('originJobId', TType.STRING, 1)
            oprot.writeString(self.originJobId.encode('utf-8') if sys.version_info[0] == 2 else self.originJobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sync_job_origin_job_by_id_args)
get_sync_job_origin_job_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'originJobId', 'UTF8', None, ),  # 1
)


class get_sync_job_origin_job_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncJobInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_sync_job_origin_job_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_sync_job_origin_job_by_id_result)
get_sync_job_origin_job_by_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncJobInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_user_has_data_args(object):
    """
    Attributes:
     - user_list

    """


    def __init__(self, user_list=None,):
        self.user_list = user_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.user_list = []
                    (_etype304, _size301) = iprot.readListBegin()
                    for _i305 in range(_size301):
                        _elem306 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.user_list.append(_elem306)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_args')
        if self.user_list is not None:
            oprot.writeFieldBegin('user_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.user_list))
            for iter307 in self.user_list:
                oprot.writeString(iter307.encode('utf-8') if sys.version_info[0] == 2 else iter307)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_args)
check_user_has_data_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'user_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class check_user_has_data_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype311, _size308) = iprot.readListBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter314 in self.success:
                oprot.writeString(iter314.encode('utf-8') if sys.version_info[0] == 2 else iter314)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_result)
check_user_has_data_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class resolve_clean_job_time_points_args(object):
    """
    Attributes:
     - job_id
     - clean_type
     - time_points
     - user
     - clean_job_id
     - login_ip

    """


    def __init__(self, job_id=None, clean_type=None, time_points=None, user=None, clean_job_id=None, login_ip=None,):
        self.job_id = job_id
        self.clean_type = clean_type
        self.time_points = time_points
        self.user = user
        self.clean_job_id = clean_job_id
        self.login_ip = login_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clean_type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.time_points = []
                    (_etype318, _size315) = iprot.readListBegin()
                    for _i319 in range(_size315):
                        _elem320 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.time_points.append(_elem320)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.user = ncUser.ttypes.ncUserInfo()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.clean_job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.login_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resolve_clean_job_time_points_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.clean_type is not None:
            oprot.writeFieldBegin('clean_type', TType.STRING, 2)
            oprot.writeString(self.clean_type.encode('utf-8') if sys.version_info[0] == 2 else self.clean_type)
            oprot.writeFieldEnd()
        if self.time_points is not None:
            oprot.writeFieldBegin('time_points', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.time_points))
            for iter321 in self.time_points:
                oprot.writeString(iter321.encode('utf-8') if sys.version_info[0] == 2 else iter321)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 4)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        if self.clean_job_id is not None:
            oprot.writeFieldBegin('clean_job_id', TType.STRING, 5)
            oprot.writeString(self.clean_job_id.encode('utf-8') if sys.version_info[0] == 2 else self.clean_job_id)
            oprot.writeFieldEnd()
        if self.login_ip is not None:
            oprot.writeFieldBegin('login_ip', TType.STRING, 6)
            oprot.writeString(self.login_ip.encode('utf-8') if sys.version_info[0] == 2 else self.login_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resolve_clean_job_time_points_args)
resolve_clean_job_time_points_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clean_type', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'time_points', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'user', [ncUser.ttypes.ncUserInfo, None], None, ),  # 4
    (5, TType.STRING, 'clean_job_id', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'login_ip', 'UTF8', None, ),  # 6
)


class resolve_clean_job_time_points_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resolve_clean_job_time_points_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resolve_clean_job_time_points_result)
resolve_clean_job_time_points_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_job_count_info_args(object):
    """
    Attributes:
     - startTime
     - userId

    """


    def __init__(self, startTime=None, userId=None,):
        self.startTime = startTime
        self.userId = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_count_info_args')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_count_info_args)
get_job_count_info_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'startTime', None, None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class get_job_count_info_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncJobCountInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_job_count_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_job_count_info_result)
get_job_count_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncJobCountInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class run_backup_job_handler_args(object):
    """
    Attributes:
     - job_instance_id
     - user_id

    """


    def __init__(self, job_instance_id=None, user_id=None,):
        self.job_instance_id = job_instance_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_instance_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_backup_job_handler_args')
        if self.job_instance_id is not None:
            oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
            oprot.writeString(self.job_instance_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_instance_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 2)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_backup_job_handler_args)
run_backup_job_handler_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_instance_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_id', 'UTF8', None, ),  # 2
)


class run_backup_job_handler_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_backup_job_handler_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_backup_job_handler_result)
run_backup_job_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class run_mount_job_handler_args(object):
    """
    Attributes:
     - job_instance_id
     - user_id

    """


    def __init__(self, job_instance_id=None, user_id=None,):
        self.job_instance_id = job_instance_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_instance_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_mount_job_handler_args')
        if self.job_instance_id is not None:
            oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
            oprot.writeString(self.job_instance_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_instance_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 2)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_mount_job_handler_args)
run_mount_job_handler_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_instance_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_id', 'UTF8', None, ),  # 2
)


class run_mount_job_handler_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_mount_job_handler_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_mount_job_handler_result)
run_mount_job_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class image_mount_handler_args(object):
    """
    Attributes:
     - job_instance_id
     - user_id

    """


    def __init__(self, job_instance_id=None, user_id=None,):
        self.job_instance_id = job_instance_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_instance_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('image_mount_handler_args')
        if self.job_instance_id is not None:
            oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
            oprot.writeString(self.job_instance_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_instance_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 2)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(image_mount_handler_args)
image_mount_handler_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_instance_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_id', 'UTF8', None, ),  # 2
)


class image_mount_handler_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('image_mount_handler_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(image_mount_handler_result)
image_mount_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class image_unmount_handler_args(object):
    """
    Attributes:
     - job_instance_id
     - user_id

    """


    def __init__(self, job_instance_id=None, user_id=None,):
        self.job_instance_id = job_instance_id
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_instance_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('image_unmount_handler_args')
        if self.job_instance_id is not None:
            oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
            oprot.writeString(self.job_instance_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_instance_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 2)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(image_unmount_handler_args)
image_unmount_handler_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_instance_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_id', 'UTF8', None, ),  # 2
)


class image_unmount_handler_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('image_unmount_handler_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(image_unmount_handler_result)
image_unmount_handler_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_extra_resource_by_username_args(object):
    """
    Attributes:
     - user_names

    """


    def __init__(self, user_names=None,):
        self.user_names = user_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.user_names = []
                    (_etype325, _size322) = iprot.readListBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.user_names.append(_elem327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_extra_resource_by_username_args')
        if self.user_names is not None:
            oprot.writeFieldBegin('user_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.user_names))
            for iter328 in self.user_names:
                oprot.writeString(iter328.encode('utf-8') if sys.version_info[0] == 2 else iter328)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_extra_resource_by_username_args)
delete_extra_resource_by_username_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'user_names', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class delete_extra_resource_by_username_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_extra_resource_by_username_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_extra_resource_by_username_result)
delete_extra_resource_by_username_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_task_src_from_DB_args(object):
    """
    Attributes:
     - job_id

    """


    def __init__(self, job_id=None,):
        self.job_id = job_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_src_from_DB_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_src_from_DB_args)
get_task_src_from_DB_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
)


class get_task_src_from_DB_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_src_from_DB_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter335 in self.success:
                oprot.writeString(iter335.encode('utf-8') if sys.version_info[0] == 2 else iter335)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_src_from_DB_result)
get_task_src_from_DB_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_jobs_by_pages_args(object):
    """
    Attributes:
     - BaseReq

    """


    def __init__(self, BaseReq=None,):
        self.BaseReq = BaseReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.BaseReq = ncCdmDispatchProto.ttypes.ncBaseRequest()
                    self.BaseReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_by_pages_args')
        if self.BaseReq is not None:
            oprot.writeFieldBegin('BaseReq', TType.STRUCT, 1)
            self.BaseReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_by_pages_args)
get_all_jobs_by_pages_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'BaseReq', [ncCdmDispatchProto.ttypes.ncBaseRequest, None], None, ),  # 1
)


class get_all_jobs_by_pages_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCdmDispatchProto.ttypes.ncBackupJobsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_jobs_by_pages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_jobs_by_pages_result)
get_all_jobs_by_pages_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCdmDispatchProto.ttypes.ncBackupJobsResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_cdmdatasource_by_client_args(object):
    """
    Attributes:
     - client_id
     - job_is_backup

    """


    def __init__(self, client_id=None, job_is_backup=None,):
        self.client_id = client_id
        self.job_is_backup = job_is_backup

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_is_backup = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cdmdatasource_by_client_args')
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 1)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        if self.job_is_backup is not None:
            oprot.writeFieldBegin('job_is_backup', TType.STRING, 2)
            oprot.writeString(self.job_is_backup.encode('utf-8') if sys.version_info[0] == 2 else self.job_is_backup)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cdmdatasource_by_client_args)
get_cdmdatasource_by_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_is_backup', 'UTF8', None, ),  # 2
)


class get_cdmdatasource_by_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype339, _size336) = iprot.readListBegin()
                    for _i340 in range(_size336):
                        _elem341 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem341)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cdmdatasource_by_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter342 in self.success:
                oprot.writeString(iter342.encode('utf-8') if sys.version_info[0] == 2 else iter342)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cdmdatasource_by_client_result)
get_cdmdatasource_by_client_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

