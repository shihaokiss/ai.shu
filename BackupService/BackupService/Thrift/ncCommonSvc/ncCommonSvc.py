# -*- coding: UTF-8 -*-
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=UTF-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw 提交任务失败

        """
        pass

    def get_all_clients(self):
        """
        获取客户端列表
        @ throw ncException

        """
        pass

    def get_available_internal_client(self):
        """
        获取一个在线内置客户端
        @ throw ncException

        """
        pass

    def get_clients_by_macs(self, macs):
        """
        获取指定客户端列表
        @ throw ncException

        Parameters:
         - macs

        """
        pass

    def get_clients_by_ids(self, client_ids):
        """
        根据id，获取指定客户端列表
        @ throw ncException

        Parameters:
         - client_ids

        """
        pass

    def get_clients_by_id(self, client_id):
        """
        根据单个id，获取指定客户端列表（物理客户端和虚拟客户端）
        @ throw ncException

        Parameters:
         - client_id

        """
        pass

    def get_storage_by_name(self, cloudStorageName):
        """
        根据名字，获取指定云存储
        @ throw ncException

        Parameters:
         - cloudStorageName

        """
        pass

    def get_storages(self):
        """
        获取所有云存储 C++使用
        @ throw ncException

        """
        pass

    def get_storage_by_type(self, cloud_type, use_type):
        """
        获取指定类型的云存储
        @ throw ncException

        Parameters:
         - cloud_type
         - use_type

        """
        pass

    def get_all_storages(self):
        """
        获取所有云存储 python使用
        @ throw ncException

        """
        pass

    def get_client(self, clientId):
        """
        获取制定客户端
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - clientId

        """
        pass

    def update_client(self, clientId, isEmail):
        """
        根据客户端ID，更改客户端的邮件标志
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        isEmail :是否发送邮件的标志
        @ throw ncException

        Parameters:
         - clientId
         - isEmail

        """
        pass

    def get_client_by_mac(self, clientMac):
        """
        根据机器码，获取客户端
        clientMac :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - clientMac

        """
        pass

    def get_platforms_by_request_config(self, p_req):
        """
        根据参数，获取虚拟化平台
        clientMac :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - p_req

        """
        pass

    def get_newest_platform(self, vplatformId):
        """
        根据id获取虚拟化平台
        commonService会根据更新时间，决定是否从客户端获取最新配置信息，该过程会登陆相关的虚拟化平台
        @ throw ncException

        Parameters:
         - vplatformId

        """
        pass

    def get_client_server_ip(self, client_uuid):
        """
        获取目的客户端所持有的服务端ip( for EMPS )



        Parameters:
         - client_uuid

        """
        pass

    def commit_job(self, clientId, baseInfo):
        """
        提交任务
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        baseInfo: baseInfo.machineCode需要在common服务赋值
        @ throw ncException

        Parameters:
         - clientId
         - baseInfo

        """
        pass

    def add_schedule_job(self, tScheTaskInfo):
        """
           * 添加计划任务
        * ncTScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - tScheTaskInfo

        """
        pass

    def remove_plans_in_cache(self, planIds):
        """
        Parameters:
         - planIds

        """
        pass

    def modify_schedule_job(self, tScheTaskInfo):
        """
           * 更新计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - tScheTaskInfo

        """
        pass

    def modify_schedule_list_job(self, tScheTaskInfoList):
        """
           * 批量更新计划任务（有添加功能，供内部使用）
        * list<tScheTaskInfo>   计划任务信息
        *
           * @ throw ncException

        Parameters:
         - tScheTaskInfoList

        """
        pass

    def delete_schedule_jobs(self, planId_list, svcType):
        """
           * 删除计划任务
        * planId_list   计划任务id列表 注意 planId_list 为空 意味着 删除所有计划
        * svcType       应用类型
           * @ throw ncException

        Parameters:
         - planId_list
         - svcType

        """
        pass

    def update_schedule_jobs_state(self, planId_list, state, svcType):
        """
           * 修改计划任务状态 就是启用禁用按钮
        * planId_list   计划任务id列表 注意 planId_list 为空 意味着 启用禁用所有计划
        * state         任务状态
        * svcType       应用类型
           * @ throw ncException

        Parameters:
         - planId_list
         - state
         - svcType

        """
        pass

    def get_schedule_all_jobs(self, svcType, filter, count, index, auther):
        """
           * 得到所有的计划
        * string filter  注意为空时代表获取从index位置到inde+count位置的计划
        * svcType 应用服务类型
        * count 计划任务总数
        * index 偏移位置
        * return list<ncTScheTaskInfo>
           * @ throw ncException

        Parameters:
         - svcType
         - filter
         - count
         - index
         - auther

        """
        pass

    def get_schedule_job(self, planId):
        """
           * 得到某条计划任务信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - planId

        """
        pass

    def get_schedule_jobs(self, jobId, count, index):
        """
           * 得到某条job的所有计划
        * count 计划任务总数
        * index 偏移位置
        * return ncTScheTaskInfoResult
           * @ throw ncException

        Parameters:
         - jobId
         - count
         - index

        """
        pass

    def get_schedule_depend_jobs(self, jobId, count, index):
        """
           * 得到依赖某条job的所有计划
        * count 计划任务总数
        * index 偏移位置
        * return ncTScheTaskInfoResult
           * @ throw ncException

        Parameters:
         - jobId
         - count
         - index

        """
        pass

    def remove_all_plan_by_job_id(self, jobId, svcType):
        """
           * 删除某个任务的所有计划
        * jobId 任务
        * svcType
           * @ throw ncException

        Parameters:
         - jobId
         - svcType

        """
        pass

    def remove_all_plan_by_job_ids(self, jobIds, svcType):
        """
        Parameters:
         - jobIds
         - svcType

        """
        pass

    def get_next_run_sche_by_job_id(self, jobIdList, svcType):
        """
           * 根据任务id批量得到下次计划时间
        * jobId 任务
        * svcType
           * @ throw ncException

        Parameters:
         - jobIdList
         - svcType

        """
        pass

    def verify_plan_exists(self, planId):
        """
           * 检测计划任务是否存在
        * planId 计划任务总数

        Parameters:
         - planId

        """
        pass

    def get_all_sches_in_node(self, real):
        """
           * 得到某个节点上的所有计划
           * real true:正在运行的计划，false: 数据库中的计划
        * return 返回结果

        Parameters:
         - real

        """
        pass

    def get_db_instance(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_db_instances(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_datasource_client_info(self, clientId):
        """
        Parameters:
         - clientId

        """
        pass

    def get_server_by_ip(self, ip):
        """
        根据ip获取server
        ip: 服务器ip
        retur ncServer


        Parameters:
         - ip

        """
        pass

    def get_available_child_clients(self, nc_parent_client, filter_parameter):
        """
        获取某一虚拟客户端下可用的子物理客户端(提供某种筛选条件)

        Parameters:
         - nc_parent_client
         - filter_parameter

        """
        pass

    def get_all_child_clients(self, nc_parent_client, filter_parameter):
        """
        获取某一虚拟客户端下所有的子物理客户端

        Parameters:
         - nc_parent_client
         - filter_parameter

        """
        pass

    def get_parent_clients(self, clientId):
        """
        Parameters:
         - clientId

        """
        pass

    def get_hadoop_info(self, nc_parent_client):
        """
        Parameters:
         - nc_parent_client

        """
        pass

    def get_mongodb_client_info(self, parent_client_id, child_client_id):
        """
        Parameters:
         - parent_client_id
         - child_client_id

        """
        pass

    def client_authorize(self, cliDisReq):
        """
        用户分配and回收


        Parameters:
         - cliDisReq

        """
        pass

    def platform_authorize(self, platDisReq):
        """
        平台回收或者分配


        Parameters:
         - platDisReq

        """
        pass

    def get_servers(self, request):
        """
        Parameters:
         - request

        """
        pass

    def del_auth_users_task(self, authReq):
        """
        删除用户所有关联


        Parameters:
         - authReq

        """
        pass

    def update_state_auth_users_task(self, authReq, state):
        """
        禁用or启用用户所有关联


        Parameters:
         - authReq
         - state

        """
        pass

    def get_strategy(self, strategyId):
        """
           * 得到cdm策略信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId

        """
        pass

    def get_strategy_by_name_and_job_type(self, strategy_name, job_type):
        """
           * 得到cdm策略信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategy_name
         - job_type

        """
        pass

    def create_strategy_schedule(self, strategyId, job_id, begin_time):
        """
           * 创建cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId
         - job_id
         - begin_time

        """
        pass

    def modify_strategy_schedule(self, strategyId, job_id, begin_time):
        """
           * 更新cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId
         - job_id
         - begin_time

        """
        pass

    def new_modify_strategy_schedule(self, schedules):
        """
           * 更新cdm策略调度(只编辑计划)
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - schedules

        """
        pass

    def delete_strategy_schedule(self, job_id, host_id):
        """
           * 删除cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - job_id
         - host_id

        """
        pass

    def delete_cur_strategy_schedule(self, plan_id_list):
        """
           * 删除当前节点cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - plan_id_list

        """
        pass

    def get_clientid_nctclient(self, request):
        """
        根据一组筛选条件, 筛选一组客户端( 接口命名, 体现了返回值是一个map)

        注: 筛选条件, 尽量映射到Django ORM的术语

        Parameters:
         - request

        """
        pass

    def get_client_configs_by_client_id(self, clientId):
        """
        获取指定客户端配置信息
        @ throw ncException

        Parameters:
         - clientId

        """
        pass

    def get_fp_user_status(self, fp_id, user_name):
        """
           * 获取指纹池状态
        * return fpStatus
        * @throw ncException

        Parameters:
         - fp_id
         - user_name

        """
        pass

    def get_fp_by_node_ip(self, node_ip):
        """
        获取该节点ip上是否拥有指纹池
        return fp
        @throw ncException

        Parameters:
         - node_ip

        """
        pass

    def get_contentcloudresourceid_resourceobj(self, request):
        """
        Parameters:
         - request

        """
        pass

    def get_username_by_flguid(self, flguid):
        """
        获取指纹库所属用户名
        return username
        @throw ncException

        Parameters:
         - flguid

        """
        pass

    def delete_recovery_client(self, client_id):
        """
        删除恢复任务相关客户端记录
        @throw ncException

        Parameters:
         - client_id

        """
        pass

    def delete_recovery_clients(self, client_ids):
        """
        批量删除恢复任务相关客户端记录
        @throw ncException

        Parameters:
         - client_ids

        """
        pass

    def update_job_message_for_ams(self, jobId, msgMethod):
        """
        更改任务时，发送消息到AMS
        包括任务新增，更新任务状态，对任务进行编辑
        @throw ncException

        Parameters:
         - jobId
         - msgMethod

        """
        pass

    def add_recovery_job_for_ams(self, jobId):
        """
        创建数据恢复任务时，发送消息到AMS
        @throw ncException

        Parameters:
         - jobId

        """
        pass

    def get_task_log_message(self, instanceId, msgMethod):
        """
        执行任务时，将任务执行记录发送至AMS
        @throw ncException

        Parameters:
         - instanceId
         - msgMethod

        """
        pass

    def get_delete_job_message(self, taskId):
        """
        删除任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - taskId

        """
        pass

    def create_clean_job(self, clean_job):
        """
        创建数据清理任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - clean_job

        """
        pass

    def update_remote_job_log(self, jobInstance, msgMethod):
        """
        更新远程复制执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        pass

    def update_remote_job(self, job, msgMethod):
        """
        更新远程复制任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        pass

    def update_cdm_backup_job(self, job, msgMethod):
        """
        更新cdm数据备份任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        pass

    def update_cdm_backup_job_history(self, jobInstance, msgMethod):
        """
        更新cdm数据备份任务执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        pass

    def update_cdm_mount_job(self, job, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        pass

    def update_cdp_job(self, job, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        pass

    def update_cdp_job_instance(self, jobInstance, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        pass

    def project_user_authorize(self, projectUserDisReq):
        """
        租户回收或者分配


        Parameters:
         - projectUserDisReq

        """
        pass

    def get_newest_projectuser(self, projectuserIds, decrypt):
        """
        获取租户列表
        @ throw ncException

        Parameters:
         - projectuserIds
         - decrypt

        """
        pass

    def get_newest_projectstorage(self, projectId):
        """
        获取租户关联的存储信息
        @ throw ncException

        Parameters:
         - projectId

        """
        pass

    def update_cdm_mount_job_instance(self, jobInstance, msgMethod):
        """
        更新cdm数据访问任务执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        pass

    def get_client_count_by_auth_user(self, username):
        """
        Parameters:
         - username

        """
        pass

    def get_clients_by_vir_platform(self, vir_platform_id):
        """
        获取虚拟化平台绑定的客户端
         return ncTClient
         @throw ncException

        Parameters:
         - vir_platform_id

        """
        pass

    def get_client_by_vir_platform_and_node(self, vir_platform_id, node_id):
        """
        通过平台id，节点id,获取虚拟化平台绑定的客户端
         return ncTClient
         @throw ncException

        Parameters:
         - vir_platform_id
         - node_id

        """
        pass

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        pass

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        pass

    def get_cluster_datasource(self, req):
        """
        Parameters:
         - req

        """
        pass

    def get_virtual_machine_datasource(self, client_id, req):
        """
        Parameters:
         - client_id
         - req

        """
        pass

    def get_client_by_ip_or_id(self, client_ip, client_id):
        """
        通过ip获取指定客户端
        @ throw ncException

        Parameters:
         - client_ip
         - client_id

        """
        pass

    def get_in_kvm_platform(self):
        """
        获取内置虚拟化平台信息（KVM）


        """
        pass

    def update_or_create_fp_pool(self):
        """
        更新指纹池节点信息，若节点变化，则编辑指纹库


        """
        pass

    def get_client_type_by_id(self, clientId):
        """
        判断是不是内置客户端


        Parameters:
         - clientId

        """
        pass

    def check_user_source(self, username, source):
        """
        判断客户端是否属于用户


        Parameters:
         - username
         - source

        """
        pass

    def get_server_by_client_ip(self, ip):
        """
        根据客户端ip获取server
        ip: 客户端ip
        return ncServer


        Parameters:
         - ip

        """
        pass

    def get_client_link_type(self, configId, hostId, wwn):
        """
        根据客户端配置信息id获取客户端id
        configId: 客户端配置信息id
        hostId: 客户端id
        wwn: 客户端对应的链路信息
        return bool


        Parameters:
         - configId
         - hostId
         - wwn

        """
        pass

    def get_virtual_safety_users(self, infos):
        """
        Parameters:
         - infos

        """
        pass

    def get_all_clients_to_log(self, user_id):
        """
        Parameters:
         - user_id

        """
        pass

    def get_fp_node_info_by_node_ip(self, node_ip):
        """
        获取该节点指纹池信息
        return fp
        @throw ncException

        Parameters:
         - node_ip

        """
        pass

    def get_fl_by_fpoor_id(self, fp_id):
        """
        *
        * 通过指纹池id判断时候有指纹库
        *
           *

        Parameters:
         - fp_id

        """
        pass

    def update_finger_poor_nodes(self, fp_id, node_ip):
        """
        *
        删除指纹池相关节点更新数据


        Parameters:
         - fp_id
         - node_ip

        """
        pass

    def get_fl_guid_ids_by_fp_id(self, fp_id):
        """
        *
        获取指纹池关联的所有指纹库编号


        Parameters:
         - fp_id

        """
        pass

    def get_protect_object_count(self, user):
        """
        *
        获取保护对象数量


        Parameters:
         - user

        """
        pass

    def update_clients(self, clientId, customer, clusterPort):
        """
        Parameters:
         - clientId
         - customer
         - clusterPort

        """
        pass

    def get_fp_data_by_primary_key_id(self, primary_key_id):
        """
        *
        根据表FingerPoors主键值获取对应的指纹池数据


        Parameters:
         - primary_key_id

        """
        pass

    def get_backup_cloud_jobs(self, query_all):
        """
        *
        获取云备份任务


        Parameters:
         - query_all

        """
        pass

    def get_projectuser_list(self, cplatform_types):
        """
        获取云平台租户列表

        Parameters:
         - cplatform_types

        """
        pass

    def get_all_protect_object(self):
        """
        *
        获取所有保护对象


        """
        pass

    def abstract_public_interface(self, msg, body):
        """
        Parameters:
         - msg
         - body

        """
        pass

    def check_get_appsys(self, req):
        """
        *
        检测应用系统相关信息

        Parameters:
         - req

        """
        pass

    def update_eceph_info(self, cinfo):
        """
        *
        更新 内容云关联灾备对象存储容量和状态， 状态优先

        Parameters:
         - cinfo

        """
        pass

    def modify_schedule_job_cur_node(self, strategy_id, job_id, begin_time, is_modify_strategy):
        """
           * 更新当前节点上的计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - strategy_id
         - job_id
         - begin_time
         - is_modify_strategy

        """
        pass

    def check_user_has_data(self, user_list):
        """
        检测用户是否存在存储指纹池指纹库数据
        @ return 返回有存储数据的用户列表


        Parameters:
         - user_list

        """
        pass

    def create_schedules_cur_node(self, schedules):
        """
           * 当前节点上的批量创建任务的计划
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        pass

    def modify_job_schedules_cur_node(self, schedules):
        """
           * 更新任务时更新当前节点上的计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        pass

    def get_schedule_start_time(self, schedules):
        """
           * 根据计划id获取计划类型的最近一次发起时间
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        pass

    def get_public_cloud_resource(self, public_cloud_id):
        """
        根据id获取公有云资源

        @ throw ncException

        Parameters:
         - public_cloud_id

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def microprobe(self):
        """
        服务探针，测试服务可用性
        @ throw 提交任务失败

        """
        self.send_microprobe()
        self.recv_microprobe()

    def send_microprobe(self):
        self._oprot.writeMessageBegin('microprobe', TMessageType.CALL, self._seqid)
        args = microprobe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_microprobe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = microprobe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_all_clients(self):
        """
        获取客户端列表
        @ throw ncException

        """
        self.send_get_all_clients()
        return self.recv_get_all_clients()

    def send_get_all_clients(self):
        self._oprot.writeMessageBegin('get_all_clients', TMessageType.CALL, self._seqid)
        args = get_all_clients_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_clients failed: unknown result")

    def get_available_internal_client(self):
        """
        获取一个在线内置客户端
        @ throw ncException

        """
        self.send_get_available_internal_client()
        return self.recv_get_available_internal_client()

    def send_get_available_internal_client(self):
        self._oprot.writeMessageBegin('get_available_internal_client', TMessageType.CALL, self._seqid)
        args = get_available_internal_client_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_available_internal_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_available_internal_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_available_internal_client failed: unknown result")

    def get_clients_by_macs(self, macs):
        """
        获取指定客户端列表
        @ throw ncException

        Parameters:
         - macs

        """
        self.send_get_clients_by_macs(macs)
        return self.recv_get_clients_by_macs()

    def send_get_clients_by_macs(self, macs):
        self._oprot.writeMessageBegin('get_clients_by_macs', TMessageType.CALL, self._seqid)
        args = get_clients_by_macs_args()
        args.macs = macs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clients_by_macs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clients_by_macs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clients_by_macs failed: unknown result")

    def get_clients_by_ids(self, client_ids):
        """
        根据id，获取指定客户端列表
        @ throw ncException

        Parameters:
         - client_ids

        """
        self.send_get_clients_by_ids(client_ids)
        return self.recv_get_clients_by_ids()

    def send_get_clients_by_ids(self, client_ids):
        self._oprot.writeMessageBegin('get_clients_by_ids', TMessageType.CALL, self._seqid)
        args = get_clients_by_ids_args()
        args.client_ids = client_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clients_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clients_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clients_by_ids failed: unknown result")

    def get_clients_by_id(self, client_id):
        """
        根据单个id，获取指定客户端列表（物理客户端和虚拟客户端）
        @ throw ncException

        Parameters:
         - client_id

        """
        self.send_get_clients_by_id(client_id)
        return self.recv_get_clients_by_id()

    def send_get_clients_by_id(self, client_id):
        self._oprot.writeMessageBegin('get_clients_by_id', TMessageType.CALL, self._seqid)
        args = get_clients_by_id_args()
        args.client_id = client_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clients_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clients_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clients_by_id failed: unknown result")

    def get_storage_by_name(self, cloudStorageName):
        """
        根据名字，获取指定云存储
        @ throw ncException

        Parameters:
         - cloudStorageName

        """
        self.send_get_storage_by_name(cloudStorageName)
        return self.recv_get_storage_by_name()

    def send_get_storage_by_name(self, cloudStorageName):
        self._oprot.writeMessageBegin('get_storage_by_name', TMessageType.CALL, self._seqid)
        args = get_storage_by_name_args()
        args.cloudStorageName = cloudStorageName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_by_name failed: unknown result")

    def get_storages(self):
        """
        获取所有云存储 C++使用
        @ throw ncException

        """
        self.send_get_storages()
        return self.recv_get_storages()

    def send_get_storages(self):
        self._oprot.writeMessageBegin('get_storages', TMessageType.CALL, self._seqid)
        args = get_storages_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storages failed: unknown result")

    def get_storage_by_type(self, cloud_type, use_type):
        """
        获取指定类型的云存储
        @ throw ncException

        Parameters:
         - cloud_type
         - use_type

        """
        self.send_get_storage_by_type(cloud_type, use_type)
        return self.recv_get_storage_by_type()

    def send_get_storage_by_type(self, cloud_type, use_type):
        self._oprot.writeMessageBegin('get_storage_by_type', TMessageType.CALL, self._seqid)
        args = get_storage_by_type_args()
        args.cloud_type = cloud_type
        args.use_type = use_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_storage_by_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_storage_by_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_storage_by_type failed: unknown result")

    def get_all_storages(self):
        """
        获取所有云存储 python使用
        @ throw ncException

        """
        self.send_get_all_storages()
        return self.recv_get_all_storages()

    def send_get_all_storages(self):
        self._oprot.writeMessageBegin('get_all_storages', TMessageType.CALL, self._seqid)
        args = get_all_storages_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_storages(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_storages_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_storages failed: unknown result")

    def get_client(self, clientId):
        """
        获取制定客户端
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - clientId

        """
        self.send_get_client(clientId)
        return self.recv_get_client()

    def send_get_client(self, clientId):
        self._oprot.writeMessageBegin('get_client', TMessageType.CALL, self._seqid)
        args = get_client_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client failed: unknown result")

    def update_client(self, clientId, isEmail):
        """
        根据客户端ID，更改客户端的邮件标志
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        isEmail :是否发送邮件的标志
        @ throw ncException

        Parameters:
         - clientId
         - isEmail

        """
        self.send_update_client(clientId, isEmail)
        self.recv_update_client()

    def send_update_client(self, clientId, isEmail):
        self._oprot.writeMessageBegin('update_client', TMessageType.CALL, self._seqid)
        args = update_client_args()
        args.clientId = clientId
        args.isEmail = isEmail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_client_by_mac(self, clientMac):
        """
        根据机器码，获取客户端
        clientMac :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - clientMac

        """
        self.send_get_client_by_mac(clientMac)
        return self.recv_get_client_by_mac()

    def send_get_client_by_mac(self, clientMac):
        self._oprot.writeMessageBegin('get_client_by_mac', TMessageType.CALL, self._seqid)
        args = get_client_by_mac_args()
        args.clientMac = clientMac
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_by_mac(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_by_mac_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_by_mac failed: unknown result")

    def get_platforms_by_request_config(self, p_req):
        """
        根据参数，获取虚拟化平台
        clientMac :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        @ throw ncException

        Parameters:
         - p_req

        """
        self.send_get_platforms_by_request_config(p_req)
        return self.recv_get_platforms_by_request_config()

    def send_get_platforms_by_request_config(self, p_req):
        self._oprot.writeMessageBegin('get_platforms_by_request_config', TMessageType.CALL, self._seqid)
        args = get_platforms_by_request_config_args()
        args.p_req = p_req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_platforms_by_request_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_platforms_by_request_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_platforms_by_request_config failed: unknown result")

    def get_newest_platform(self, vplatformId):
        """
        根据id获取虚拟化平台
        commonService会根据更新时间，决定是否从客户端获取最新配置信息，该过程会登陆相关的虚拟化平台
        @ throw ncException

        Parameters:
         - vplatformId

        """
        self.send_get_newest_platform(vplatformId)
        return self.recv_get_newest_platform()

    def send_get_newest_platform(self, vplatformId):
        self._oprot.writeMessageBegin('get_newest_platform', TMessageType.CALL, self._seqid)
        args = get_newest_platform_args()
        args.vplatformId = vplatformId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_newest_platform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_newest_platform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_newest_platform failed: unknown result")

    def get_client_server_ip(self, client_uuid):
        """
        获取目的客户端所持有的服务端ip( for EMPS )



        Parameters:
         - client_uuid

        """
        self.send_get_client_server_ip(client_uuid)
        return self.recv_get_client_server_ip()

    def send_get_client_server_ip(self, client_uuid):
        self._oprot.writeMessageBegin('get_client_server_ip', TMessageType.CALL, self._seqid)
        args = get_client_server_ip_args()
        args.client_uuid = client_uuid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_server_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_server_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_server_ip failed: unknown result")

    def commit_job(self, clientId, baseInfo):
        """
        提交任务
        clientId :后面将数据库主键统一为uuid，这里使用string型，兼容目前的int自增主键和后期uuid
        baseInfo: baseInfo.machineCode需要在common服务赋值
        @ throw ncException

        Parameters:
         - clientId
         - baseInfo

        """
        self.send_commit_job(clientId, baseInfo)
        self.recv_commit_job()

    def send_commit_job(self, clientId, baseInfo):
        self._oprot.writeMessageBegin('commit_job', TMessageType.CALL, self._seqid)
        args = commit_job_args()
        args.clientId = clientId
        args.baseInfo = baseInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def add_schedule_job(self, tScheTaskInfo):
        """
           * 添加计划任务
        * ncTScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - tScheTaskInfo

        """
        self.send_add_schedule_job(tScheTaskInfo)
        return self.recv_add_schedule_job()

    def send_add_schedule_job(self, tScheTaskInfo):
        self._oprot.writeMessageBegin('add_schedule_job', TMessageType.CALL, self._seqid)
        args = add_schedule_job_args()
        args.tScheTaskInfo = tScheTaskInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_schedule_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_schedule_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_schedule_job failed: unknown result")

    def remove_plans_in_cache(self, planIds):
        """
        Parameters:
         - planIds

        """
        self.send_remove_plans_in_cache(planIds)
        self.recv_remove_plans_in_cache()

    def send_remove_plans_in_cache(self, planIds):
        self._oprot.writeMessageBegin('remove_plans_in_cache', TMessageType.CALL, self._seqid)
        args = remove_plans_in_cache_args()
        args.planIds = planIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_plans_in_cache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_plans_in_cache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def modify_schedule_job(self, tScheTaskInfo):
        """
           * 更新计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - tScheTaskInfo

        """
        self.send_modify_schedule_job(tScheTaskInfo)
        return self.recv_modify_schedule_job()

    def send_modify_schedule_job(self, tScheTaskInfo):
        self._oprot.writeMessageBegin('modify_schedule_job', TMessageType.CALL, self._seqid)
        args = modify_schedule_job_args()
        args.tScheTaskInfo = tScheTaskInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_schedule_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_schedule_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modify_schedule_job failed: unknown result")

    def modify_schedule_list_job(self, tScheTaskInfoList):
        """
           * 批量更新计划任务（有添加功能，供内部使用）
        * list<tScheTaskInfo>   计划任务信息
        *
           * @ throw ncException

        Parameters:
         - tScheTaskInfoList

        """
        self.send_modify_schedule_list_job(tScheTaskInfoList)
        self.recv_modify_schedule_list_job()

    def send_modify_schedule_list_job(self, tScheTaskInfoList):
        self._oprot.writeMessageBegin('modify_schedule_list_job', TMessageType.CALL, self._seqid)
        args = modify_schedule_list_job_args()
        args.tScheTaskInfoList = tScheTaskInfoList
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_schedule_list_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_schedule_list_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_schedule_jobs(self, planId_list, svcType):
        """
           * 删除计划任务
        * planId_list   计划任务id列表 注意 planId_list 为空 意味着 删除所有计划
        * svcType       应用类型
           * @ throw ncException

        Parameters:
         - planId_list
         - svcType

        """
        self.send_delete_schedule_jobs(planId_list, svcType)
        self.recv_delete_schedule_jobs()

    def send_delete_schedule_jobs(self, planId_list, svcType):
        self._oprot.writeMessageBegin('delete_schedule_jobs', TMessageType.CALL, self._seqid)
        args = delete_schedule_jobs_args()
        args.planId_list = planId_list
        args.svcType = svcType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_schedule_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_schedule_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_schedule_jobs_state(self, planId_list, state, svcType):
        """
           * 修改计划任务状态 就是启用禁用按钮
        * planId_list   计划任务id列表 注意 planId_list 为空 意味着 启用禁用所有计划
        * state         任务状态
        * svcType       应用类型
           * @ throw ncException

        Parameters:
         - planId_list
         - state
         - svcType

        """
        self.send_update_schedule_jobs_state(planId_list, state, svcType)
        self.recv_update_schedule_jobs_state()

    def send_update_schedule_jobs_state(self, planId_list, state, svcType):
        self._oprot.writeMessageBegin('update_schedule_jobs_state', TMessageType.CALL, self._seqid)
        args = update_schedule_jobs_state_args()
        args.planId_list = planId_list
        args.state = state
        args.svcType = svcType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_schedule_jobs_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_schedule_jobs_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_schedule_all_jobs(self, svcType, filter, count, index, auther):
        """
           * 得到所有的计划
        * string filter  注意为空时代表获取从index位置到inde+count位置的计划
        * svcType 应用服务类型
        * count 计划任务总数
        * index 偏移位置
        * return list<ncTScheTaskInfo>
           * @ throw ncException

        Parameters:
         - svcType
         - filter
         - count
         - index
         - auther

        """
        self.send_get_schedule_all_jobs(svcType, filter, count, index, auther)
        return self.recv_get_schedule_all_jobs()

    def send_get_schedule_all_jobs(self, svcType, filter, count, index, auther):
        self._oprot.writeMessageBegin('get_schedule_all_jobs', TMessageType.CALL, self._seqid)
        args = get_schedule_all_jobs_args()
        args.svcType = svcType
        args.filter = filter
        args.count = count
        args.index = index
        args.auther = auther
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_all_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_all_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_all_jobs failed: unknown result")

    def get_schedule_job(self, planId):
        """
           * 得到某条计划任务信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - planId

        """
        self.send_get_schedule_job(planId)
        return self.recv_get_schedule_job()

    def send_get_schedule_job(self, planId):
        self._oprot.writeMessageBegin('get_schedule_job', TMessageType.CALL, self._seqid)
        args = get_schedule_job_args()
        args.planId = planId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_job failed: unknown result")

    def get_schedule_jobs(self, jobId, count, index):
        """
           * 得到某条job的所有计划
        * count 计划任务总数
        * index 偏移位置
        * return ncTScheTaskInfoResult
           * @ throw ncException

        Parameters:
         - jobId
         - count
         - index

        """
        self.send_get_schedule_jobs(jobId, count, index)
        return self.recv_get_schedule_jobs()

    def send_get_schedule_jobs(self, jobId, count, index):
        self._oprot.writeMessageBegin('get_schedule_jobs', TMessageType.CALL, self._seqid)
        args = get_schedule_jobs_args()
        args.jobId = jobId
        args.count = count
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_jobs failed: unknown result")

    def get_schedule_depend_jobs(self, jobId, count, index):
        """
           * 得到依赖某条job的所有计划
        * count 计划任务总数
        * index 偏移位置
        * return ncTScheTaskInfoResult
           * @ throw ncException

        Parameters:
         - jobId
         - count
         - index

        """
        self.send_get_schedule_depend_jobs(jobId, count, index)
        return self.recv_get_schedule_depend_jobs()

    def send_get_schedule_depend_jobs(self, jobId, count, index):
        self._oprot.writeMessageBegin('get_schedule_depend_jobs', TMessageType.CALL, self._seqid)
        args = get_schedule_depend_jobs_args()
        args.jobId = jobId
        args.count = count
        args.index = index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_depend_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_depend_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_depend_jobs failed: unknown result")

    def remove_all_plan_by_job_id(self, jobId, svcType):
        """
           * 删除某个任务的所有计划
        * jobId 任务
        * svcType
           * @ throw ncException

        Parameters:
         - jobId
         - svcType

        """
        self.send_remove_all_plan_by_job_id(jobId, svcType)
        self.recv_remove_all_plan_by_job_id()

    def send_remove_all_plan_by_job_id(self, jobId, svcType):
        self._oprot.writeMessageBegin('remove_all_plan_by_job_id', TMessageType.CALL, self._seqid)
        args = remove_all_plan_by_job_id_args()
        args.jobId = jobId
        args.svcType = svcType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_plan_by_job_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_plan_by_job_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def remove_all_plan_by_job_ids(self, jobIds, svcType):
        """
        Parameters:
         - jobIds
         - svcType

        """
        self.send_remove_all_plan_by_job_ids(jobIds, svcType)
        self.recv_remove_all_plan_by_job_ids()

    def send_remove_all_plan_by_job_ids(self, jobIds, svcType):
        self._oprot.writeMessageBegin('remove_all_plan_by_job_ids', TMessageType.CALL, self._seqid)
        args = remove_all_plan_by_job_ids_args()
        args.jobIds = jobIds
        args.svcType = svcType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_all_plan_by_job_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_all_plan_by_job_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_next_run_sche_by_job_id(self, jobIdList, svcType):
        """
           * 根据任务id批量得到下次计划时间
        * jobId 任务
        * svcType
           * @ throw ncException

        Parameters:
         - jobIdList
         - svcType

        """
        self.send_get_next_run_sche_by_job_id(jobIdList, svcType)
        return self.recv_get_next_run_sche_by_job_id()

    def send_get_next_run_sche_by_job_id(self, jobIdList, svcType):
        self._oprot.writeMessageBegin('get_next_run_sche_by_job_id', TMessageType.CALL, self._seqid)
        args = get_next_run_sche_by_job_id_args()
        args.jobIdList = jobIdList
        args.svcType = svcType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_next_run_sche_by_job_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_next_run_sche_by_job_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_run_sche_by_job_id failed: unknown result")

    def verify_plan_exists(self, planId):
        """
           * 检测计划任务是否存在
        * planId 计划任务总数

        Parameters:
         - planId

        """
        self.send_verify_plan_exists(planId)
        return self.recv_verify_plan_exists()

    def send_verify_plan_exists(self, planId):
        self._oprot.writeMessageBegin('verify_plan_exists', TMessageType.CALL, self._seqid)
        args = verify_plan_exists_args()
        args.planId = planId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verify_plan_exists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verify_plan_exists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verify_plan_exists failed: unknown result")

    def get_all_sches_in_node(self, real):
        """
           * 得到某个节点上的所有计划
           * real true:正在运行的计划，false: 数据库中的计划
        * return 返回结果

        Parameters:
         - real

        """
        self.send_get_all_sches_in_node(real)
        return self.recv_get_all_sches_in_node()

    def send_get_all_sches_in_node(self, real):
        self._oprot.writeMessageBegin('get_all_sches_in_node', TMessageType.CALL, self._seqid)
        args = get_all_sches_in_node_args()
        args.real = real
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_sches_in_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_sches_in_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_sches_in_node failed: unknown result")

    def get_db_instance(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_instance(request)
        return self.recv_get_db_instance()

    def send_get_db_instance(self, request):
        self._oprot.writeMessageBegin('get_db_instance', TMessageType.CALL, self._seqid)
        args = get_db_instance_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_instance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_instance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_instance failed: unknown result")

    def get_db_instances(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_db_instances(request)
        return self.recv_get_db_instances()

    def send_get_db_instances(self, request):
        self._oprot.writeMessageBegin('get_db_instances', TMessageType.CALL, self._seqid)
        args = get_db_instances_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_db_instances(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_db_instances_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_instances failed: unknown result")

    def get_datasource_client_info(self, clientId):
        """
        Parameters:
         - clientId

        """
        self.send_get_datasource_client_info(clientId)
        return self.recv_get_datasource_client_info()

    def send_get_datasource_client_info(self, clientId):
        self._oprot.writeMessageBegin('get_datasource_client_info', TMessageType.CALL, self._seqid)
        args = get_datasource_client_info_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_datasource_client_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_datasource_client_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_datasource_client_info failed: unknown result")

    def get_server_by_ip(self, ip):
        """
        根据ip获取server
        ip: 服务器ip
        retur ncServer


        Parameters:
         - ip

        """
        self.send_get_server_by_ip(ip)
        return self.recv_get_server_by_ip()

    def send_get_server_by_ip(self, ip):
        self._oprot.writeMessageBegin('get_server_by_ip', TMessageType.CALL, self._seqid)
        args = get_server_by_ip_args()
        args.ip = ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server_by_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_by_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server_by_ip failed: unknown result")

    def get_available_child_clients(self, nc_parent_client, filter_parameter):
        """
        获取某一虚拟客户端下可用的子物理客户端(提供某种筛选条件)

        Parameters:
         - nc_parent_client
         - filter_parameter

        """
        self.send_get_available_child_clients(nc_parent_client, filter_parameter)
        return self.recv_get_available_child_clients()

    def send_get_available_child_clients(self, nc_parent_client, filter_parameter):
        self._oprot.writeMessageBegin('get_available_child_clients', TMessageType.CALL, self._seqid)
        args = get_available_child_clients_args()
        args.nc_parent_client = nc_parent_client
        args.filter_parameter = filter_parameter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_available_child_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_available_child_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_available_child_clients failed: unknown result")

    def get_all_child_clients(self, nc_parent_client, filter_parameter):
        """
        获取某一虚拟客户端下所有的子物理客户端

        Parameters:
         - nc_parent_client
         - filter_parameter

        """
        self.send_get_all_child_clients(nc_parent_client, filter_parameter)
        return self.recv_get_all_child_clients()

    def send_get_all_child_clients(self, nc_parent_client, filter_parameter):
        self._oprot.writeMessageBegin('get_all_child_clients', TMessageType.CALL, self._seqid)
        args = get_all_child_clients_args()
        args.nc_parent_client = nc_parent_client
        args.filter_parameter = filter_parameter
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_child_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_child_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_child_clients failed: unknown result")

    def get_parent_clients(self, clientId):
        """
        Parameters:
         - clientId

        """
        self.send_get_parent_clients(clientId)
        return self.recv_get_parent_clients()

    def send_get_parent_clients(self, clientId):
        self._oprot.writeMessageBegin('get_parent_clients', TMessageType.CALL, self._seqid)
        args = get_parent_clients_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_parent_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_parent_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_parent_clients failed: unknown result")

    def get_hadoop_info(self, nc_parent_client):
        """
        Parameters:
         - nc_parent_client

        """
        self.send_get_hadoop_info(nc_parent_client)
        return self.recv_get_hadoop_info()

    def send_get_hadoop_info(self, nc_parent_client):
        self._oprot.writeMessageBegin('get_hadoop_info', TMessageType.CALL, self._seqid)
        args = get_hadoop_info_args()
        args.nc_parent_client = nc_parent_client
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_hadoop_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_hadoop_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_hadoop_info failed: unknown result")

    def get_mongodb_client_info(self, parent_client_id, child_client_id):
        """
        Parameters:
         - parent_client_id
         - child_client_id

        """
        self.send_get_mongodb_client_info(parent_client_id, child_client_id)
        return self.recv_get_mongodb_client_info()

    def send_get_mongodb_client_info(self, parent_client_id, child_client_id):
        self._oprot.writeMessageBegin('get_mongodb_client_info', TMessageType.CALL, self._seqid)
        args = get_mongodb_client_info_args()
        args.parent_client_id = parent_client_id
        args.child_client_id = child_client_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_mongodb_client_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_mongodb_client_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_mongodb_client_info failed: unknown result")

    def client_authorize(self, cliDisReq):
        """
        用户分配and回收


        Parameters:
         - cliDisReq

        """
        self.send_client_authorize(cliDisReq)
        return self.recv_client_authorize()

    def send_client_authorize(self, cliDisReq):
        self._oprot.writeMessageBegin('client_authorize', TMessageType.CALL, self._seqid)
        args = client_authorize_args()
        args.cliDisReq = cliDisReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_authorize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_authorize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "client_authorize failed: unknown result")

    def platform_authorize(self, platDisReq):
        """
        平台回收或者分配


        Parameters:
         - platDisReq

        """
        self.send_platform_authorize(platDisReq)
        return self.recv_platform_authorize()

    def send_platform_authorize(self, platDisReq):
        self._oprot.writeMessageBegin('platform_authorize', TMessageType.CALL, self._seqid)
        args = platform_authorize_args()
        args.platDisReq = platDisReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_platform_authorize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = platform_authorize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "platform_authorize failed: unknown result")

    def get_servers(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_servers(request)
        return self.recv_get_servers()

    def send_get_servers(self, request):
        self._oprot.writeMessageBegin('get_servers', TMessageType.CALL, self._seqid)
        args = get_servers_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_servers failed: unknown result")

    def del_auth_users_task(self, authReq):
        """
        删除用户所有关联


        Parameters:
         - authReq

        """
        self.send_del_auth_users_task(authReq)
        return self.recv_del_auth_users_task()

    def send_del_auth_users_task(self, authReq):
        self._oprot.writeMessageBegin('del_auth_users_task', TMessageType.CALL, self._seqid)
        args = del_auth_users_task_args()
        args.authReq = authReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_del_auth_users_task(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = del_auth_users_task_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.errors is not None:
            raise result.errors
        raise TApplicationException(TApplicationException.MISSING_RESULT, "del_auth_users_task failed: unknown result")

    def update_state_auth_users_task(self, authReq, state):
        """
        禁用or启用用户所有关联


        Parameters:
         - authReq
         - state

        """
        self.send_update_state_auth_users_task(authReq, state)
        return self.recv_update_state_auth_users_task()

    def send_update_state_auth_users_task(self, authReq, state):
        self._oprot.writeMessageBegin('update_state_auth_users_task', TMessageType.CALL, self._seqid)
        args = update_state_auth_users_task_args()
        args.authReq = authReq
        args.state = state
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_state_auth_users_task(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_state_auth_users_task_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.errors is not None:
            raise result.errors
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_state_auth_users_task failed: unknown result")

    def get_strategy(self, strategyId):
        """
           * 得到cdm策略信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId

        """
        self.send_get_strategy(strategyId)
        return self.recv_get_strategy()

    def send_get_strategy(self, strategyId):
        self._oprot.writeMessageBegin('get_strategy', TMessageType.CALL, self._seqid)
        args = get_strategy_args()
        args.strategyId = strategyId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_strategy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_strategy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_strategy failed: unknown result")

    def get_strategy_by_name_and_job_type(self, strategy_name, job_type):
        """
           * 得到cdm策略信息
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategy_name
         - job_type

        """
        self.send_get_strategy_by_name_and_job_type(strategy_name, job_type)
        return self.recv_get_strategy_by_name_and_job_type()

    def send_get_strategy_by_name_and_job_type(self, strategy_name, job_type):
        self._oprot.writeMessageBegin('get_strategy_by_name_and_job_type', TMessageType.CALL, self._seqid)
        args = get_strategy_by_name_and_job_type_args()
        args.strategy_name = strategy_name
        args.job_type = job_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_strategy_by_name_and_job_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_strategy_by_name_and_job_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_strategy_by_name_and_job_type failed: unknown result")

    def create_strategy_schedule(self, strategyId, job_id, begin_time):
        """
           * 创建cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId
         - job_id
         - begin_time

        """
        self.send_create_strategy_schedule(strategyId, job_id, begin_time)
        self.recv_create_strategy_schedule()

    def send_create_strategy_schedule(self, strategyId, job_id, begin_time):
        self._oprot.writeMessageBegin('create_strategy_schedule', TMessageType.CALL, self._seqid)
        args = create_strategy_schedule_args()
        args.strategyId = strategyId
        args.job_id = job_id
        args.begin_time = begin_time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_strategy_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_strategy_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def modify_strategy_schedule(self, strategyId, job_id, begin_time):
        """
           * 更新cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - strategyId
         - job_id
         - begin_time

        """
        self.send_modify_strategy_schedule(strategyId, job_id, begin_time)
        self.recv_modify_strategy_schedule()

    def send_modify_strategy_schedule(self, strategyId, job_id, begin_time):
        self._oprot.writeMessageBegin('modify_strategy_schedule', TMessageType.CALL, self._seqid)
        args = modify_strategy_schedule_args()
        args.strategyId = strategyId
        args.job_id = job_id
        args.begin_time = begin_time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_strategy_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_strategy_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def new_modify_strategy_schedule(self, schedules):
        """
           * 更新cdm策略调度(只编辑计划)
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - schedules

        """
        self.send_new_modify_strategy_schedule(schedules)
        self.recv_new_modify_strategy_schedule()

    def send_new_modify_strategy_schedule(self, schedules):
        self._oprot.writeMessageBegin('new_modify_strategy_schedule', TMessageType.CALL, self._seqid)
        args = new_modify_strategy_schedule_args()
        args.schedules = schedules
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_new_modify_strategy_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = new_modify_strategy_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_strategy_schedule(self, job_id, host_id):
        """
           * 删除cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - job_id
         - host_id

        """
        self.send_delete_strategy_schedule(job_id, host_id)
        self.recv_delete_strategy_schedule()

    def send_delete_strategy_schedule(self, job_id, host_id):
        self._oprot.writeMessageBegin('delete_strategy_schedule', TMessageType.CALL, self._seqid)
        args = delete_strategy_schedule_args()
        args.job_id = job_id
        args.host_id = host_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_strategy_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_strategy_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_cur_strategy_schedule(self, plan_id_list):
        """
           * 删除当前节点cdm策略调度
        * return ncTScheTaskInfo
           * @ throw ncException

        Parameters:
         - plan_id_list

        """
        self.send_delete_cur_strategy_schedule(plan_id_list)
        self.recv_delete_cur_strategy_schedule()

    def send_delete_cur_strategy_schedule(self, plan_id_list):
        self._oprot.writeMessageBegin('delete_cur_strategy_schedule', TMessageType.CALL, self._seqid)
        args = delete_cur_strategy_schedule_args()
        args.plan_id_list = plan_id_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_cur_strategy_schedule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_cur_strategy_schedule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_clientid_nctclient(self, request):
        """
        根据一组筛选条件, 筛选一组客户端( 接口命名, 体现了返回值是一个map)

        注: 筛选条件, 尽量映射到Django ORM的术语

        Parameters:
         - request

        """
        self.send_get_clientid_nctclient(request)
        return self.recv_get_clientid_nctclient()

    def send_get_clientid_nctclient(self, request):
        self._oprot.writeMessageBegin('get_clientid_nctclient', TMessageType.CALL, self._seqid)
        args = get_clientid_nctclient_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clientid_nctclient(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clientid_nctclient_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clientid_nctclient failed: unknown result")

    def get_client_configs_by_client_id(self, clientId):
        """
        获取指定客户端配置信息
        @ throw ncException

        Parameters:
         - clientId

        """
        self.send_get_client_configs_by_client_id(clientId)
        return self.recv_get_client_configs_by_client_id()

    def send_get_client_configs_by_client_id(self, clientId):
        self._oprot.writeMessageBegin('get_client_configs_by_client_id', TMessageType.CALL, self._seqid)
        args = get_client_configs_by_client_id_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_configs_by_client_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_configs_by_client_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_configs_by_client_id failed: unknown result")

    def get_fp_user_status(self, fp_id, user_name):
        """
           * 获取指纹池状态
        * return fpStatus
        * @throw ncException

        Parameters:
         - fp_id
         - user_name

        """
        self.send_get_fp_user_status(fp_id, user_name)
        return self.recv_get_fp_user_status()

    def send_get_fp_user_status(self, fp_id, user_name):
        self._oprot.writeMessageBegin('get_fp_user_status', TMessageType.CALL, self._seqid)
        args = get_fp_user_status_args()
        args.fp_id = fp_id
        args.user_name = user_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fp_user_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fp_user_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fp_user_status failed: unknown result")

    def get_fp_by_node_ip(self, node_ip):
        """
        获取该节点ip上是否拥有指纹池
        return fp
        @throw ncException

        Parameters:
         - node_ip

        """
        self.send_get_fp_by_node_ip(node_ip)
        return self.recv_get_fp_by_node_ip()

    def send_get_fp_by_node_ip(self, node_ip):
        self._oprot.writeMessageBegin('get_fp_by_node_ip', TMessageType.CALL, self._seqid)
        args = get_fp_by_node_ip_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fp_by_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fp_by_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fp_by_node_ip failed: unknown result")

    def get_contentcloudresourceid_resourceobj(self, request):
        """
        Parameters:
         - request

        """
        self.send_get_contentcloudresourceid_resourceobj(request)
        return self.recv_get_contentcloudresourceid_resourceobj()

    def send_get_contentcloudresourceid_resourceobj(self, request):
        self._oprot.writeMessageBegin('get_contentcloudresourceid_resourceobj', TMessageType.CALL, self._seqid)
        args = get_contentcloudresourceid_resourceobj_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_contentcloudresourceid_resourceobj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_contentcloudresourceid_resourceobj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_contentcloudresourceid_resourceobj failed: unknown result")

    def get_username_by_flguid(self, flguid):
        """
        获取指纹库所属用户名
        return username
        @throw ncException

        Parameters:
         - flguid

        """
        self.send_get_username_by_flguid(flguid)
        return self.recv_get_username_by_flguid()

    def send_get_username_by_flguid(self, flguid):
        self._oprot.writeMessageBegin('get_username_by_flguid', TMessageType.CALL, self._seqid)
        args = get_username_by_flguid_args()
        args.flguid = flguid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_username_by_flguid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_username_by_flguid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_username_by_flguid failed: unknown result")

    def delete_recovery_client(self, client_id):
        """
        删除恢复任务相关客户端记录
        @throw ncException

        Parameters:
         - client_id

        """
        self.send_delete_recovery_client(client_id)
        self.recv_delete_recovery_client()

    def send_delete_recovery_client(self, client_id):
        self._oprot.writeMessageBegin('delete_recovery_client', TMessageType.CALL, self._seqid)
        args = delete_recovery_client_args()
        args.client_id = client_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_recovery_client(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_recovery_client_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def delete_recovery_clients(self, client_ids):
        """
        批量删除恢复任务相关客户端记录
        @throw ncException

        Parameters:
         - client_ids

        """
        self.send_delete_recovery_clients(client_ids)
        self.recv_delete_recovery_clients()

    def send_delete_recovery_clients(self, client_ids):
        self._oprot.writeMessageBegin('delete_recovery_clients', TMessageType.CALL, self._seqid)
        args = delete_recovery_clients_args()
        args.client_ids = client_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_recovery_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_recovery_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_job_message_for_ams(self, jobId, msgMethod):
        """
        更改任务时，发送消息到AMS
        包括任务新增，更新任务状态，对任务进行编辑
        @throw ncException

        Parameters:
         - jobId
         - msgMethod

        """
        self.send_update_job_message_for_ams(jobId, msgMethod)
        self.recv_update_job_message_for_ams()

    def send_update_job_message_for_ams(self, jobId, msgMethod):
        self._oprot.writeMessageBegin('update_job_message_for_ams', TMessageType.CALL, self._seqid)
        args = update_job_message_for_ams_args()
        args.jobId = jobId
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_job_message_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_job_message_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def add_recovery_job_for_ams(self, jobId):
        """
        创建数据恢复任务时，发送消息到AMS
        @throw ncException

        Parameters:
         - jobId

        """
        self.send_add_recovery_job_for_ams(jobId)
        self.recv_add_recovery_job_for_ams()

    def send_add_recovery_job_for_ams(self, jobId):
        self._oprot.writeMessageBegin('add_recovery_job_for_ams', TMessageType.CALL, self._seqid)
        args = add_recovery_job_for_ams_args()
        args.jobId = jobId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_recovery_job_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_recovery_job_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_task_log_message(self, instanceId, msgMethod):
        """
        执行任务时，将任务执行记录发送至AMS
        @throw ncException

        Parameters:
         - instanceId
         - msgMethod

        """
        self.send_get_task_log_message(instanceId, msgMethod)
        self.recv_get_task_log_message()

    def send_get_task_log_message(self, instanceId, msgMethod):
        self._oprot.writeMessageBegin('get_task_log_message', TMessageType.CALL, self._seqid)
        args = get_task_log_message_args()
        args.instanceId = instanceId
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_task_log_message(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_task_log_message_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_delete_job_message(self, taskId):
        """
        删除任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - taskId

        """
        self.send_get_delete_job_message(taskId)
        self.recv_get_delete_job_message()

    def send_get_delete_job_message(self, taskId):
        self._oprot.writeMessageBegin('get_delete_job_message', TMessageType.CALL, self._seqid)
        args = get_delete_job_message_args()
        args.taskId = taskId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_delete_job_message(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_delete_job_message_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def create_clean_job(self, clean_job):
        """
        创建数据清理任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - clean_job

        """
        self.send_create_clean_job(clean_job)
        self.recv_create_clean_job()

    def send_create_clean_job(self, clean_job):
        self._oprot.writeMessageBegin('create_clean_job', TMessageType.CALL, self._seqid)
        args = create_clean_job_args()
        args.clean_job = clean_job
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_clean_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_clean_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_remote_job_log(self, jobInstance, msgMethod):
        """
        更新远程复制执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        self.send_update_remote_job_log(jobInstance, msgMethod)
        self.recv_update_remote_job_log()

    def send_update_remote_job_log(self, jobInstance, msgMethod):
        self._oprot.writeMessageBegin('update_remote_job_log', TMessageType.CALL, self._seqid)
        args = update_remote_job_log_args()
        args.jobInstance = jobInstance
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_remote_job_log(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_remote_job_log_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_remote_job(self, job, msgMethod):
        """
        更新远程复制任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        self.send_update_remote_job(job, msgMethod)
        self.recv_update_remote_job()

    def send_update_remote_job(self, job, msgMethod):
        self._oprot.writeMessageBegin('update_remote_job', TMessageType.CALL, self._seqid)
        args = update_remote_job_args()
        args.job = job
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_remote_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_remote_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_cdm_backup_job(self, job, msgMethod):
        """
        更新cdm数据备份任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        self.send_update_cdm_backup_job(job, msgMethod)
        self.recv_update_cdm_backup_job()

    def send_update_cdm_backup_job(self, job, msgMethod):
        self._oprot.writeMessageBegin('update_cdm_backup_job', TMessageType.CALL, self._seqid)
        args = update_cdm_backup_job_args()
        args.job = job
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdm_backup_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdm_backup_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_cdm_backup_job_history(self, jobInstance, msgMethod):
        """
        更新cdm数据备份任务执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        self.send_update_cdm_backup_job_history(jobInstance, msgMethod)
        self.recv_update_cdm_backup_job_history()

    def send_update_cdm_backup_job_history(self, jobInstance, msgMethod):
        self._oprot.writeMessageBegin('update_cdm_backup_job_history', TMessageType.CALL, self._seqid)
        args = update_cdm_backup_job_history_args()
        args.jobInstance = jobInstance
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdm_backup_job_history(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdm_backup_job_history_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_cdm_mount_job(self, job, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        self.send_update_cdm_mount_job(job, msgMethod)
        self.recv_update_cdm_mount_job()

    def send_update_cdm_mount_job(self, job, msgMethod):
        self._oprot.writeMessageBegin('update_cdm_mount_job', TMessageType.CALL, self._seqid)
        args = update_cdm_mount_job_args()
        args.job = job
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdm_mount_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdm_mount_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_cdp_job(self, job, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - job
         - msgMethod

        """
        self.send_update_cdp_job(job, msgMethod)
        self.recv_update_cdp_job()

    def send_update_cdp_job(self, job, msgMethod):
        self._oprot.writeMessageBegin('update_cdp_job', TMessageType.CALL, self._seqid)
        args = update_cdp_job_args()
        args.job = job
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdp_job(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdp_job_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def update_cdp_job_instance(self, jobInstance, msgMethod):
        """
        更新cdm数据访问任务时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        self.send_update_cdp_job_instance(jobInstance, msgMethod)
        self.recv_update_cdp_job_instance()

    def send_update_cdp_job_instance(self, jobInstance, msgMethod):
        self._oprot.writeMessageBegin('update_cdp_job_instance', TMessageType.CALL, self._seqid)
        args = update_cdp_job_instance_args()
        args.jobInstance = jobInstance
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdp_job_instance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdp_job_instance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def project_user_authorize(self, projectUserDisReq):
        """
        租户回收或者分配


        Parameters:
         - projectUserDisReq

        """
        self.send_project_user_authorize(projectUserDisReq)
        return self.recv_project_user_authorize()

    def send_project_user_authorize(self, projectUserDisReq):
        self._oprot.writeMessageBegin('project_user_authorize', TMessageType.CALL, self._seqid)
        args = project_user_authorize_args()
        args.projectUserDisReq = projectUserDisReq
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_project_user_authorize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = project_user_authorize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "project_user_authorize failed: unknown result")

    def get_newest_projectuser(self, projectuserIds, decrypt):
        """
        获取租户列表
        @ throw ncException

        Parameters:
         - projectuserIds
         - decrypt

        """
        self.send_get_newest_projectuser(projectuserIds, decrypt)
        return self.recv_get_newest_projectuser()

    def send_get_newest_projectuser(self, projectuserIds, decrypt):
        self._oprot.writeMessageBegin('get_newest_projectuser', TMessageType.CALL, self._seqid)
        args = get_newest_projectuser_args()
        args.projectuserIds = projectuserIds
        args.decrypt = decrypt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_newest_projectuser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_newest_projectuser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_newest_projectuser failed: unknown result")

    def get_newest_projectstorage(self, projectId):
        """
        获取租户关联的存储信息
        @ throw ncException

        Parameters:
         - projectId

        """
        self.send_get_newest_projectstorage(projectId)
        return self.recv_get_newest_projectstorage()

    def send_get_newest_projectstorage(self, projectId):
        self._oprot.writeMessageBegin('get_newest_projectstorage', TMessageType.CALL, self._seqid)
        args = get_newest_projectstorage_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_newest_projectstorage(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_newest_projectstorage_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_newest_projectstorage failed: unknown result")

    def update_cdm_mount_job_instance(self, jobInstance, msgMethod):
        """
        更新cdm数据访问任务执行记录时，给AMS推送消息
        @throw ncException

        Parameters:
         - jobInstance
         - msgMethod

        """
        self.send_update_cdm_mount_job_instance(jobInstance, msgMethod)
        self.recv_update_cdm_mount_job_instance()

    def send_update_cdm_mount_job_instance(self, jobInstance, msgMethod):
        self._oprot.writeMessageBegin('update_cdm_mount_job_instance', TMessageType.CALL, self._seqid)
        args = update_cdm_mount_job_instance_args()
        args.jobInstance = jobInstance
        args.msgMethod = msgMethod
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_cdm_mount_job_instance(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_cdm_mount_job_instance_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_client_count_by_auth_user(self, username):
        """
        Parameters:
         - username

        """
        self.send_get_client_count_by_auth_user(username)
        return self.recv_get_client_count_by_auth_user()

    def send_get_client_count_by_auth_user(self, username):
        self._oprot.writeMessageBegin('get_client_count_by_auth_user', TMessageType.CALL, self._seqid)
        args = get_client_count_by_auth_user_args()
        args.username = username
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_count_by_auth_user(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_count_by_auth_user_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_count_by_auth_user failed: unknown result")

    def get_clients_by_vir_platform(self, vir_platform_id):
        """
        获取虚拟化平台绑定的客户端
         return ncTClient
         @throw ncException

        Parameters:
         - vir_platform_id

        """
        self.send_get_clients_by_vir_platform(vir_platform_id)
        return self.recv_get_clients_by_vir_platform()

    def send_get_clients_by_vir_platform(self, vir_platform_id):
        self._oprot.writeMessageBegin('get_clients_by_vir_platform', TMessageType.CALL, self._seqid)
        args = get_clients_by_vir_platform_args()
        args.vir_platform_id = vir_platform_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_clients_by_vir_platform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_clients_by_vir_platform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clients_by_vir_platform failed: unknown result")

    def get_client_by_vir_platform_and_node(self, vir_platform_id, node_id):
        """
        通过平台id，节点id,获取虚拟化平台绑定的客户端
         return ncTClient
         @throw ncException

        Parameters:
         - vir_platform_id
         - node_id

        """
        self.send_get_client_by_vir_platform_and_node(vir_platform_id, node_id)
        return self.recv_get_client_by_vir_platform_and_node()

    def send_get_client_by_vir_platform_and_node(self, vir_platform_id, node_id):
        self._oprot.writeMessageBegin('get_client_by_vir_platform_and_node', TMessageType.CALL, self._seqid)
        args = get_client_by_vir_platform_and_node_args()
        args.vir_platform_id = vir_platform_id
        args.node_id = node_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_by_vir_platform_and_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_by_vir_platform_and_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_by_vir_platform_and_node failed: unknown result")

    def get_data_for_ams(self, kwargs):
        """
        AMS获取数据接口


        Parameters:
         - kwargs

        """
        self.send_get_data_for_ams(kwargs)
        return self.recv_get_data_for_ams()

    def send_get_data_for_ams(self, kwargs):
        self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
        args = get_data_for_ams_args()
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_data_for_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_data_for_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

    def do_operation_from_ams(self, target, method, kwargs):
        """
        执行从AMS7.0下发的操作


        Parameters:
         - target
         - method
         - kwargs

        """
        self.send_do_operation_from_ams(target, method, kwargs)
        return self.recv_do_operation_from_ams()

    def send_do_operation_from_ams(self, target, method, kwargs):
        self._oprot.writeMessageBegin('do_operation_from_ams', TMessageType.CALL, self._seqid)
        args = do_operation_from_ams_args()
        args.target = target
        args.method = method
        args.kwargs = kwargs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_do_operation_from_ams(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = do_operation_from_ams_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "do_operation_from_ams failed: unknown result")

    def get_cluster_datasource(self, req):
        """
        Parameters:
         - req

        """
        self.send_get_cluster_datasource(req)
        return self.recv_get_cluster_datasource()

    def send_get_cluster_datasource(self, req):
        self._oprot.writeMessageBegin('get_cluster_datasource', TMessageType.CALL, self._seqid)
        args = get_cluster_datasource_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_datasource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_datasource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_cluster_datasource failed: unknown result")

    def get_virtual_machine_datasource(self, client_id, req):
        """
        Parameters:
         - client_id
         - req

        """
        self.send_get_virtual_machine_datasource(client_id, req)
        return self.recv_get_virtual_machine_datasource()

    def send_get_virtual_machine_datasource(self, client_id, req):
        self._oprot.writeMessageBegin('get_virtual_machine_datasource', TMessageType.CALL, self._seqid)
        args = get_virtual_machine_datasource_args()
        args.client_id = client_id
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_virtual_machine_datasource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_virtual_machine_datasource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_virtual_machine_datasource failed: unknown result")

    def get_client_by_ip_or_id(self, client_ip, client_id):
        """
        通过ip获取指定客户端
        @ throw ncException

        Parameters:
         - client_ip
         - client_id

        """
        self.send_get_client_by_ip_or_id(client_ip, client_id)
        return self.recv_get_client_by_ip_or_id()

    def send_get_client_by_ip_or_id(self, client_ip, client_id):
        self._oprot.writeMessageBegin('get_client_by_ip_or_id', TMessageType.CALL, self._seqid)
        args = get_client_by_ip_or_id_args()
        args.client_ip = client_ip
        args.client_id = client_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_by_ip_or_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_by_ip_or_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_by_ip_or_id failed: unknown result")

    def get_in_kvm_platform(self):
        """
        获取内置虚拟化平台信息（KVM）


        """
        self.send_get_in_kvm_platform()
        return self.recv_get_in_kvm_platform()

    def send_get_in_kvm_platform(self):
        self._oprot.writeMessageBegin('get_in_kvm_platform', TMessageType.CALL, self._seqid)
        args = get_in_kvm_platform_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_in_kvm_platform(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_in_kvm_platform_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_in_kvm_platform failed: unknown result")

    def update_or_create_fp_pool(self):
        """
        更新指纹池节点信息，若节点变化，则编辑指纹库


        """
        self.send_update_or_create_fp_pool()
        self.recv_update_or_create_fp_pool()

    def send_update_or_create_fp_pool(self):
        self._oprot.writeMessageBegin('update_or_create_fp_pool', TMessageType.CALL, self._seqid)
        args = update_or_create_fp_pool_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_or_create_fp_pool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_or_create_fp_pool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_client_type_by_id(self, clientId):
        """
        判断是不是内置客户端


        Parameters:
         - clientId

        """
        self.send_get_client_type_by_id(clientId)
        return self.recv_get_client_type_by_id()

    def send_get_client_type_by_id(self, clientId):
        self._oprot.writeMessageBegin('get_client_type_by_id', TMessageType.CALL, self._seqid)
        args = get_client_type_by_id_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_type_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_type_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_type_by_id failed: unknown result")

    def check_user_source(self, username, source):
        """
        判断客户端是否属于用户


        Parameters:
         - username
         - source

        """
        self.send_check_user_source(username, source)
        self.recv_check_user_source()

    def send_check_user_source(self, username, source):
        self._oprot.writeMessageBegin('check_user_source', TMessageType.CALL, self._seqid)
        args = check_user_source_args()
        args.username = username
        args.source = source
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_user_source(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_user_source_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_server_by_client_ip(self, ip):
        """
        根据客户端ip获取server
        ip: 客户端ip
        return ncServer


        Parameters:
         - ip

        """
        self.send_get_server_by_client_ip(ip)
        return self.recv_get_server_by_client_ip()

    def send_get_server_by_client_ip(self, ip):
        self._oprot.writeMessageBegin('get_server_by_client_ip', TMessageType.CALL, self._seqid)
        args = get_server_by_client_ip_args()
        args.ip = ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server_by_client_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_by_client_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server_by_client_ip failed: unknown result")

    def get_client_link_type(self, configId, hostId, wwn):
        """
        根据客户端配置信息id获取客户端id
        configId: 客户端配置信息id
        hostId: 客户端id
        wwn: 客户端对应的链路信息
        return bool


        Parameters:
         - configId
         - hostId
         - wwn

        """
        self.send_get_client_link_type(configId, hostId, wwn)
        return self.recv_get_client_link_type()

    def send_get_client_link_type(self, configId, hostId, wwn):
        self._oprot.writeMessageBegin('get_client_link_type', TMessageType.CALL, self._seqid)
        args = get_client_link_type_args()
        args.configId = configId
        args.hostId = hostId
        args.wwn = wwn
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_link_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_link_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_client_link_type failed: unknown result")

    def get_virtual_safety_users(self, infos):
        """
        Parameters:
         - infos

        """
        self.send_get_virtual_safety_users(infos)
        return self.recv_get_virtual_safety_users()

    def send_get_virtual_safety_users(self, infos):
        self._oprot.writeMessageBegin('get_virtual_safety_users', TMessageType.CALL, self._seqid)
        args = get_virtual_safety_users_args()
        args.infos = infos
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_virtual_safety_users(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_virtual_safety_users_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_virtual_safety_users failed: unknown result")

    def get_all_clients_to_log(self, user_id):
        """
        Parameters:
         - user_id

        """
        self.send_get_all_clients_to_log(user_id)
        return self.recv_get_all_clients_to_log()

    def send_get_all_clients_to_log(self, user_id):
        self._oprot.writeMessageBegin('get_all_clients_to_log', TMessageType.CALL, self._seqid)
        args = get_all_clients_to_log_args()
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_clients_to_log(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_clients_to_log_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_clients_to_log failed: unknown result")

    def get_fp_node_info_by_node_ip(self, node_ip):
        """
        获取该节点指纹池信息
        return fp
        @throw ncException

        Parameters:
         - node_ip

        """
        self.send_get_fp_node_info_by_node_ip(node_ip)
        return self.recv_get_fp_node_info_by_node_ip()

    def send_get_fp_node_info_by_node_ip(self, node_ip):
        self._oprot.writeMessageBegin('get_fp_node_info_by_node_ip', TMessageType.CALL, self._seqid)
        args = get_fp_node_info_by_node_ip_args()
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fp_node_info_by_node_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fp_node_info_by_node_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fp_node_info_by_node_ip failed: unknown result")

    def get_fl_by_fpoor_id(self, fp_id):
        """
        *
        * 通过指纹池id判断时候有指纹库
        *
           *

        Parameters:
         - fp_id

        """
        self.send_get_fl_by_fpoor_id(fp_id)
        return self.recv_get_fl_by_fpoor_id()

    def send_get_fl_by_fpoor_id(self, fp_id):
        self._oprot.writeMessageBegin('get_fl_by_fpoor_id', TMessageType.CALL, self._seqid)
        args = get_fl_by_fpoor_id_args()
        args.fp_id = fp_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fl_by_fpoor_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fl_by_fpoor_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fl_by_fpoor_id failed: unknown result")

    def update_finger_poor_nodes(self, fp_id, node_ip):
        """
        *
        删除指纹池相关节点更新数据


        Parameters:
         - fp_id
         - node_ip

        """
        self.send_update_finger_poor_nodes(fp_id, node_ip)
        self.recv_update_finger_poor_nodes()

    def send_update_finger_poor_nodes(self, fp_id, node_ip):
        self._oprot.writeMessageBegin('update_finger_poor_nodes', TMessageType.CALL, self._seqid)
        args = update_finger_poor_nodes_args()
        args.fp_id = fp_id
        args.node_ip = node_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_finger_poor_nodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_finger_poor_nodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_fl_guid_ids_by_fp_id(self, fp_id):
        """
        *
        获取指纹池关联的所有指纹库编号


        Parameters:
         - fp_id

        """
        self.send_get_fl_guid_ids_by_fp_id(fp_id)
        return self.recv_get_fl_guid_ids_by_fp_id()

    def send_get_fl_guid_ids_by_fp_id(self, fp_id):
        self._oprot.writeMessageBegin('get_fl_guid_ids_by_fp_id', TMessageType.CALL, self._seqid)
        args = get_fl_guid_ids_by_fp_id_args()
        args.fp_id = fp_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fl_guid_ids_by_fp_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fl_guid_ids_by_fp_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fl_guid_ids_by_fp_id failed: unknown result")

    def get_protect_object_count(self, user):
        """
        *
        获取保护对象数量


        Parameters:
         - user

        """
        self.send_get_protect_object_count(user)
        return self.recv_get_protect_object_count()

    def send_get_protect_object_count(self, user):
        self._oprot.writeMessageBegin('get_protect_object_count', TMessageType.CALL, self._seqid)
        args = get_protect_object_count_args()
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_protect_object_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_protect_object_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_protect_object_count failed: unknown result")

    def update_clients(self, clientId, customer, clusterPort):
        """
        Parameters:
         - clientId
         - customer
         - clusterPort

        """
        self.send_update_clients(clientId, customer, clusterPort)
        self.recv_update_clients()

    def send_update_clients(self, clientId, customer, clusterPort):
        self._oprot.writeMessageBegin('update_clients', TMessageType.CALL, self._seqid)
        args = update_clients_args()
        args.clientId = clientId
        args.customer = customer
        args.clusterPort = clusterPort
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_clients(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_clients_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_fp_data_by_primary_key_id(self, primary_key_id):
        """
        *
        根据表FingerPoors主键值获取对应的指纹池数据


        Parameters:
         - primary_key_id

        """
        self.send_get_fp_data_by_primary_key_id(primary_key_id)
        return self.recv_get_fp_data_by_primary_key_id()

    def send_get_fp_data_by_primary_key_id(self, primary_key_id):
        self._oprot.writeMessageBegin('get_fp_data_by_primary_key_id', TMessageType.CALL, self._seqid)
        args = get_fp_data_by_primary_key_id_args()
        args.primary_key_id = primary_key_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fp_data_by_primary_key_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fp_data_by_primary_key_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fp_data_by_primary_key_id failed: unknown result")

    def get_backup_cloud_jobs(self, query_all):
        """
        *
        获取云备份任务


        Parameters:
         - query_all

        """
        self.send_get_backup_cloud_jobs(query_all)
        return self.recv_get_backup_cloud_jobs()

    def send_get_backup_cloud_jobs(self, query_all):
        self._oprot.writeMessageBegin('get_backup_cloud_jobs', TMessageType.CALL, self._seqid)
        args = get_backup_cloud_jobs_args()
        args.query_all = query_all
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backup_cloud_jobs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backup_cloud_jobs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backup_cloud_jobs failed: unknown result")

    def get_projectuser_list(self, cplatform_types):
        """
        获取云平台租户列表

        Parameters:
         - cplatform_types

        """
        self.send_get_projectuser_list(cplatform_types)
        return self.recv_get_projectuser_list()

    def send_get_projectuser_list(self, cplatform_types):
        self._oprot.writeMessageBegin('get_projectuser_list', TMessageType.CALL, self._seqid)
        args = get_projectuser_list_args()
        args.cplatform_types = cplatform_types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_projectuser_list(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_projectuser_list_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_projectuser_list failed: unknown result")

    def get_all_protect_object(self):
        """
        *
        获取所有保护对象


        """
        self.send_get_all_protect_object()
        return self.recv_get_all_protect_object()

    def send_get_all_protect_object(self):
        self._oprot.writeMessageBegin('get_all_protect_object', TMessageType.CALL, self._seqid)
        args = get_all_protect_object_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_protect_object(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_protect_object_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_protect_object failed: unknown result")

    def abstract_public_interface(self, msg, body):
        """
        Parameters:
         - msg
         - body

        """
        self.send_abstract_public_interface(msg, body)
        return self.recv_abstract_public_interface()

    def send_abstract_public_interface(self, msg, body):
        self._oprot.writeMessageBegin('abstract_public_interface', TMessageType.CALL, self._seqid)
        args = abstract_public_interface_args()
        args.msg = msg
        args.body = body
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abstract_public_interface(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abstract_public_interface_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "abstract_public_interface failed: unknown result")

    def check_get_appsys(self, req):
        """
        *
        检测应用系统相关信息

        Parameters:
         - req

        """
        self.send_check_get_appsys(req)
        return self.recv_check_get_appsys()

    def send_check_get_appsys(self, req):
        self._oprot.writeMessageBegin('check_get_appsys', TMessageType.CALL, self._seqid)
        args = check_get_appsys_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_get_appsys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_get_appsys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_get_appsys failed: unknown result")

    def update_eceph_info(self, cinfo):
        """
        *
        更新 内容云关联灾备对象存储容量和状态， 状态优先

        Parameters:
         - cinfo

        """
        self.send_update_eceph_info(cinfo)
        self.recv_update_eceph_info()

    def send_update_eceph_info(self, cinfo):
        self._oprot.writeMessageBegin('update_eceph_info', TMessageType.CALL, self._seqid)
        args = update_eceph_info_args()
        args.cinfo = cinfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_eceph_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_eceph_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def modify_schedule_job_cur_node(self, strategy_id, job_id, begin_time, is_modify_strategy):
        """
           * 更新当前节点上的计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - strategy_id
         - job_id
         - begin_time
         - is_modify_strategy

        """
        self.send_modify_schedule_job_cur_node(strategy_id, job_id, begin_time, is_modify_strategy)
        self.recv_modify_schedule_job_cur_node()

    def send_modify_schedule_job_cur_node(self, strategy_id, job_id, begin_time, is_modify_strategy):
        self._oprot.writeMessageBegin('modify_schedule_job_cur_node', TMessageType.CALL, self._seqid)
        args = modify_schedule_job_cur_node_args()
        args.strategy_id = strategy_id
        args.job_id = job_id
        args.begin_time = begin_time
        args.is_modify_strategy = is_modify_strategy
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_schedule_job_cur_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_schedule_job_cur_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def check_user_has_data(self, user_list):
        """
        检测用户是否存在存储指纹池指纹库数据
        @ return 返回有存储数据的用户列表


        Parameters:
         - user_list

        """
        self.send_check_user_has_data(user_list)
        return self.recv_check_user_has_data()

    def send_check_user_has_data(self, user_list):
        self._oprot.writeMessageBegin('check_user_has_data', TMessageType.CALL, self._seqid)
        args = check_user_has_data_args()
        args.user_list = user_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_user_has_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_user_has_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_user_has_data failed: unknown result")

    def create_schedules_cur_node(self, schedules):
        """
           * 当前节点上的批量创建任务的计划
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        self.send_create_schedules_cur_node(schedules)
        self.recv_create_schedules_cur_node()

    def send_create_schedules_cur_node(self, schedules):
        self._oprot.writeMessageBegin('create_schedules_cur_node', TMessageType.CALL, self._seqid)
        args = create_schedules_cur_node_args()
        args.schedules = schedules
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_schedules_cur_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_schedules_cur_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def modify_job_schedules_cur_node(self, schedules):
        """
           * 更新任务时更新当前节点上的计划任务
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        self.send_modify_job_schedules_cur_node(schedules)
        self.recv_modify_job_schedules_cur_node()

    def send_modify_job_schedules_cur_node(self, schedules):
        self._oprot.writeMessageBegin('modify_job_schedules_cur_node', TMessageType.CALL, self._seqid)
        args = modify_job_schedules_cur_node_args()
        args.schedules = schedules
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modify_job_schedules_cur_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modify_job_schedules_cur_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.error is not None:
            raise result.error
        return

    def get_schedule_start_time(self, schedules):
        """
           * 根据计划id获取计划类型的最近一次发起时间
        * tScheTaskInfo   计划任务信息
        * return ncTScheTaskResult
           * @ throw ncException

        Parameters:
         - schedules

        """
        self.send_get_schedule_start_time(schedules)
        return self.recv_get_schedule_start_time()

    def send_get_schedule_start_time(self, schedules):
        self._oprot.writeMessageBegin('get_schedule_start_time', TMessageType.CALL, self._seqid)
        args = get_schedule_start_time_args()
        args.schedules = schedules
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schedule_start_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schedule_start_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schedule_start_time failed: unknown result")

    def get_public_cloud_resource(self, public_cloud_id):
        """
        根据id获取公有云资源

        @ throw ncException

        Parameters:
         - public_cloud_id

        """
        self.send_get_public_cloud_resource(public_cloud_id)
        return self.recv_get_public_cloud_resource()

    def send_get_public_cloud_resource(self, public_cloud_id):
        self._oprot.writeMessageBegin('get_public_cloud_resource', TMessageType.CALL, self._seqid)
        args = get_public_cloud_resource_args()
        args.public_cloud_id = public_cloud_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_public_cloud_resource(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_public_cloud_resource_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.error is not None:
            raise result.error
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_public_cloud_resource failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["microprobe"] = Processor.process_microprobe
        self._processMap["get_all_clients"] = Processor.process_get_all_clients
        self._processMap["get_available_internal_client"] = Processor.process_get_available_internal_client
        self._processMap["get_clients_by_macs"] = Processor.process_get_clients_by_macs
        self._processMap["get_clients_by_ids"] = Processor.process_get_clients_by_ids
        self._processMap["get_clients_by_id"] = Processor.process_get_clients_by_id
        self._processMap["get_storage_by_name"] = Processor.process_get_storage_by_name
        self._processMap["get_storages"] = Processor.process_get_storages
        self._processMap["get_storage_by_type"] = Processor.process_get_storage_by_type
        self._processMap["get_all_storages"] = Processor.process_get_all_storages
        self._processMap["get_client"] = Processor.process_get_client
        self._processMap["update_client"] = Processor.process_update_client
        self._processMap["get_client_by_mac"] = Processor.process_get_client_by_mac
        self._processMap["get_platforms_by_request_config"] = Processor.process_get_platforms_by_request_config
        self._processMap["get_newest_platform"] = Processor.process_get_newest_platform
        self._processMap["get_client_server_ip"] = Processor.process_get_client_server_ip
        self._processMap["commit_job"] = Processor.process_commit_job
        self._processMap["add_schedule_job"] = Processor.process_add_schedule_job
        self._processMap["remove_plans_in_cache"] = Processor.process_remove_plans_in_cache
        self._processMap["modify_schedule_job"] = Processor.process_modify_schedule_job
        self._processMap["modify_schedule_list_job"] = Processor.process_modify_schedule_list_job
        self._processMap["delete_schedule_jobs"] = Processor.process_delete_schedule_jobs
        self._processMap["update_schedule_jobs_state"] = Processor.process_update_schedule_jobs_state
        self._processMap["get_schedule_all_jobs"] = Processor.process_get_schedule_all_jobs
        self._processMap["get_schedule_job"] = Processor.process_get_schedule_job
        self._processMap["get_schedule_jobs"] = Processor.process_get_schedule_jobs
        self._processMap["get_schedule_depend_jobs"] = Processor.process_get_schedule_depend_jobs
        self._processMap["remove_all_plan_by_job_id"] = Processor.process_remove_all_plan_by_job_id
        self._processMap["remove_all_plan_by_job_ids"] = Processor.process_remove_all_plan_by_job_ids
        self._processMap["get_next_run_sche_by_job_id"] = Processor.process_get_next_run_sche_by_job_id
        self._processMap["verify_plan_exists"] = Processor.process_verify_plan_exists
        self._processMap["get_all_sches_in_node"] = Processor.process_get_all_sches_in_node
        self._processMap["get_db_instance"] = Processor.process_get_db_instance
        self._processMap["get_db_instances"] = Processor.process_get_db_instances
        self._processMap["get_datasource_client_info"] = Processor.process_get_datasource_client_info
        self._processMap["get_server_by_ip"] = Processor.process_get_server_by_ip
        self._processMap["get_available_child_clients"] = Processor.process_get_available_child_clients
        self._processMap["get_all_child_clients"] = Processor.process_get_all_child_clients
        self._processMap["get_parent_clients"] = Processor.process_get_parent_clients
        self._processMap["get_hadoop_info"] = Processor.process_get_hadoop_info
        self._processMap["get_mongodb_client_info"] = Processor.process_get_mongodb_client_info
        self._processMap["client_authorize"] = Processor.process_client_authorize
        self._processMap["platform_authorize"] = Processor.process_platform_authorize
        self._processMap["get_servers"] = Processor.process_get_servers
        self._processMap["del_auth_users_task"] = Processor.process_del_auth_users_task
        self._processMap["update_state_auth_users_task"] = Processor.process_update_state_auth_users_task
        self._processMap["get_strategy"] = Processor.process_get_strategy
        self._processMap["get_strategy_by_name_and_job_type"] = Processor.process_get_strategy_by_name_and_job_type
        self._processMap["create_strategy_schedule"] = Processor.process_create_strategy_schedule
        self._processMap["modify_strategy_schedule"] = Processor.process_modify_strategy_schedule
        self._processMap["new_modify_strategy_schedule"] = Processor.process_new_modify_strategy_schedule
        self._processMap["delete_strategy_schedule"] = Processor.process_delete_strategy_schedule
        self._processMap["delete_cur_strategy_schedule"] = Processor.process_delete_cur_strategy_schedule
        self._processMap["get_clientid_nctclient"] = Processor.process_get_clientid_nctclient
        self._processMap["get_client_configs_by_client_id"] = Processor.process_get_client_configs_by_client_id
        self._processMap["get_fp_user_status"] = Processor.process_get_fp_user_status
        self._processMap["get_fp_by_node_ip"] = Processor.process_get_fp_by_node_ip
        self._processMap["get_contentcloudresourceid_resourceobj"] = Processor.process_get_contentcloudresourceid_resourceobj
        self._processMap["get_username_by_flguid"] = Processor.process_get_username_by_flguid
        self._processMap["delete_recovery_client"] = Processor.process_delete_recovery_client
        self._processMap["delete_recovery_clients"] = Processor.process_delete_recovery_clients
        self._processMap["update_job_message_for_ams"] = Processor.process_update_job_message_for_ams
        self._processMap["add_recovery_job_for_ams"] = Processor.process_add_recovery_job_for_ams
        self._processMap["get_task_log_message"] = Processor.process_get_task_log_message
        self._processMap["get_delete_job_message"] = Processor.process_get_delete_job_message
        self._processMap["create_clean_job"] = Processor.process_create_clean_job
        self._processMap["update_remote_job_log"] = Processor.process_update_remote_job_log
        self._processMap["update_remote_job"] = Processor.process_update_remote_job
        self._processMap["update_cdm_backup_job"] = Processor.process_update_cdm_backup_job
        self._processMap["update_cdm_backup_job_history"] = Processor.process_update_cdm_backup_job_history
        self._processMap["update_cdm_mount_job"] = Processor.process_update_cdm_mount_job
        self._processMap["update_cdp_job"] = Processor.process_update_cdp_job
        self._processMap["update_cdp_job_instance"] = Processor.process_update_cdp_job_instance
        self._processMap["project_user_authorize"] = Processor.process_project_user_authorize
        self._processMap["get_newest_projectuser"] = Processor.process_get_newest_projectuser
        self._processMap["get_newest_projectstorage"] = Processor.process_get_newest_projectstorage
        self._processMap["update_cdm_mount_job_instance"] = Processor.process_update_cdm_mount_job_instance
        self._processMap["get_client_count_by_auth_user"] = Processor.process_get_client_count_by_auth_user
        self._processMap["get_clients_by_vir_platform"] = Processor.process_get_clients_by_vir_platform
        self._processMap["get_client_by_vir_platform_and_node"] = Processor.process_get_client_by_vir_platform_and_node
        self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
        self._processMap["do_operation_from_ams"] = Processor.process_do_operation_from_ams
        self._processMap["get_cluster_datasource"] = Processor.process_get_cluster_datasource
        self._processMap["get_virtual_machine_datasource"] = Processor.process_get_virtual_machine_datasource
        self._processMap["get_client_by_ip_or_id"] = Processor.process_get_client_by_ip_or_id
        self._processMap["get_in_kvm_platform"] = Processor.process_get_in_kvm_platform
        self._processMap["update_or_create_fp_pool"] = Processor.process_update_or_create_fp_pool
        self._processMap["get_client_type_by_id"] = Processor.process_get_client_type_by_id
        self._processMap["check_user_source"] = Processor.process_check_user_source
        self._processMap["get_server_by_client_ip"] = Processor.process_get_server_by_client_ip
        self._processMap["get_client_link_type"] = Processor.process_get_client_link_type
        self._processMap["get_virtual_safety_users"] = Processor.process_get_virtual_safety_users
        self._processMap["get_all_clients_to_log"] = Processor.process_get_all_clients_to_log
        self._processMap["get_fp_node_info_by_node_ip"] = Processor.process_get_fp_node_info_by_node_ip
        self._processMap["get_fl_by_fpoor_id"] = Processor.process_get_fl_by_fpoor_id
        self._processMap["update_finger_poor_nodes"] = Processor.process_update_finger_poor_nodes
        self._processMap["get_fl_guid_ids_by_fp_id"] = Processor.process_get_fl_guid_ids_by_fp_id
        self._processMap["get_protect_object_count"] = Processor.process_get_protect_object_count
        self._processMap["update_clients"] = Processor.process_update_clients
        self._processMap["get_fp_data_by_primary_key_id"] = Processor.process_get_fp_data_by_primary_key_id
        self._processMap["get_backup_cloud_jobs"] = Processor.process_get_backup_cloud_jobs
        self._processMap["get_projectuser_list"] = Processor.process_get_projectuser_list
        self._processMap["get_all_protect_object"] = Processor.process_get_all_protect_object
        self._processMap["abstract_public_interface"] = Processor.process_abstract_public_interface
        self._processMap["check_get_appsys"] = Processor.process_check_get_appsys
        self._processMap["update_eceph_info"] = Processor.process_update_eceph_info
        self._processMap["modify_schedule_job_cur_node"] = Processor.process_modify_schedule_job_cur_node
        self._processMap["check_user_has_data"] = Processor.process_check_user_has_data
        self._processMap["create_schedules_cur_node"] = Processor.process_create_schedules_cur_node
        self._processMap["modify_job_schedules_cur_node"] = Processor.process_modify_job_schedules_cur_node
        self._processMap["get_schedule_start_time"] = Processor.process_get_schedule_start_time
        self._processMap["get_public_cloud_resource"] = Processor.process_get_public_cloud_resource
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_microprobe(self, seqid, iprot, oprot):
        args = microprobe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = microprobe_result()
        try:
            self._handler.microprobe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("microprobe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_clients(self, seqid, iprot, oprot):
        args = get_all_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_clients_result()
        try:
            result.success = self._handler.get_all_clients()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_available_internal_client(self, seqid, iprot, oprot):
        args = get_available_internal_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_available_internal_client_result()
        try:
            result.success = self._handler.get_available_internal_client()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_available_internal_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clients_by_macs(self, seqid, iprot, oprot):
        args = get_clients_by_macs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clients_by_macs_result()
        try:
            result.success = self._handler.get_clients_by_macs(args.macs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clients_by_macs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clients_by_ids(self, seqid, iprot, oprot):
        args = get_clients_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clients_by_ids_result()
        try:
            result.success = self._handler.get_clients_by_ids(args.client_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clients_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clients_by_id(self, seqid, iprot, oprot):
        args = get_clients_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clients_by_id_result()
        try:
            result.success = self._handler.get_clients_by_id(args.client_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clients_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_by_name(self, seqid, iprot, oprot):
        args = get_storage_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_by_name_result()
        try:
            result.success = self._handler.get_storage_by_name(args.cloudStorageName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storages(self, seqid, iprot, oprot):
        args = get_storages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storages_result()
        try:
            result.success = self._handler.get_storages()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_storage_by_type(self, seqid, iprot, oprot):
        args = get_storage_by_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_storage_by_type_result()
        try:
            result.success = self._handler.get_storage_by_type(args.cloud_type, args.use_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_storage_by_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_storages(self, seqid, iprot, oprot):
        args = get_all_storages_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_storages_result()
        try:
            result.success = self._handler.get_all_storages()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_storages", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client(self, seqid, iprot, oprot):
        args = get_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_result()
        try:
            result.success = self._handler.get_client(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_client(self, seqid, iprot, oprot):
        args = update_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_client_result()
        try:
            self._handler.update_client(args.clientId, args.isEmail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_by_mac(self, seqid, iprot, oprot):
        args = get_client_by_mac_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_by_mac_result()
        try:
            result.success = self._handler.get_client_by_mac(args.clientMac)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_by_mac", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_platforms_by_request_config(self, seqid, iprot, oprot):
        args = get_platforms_by_request_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_platforms_by_request_config_result()
        try:
            result.success = self._handler.get_platforms_by_request_config(args.p_req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_platforms_by_request_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_newest_platform(self, seqid, iprot, oprot):
        args = get_newest_platform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_newest_platform_result()
        try:
            result.success = self._handler.get_newest_platform(args.vplatformId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_newest_platform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_server_ip(self, seqid, iprot, oprot):
        args = get_client_server_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_server_ip_result()
        try:
            result.success = self._handler.get_client_server_ip(args.client_uuid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_server_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_job(self, seqid, iprot, oprot):
        args = commit_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_job_result()
        try:
            self._handler.commit_job(args.clientId, args.baseInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_schedule_job(self, seqid, iprot, oprot):
        args = add_schedule_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_schedule_job_result()
        try:
            result.success = self._handler.add_schedule_job(args.tScheTaskInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_schedule_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_plans_in_cache(self, seqid, iprot, oprot):
        args = remove_plans_in_cache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_plans_in_cache_result()
        try:
            self._handler.remove_plans_in_cache(args.planIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_plans_in_cache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_schedule_job(self, seqid, iprot, oprot):
        args = modify_schedule_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_schedule_job_result()
        try:
            result.success = self._handler.modify_schedule_job(args.tScheTaskInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_schedule_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_schedule_list_job(self, seqid, iprot, oprot):
        args = modify_schedule_list_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_schedule_list_job_result()
        try:
            self._handler.modify_schedule_list_job(args.tScheTaskInfoList)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_schedule_list_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_schedule_jobs(self, seqid, iprot, oprot):
        args = delete_schedule_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_schedule_jobs_result()
        try:
            self._handler.delete_schedule_jobs(args.planId_list, args.svcType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_schedule_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_schedule_jobs_state(self, seqid, iprot, oprot):
        args = update_schedule_jobs_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_schedule_jobs_state_result()
        try:
            self._handler.update_schedule_jobs_state(args.planId_list, args.state, args.svcType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_schedule_jobs_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_all_jobs(self, seqid, iprot, oprot):
        args = get_schedule_all_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_all_jobs_result()
        try:
            result.success = self._handler.get_schedule_all_jobs(args.svcType, args.filter, args.count, args.index, args.auther)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_all_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_job(self, seqid, iprot, oprot):
        args = get_schedule_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_job_result()
        try:
            result.success = self._handler.get_schedule_job(args.planId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_jobs(self, seqid, iprot, oprot):
        args = get_schedule_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_jobs_result()
        try:
            result.success = self._handler.get_schedule_jobs(args.jobId, args.count, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_depend_jobs(self, seqid, iprot, oprot):
        args = get_schedule_depend_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_depend_jobs_result()
        try:
            result.success = self._handler.get_schedule_depend_jobs(args.jobId, args.count, args.index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_depend_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_plan_by_job_id(self, seqid, iprot, oprot):
        args = remove_all_plan_by_job_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_plan_by_job_id_result()
        try:
            self._handler.remove_all_plan_by_job_id(args.jobId, args.svcType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_plan_by_job_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_all_plan_by_job_ids(self, seqid, iprot, oprot):
        args = remove_all_plan_by_job_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_all_plan_by_job_ids_result()
        try:
            self._handler.remove_all_plan_by_job_ids(args.jobIds, args.svcType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("remove_all_plan_by_job_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_next_run_sche_by_job_id(self, seqid, iprot, oprot):
        args = get_next_run_sche_by_job_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_next_run_sche_by_job_id_result()
        try:
            result.success = self._handler.get_next_run_sche_by_job_id(args.jobIdList, args.svcType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_next_run_sche_by_job_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verify_plan_exists(self, seqid, iprot, oprot):
        args = verify_plan_exists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verify_plan_exists_result()
        try:
            result.success = self._handler.verify_plan_exists(args.planId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verify_plan_exists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_sches_in_node(self, seqid, iprot, oprot):
        args = get_all_sches_in_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_sches_in_node_result()
        try:
            result.success = self._handler.get_all_sches_in_node(args.real)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_sches_in_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_instance(self, seqid, iprot, oprot):
        args = get_db_instance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_instance_result()
        try:
            result.success = self._handler.get_db_instance(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_instance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_db_instances(self, seqid, iprot, oprot):
        args = get_db_instances_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_db_instances_result()
        try:
            result.success = self._handler.get_db_instances(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_db_instances", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_datasource_client_info(self, seqid, iprot, oprot):
        args = get_datasource_client_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_datasource_client_info_result()
        try:
            result.success = self._handler.get_datasource_client_info(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_datasource_client_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server_by_ip(self, seqid, iprot, oprot):
        args = get_server_by_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_by_ip_result()
        try:
            result.success = self._handler.get_server_by_ip(args.ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_server_by_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_available_child_clients(self, seqid, iprot, oprot):
        args = get_available_child_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_available_child_clients_result()
        try:
            result.success = self._handler.get_available_child_clients(args.nc_parent_client, args.filter_parameter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_available_child_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_child_clients(self, seqid, iprot, oprot):
        args = get_all_child_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_child_clients_result()
        try:
            result.success = self._handler.get_all_child_clients(args.nc_parent_client, args.filter_parameter)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_child_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_parent_clients(self, seqid, iprot, oprot):
        args = get_parent_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_parent_clients_result()
        try:
            result.success = self._handler.get_parent_clients(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_parent_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_hadoop_info(self, seqid, iprot, oprot):
        args = get_hadoop_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_hadoop_info_result()
        try:
            result.success = self._handler.get_hadoop_info(args.nc_parent_client)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_hadoop_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_mongodb_client_info(self, seqid, iprot, oprot):
        args = get_mongodb_client_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_mongodb_client_info_result()
        try:
            result.success = self._handler.get_mongodb_client_info(args.parent_client_id, args.child_client_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_mongodb_client_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_authorize(self, seqid, iprot, oprot):
        args = client_authorize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_authorize_result()
        try:
            result.success = self._handler.client_authorize(args.cliDisReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_authorize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_platform_authorize(self, seqid, iprot, oprot):
        args = platform_authorize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = platform_authorize_result()
        try:
            result.success = self._handler.platform_authorize(args.platDisReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("platform_authorize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers(self, seqid, iprot, oprot):
        args = get_servers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_result()
        try:
            result.success = self._handler.get_servers(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_servers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_del_auth_users_task(self, seqid, iprot, oprot):
        args = del_auth_users_task_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = del_auth_users_task_result()
        try:
            result.success = self._handler.del_auth_users_task(args.authReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as errors:
            msg_type = TMessageType.REPLY
            result.errors = errors
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("del_auth_users_task", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_state_auth_users_task(self, seqid, iprot, oprot):
        args = update_state_auth_users_task_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_state_auth_users_task_result()
        try:
            result.success = self._handler.update_state_auth_users_task(args.authReq, args.state)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as errors:
            msg_type = TMessageType.REPLY
            result.errors = errors
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_state_auth_users_task", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_strategy(self, seqid, iprot, oprot):
        args = get_strategy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_strategy_result()
        try:
            result.success = self._handler.get_strategy(args.strategyId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_strategy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_strategy_by_name_and_job_type(self, seqid, iprot, oprot):
        args = get_strategy_by_name_and_job_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_strategy_by_name_and_job_type_result()
        try:
            result.success = self._handler.get_strategy_by_name_and_job_type(args.strategy_name, args.job_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_strategy_by_name_and_job_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_strategy_schedule(self, seqid, iprot, oprot):
        args = create_strategy_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_strategy_schedule_result()
        try:
            self._handler.create_strategy_schedule(args.strategyId, args.job_id, args.begin_time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_strategy_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_strategy_schedule(self, seqid, iprot, oprot):
        args = modify_strategy_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_strategy_schedule_result()
        try:
            self._handler.modify_strategy_schedule(args.strategyId, args.job_id, args.begin_time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_strategy_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_new_modify_strategy_schedule(self, seqid, iprot, oprot):
        args = new_modify_strategy_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = new_modify_strategy_schedule_result()
        try:
            self._handler.new_modify_strategy_schedule(args.schedules)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("new_modify_strategy_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_strategy_schedule(self, seqid, iprot, oprot):
        args = delete_strategy_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_strategy_schedule_result()
        try:
            self._handler.delete_strategy_schedule(args.job_id, args.host_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_strategy_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_cur_strategy_schedule(self, seqid, iprot, oprot):
        args = delete_cur_strategy_schedule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_cur_strategy_schedule_result()
        try:
            self._handler.delete_cur_strategy_schedule(args.plan_id_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_cur_strategy_schedule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clientid_nctclient(self, seqid, iprot, oprot):
        args = get_clientid_nctclient_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clientid_nctclient_result()
        try:
            result.success = self._handler.get_clientid_nctclient(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clientid_nctclient", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_configs_by_client_id(self, seqid, iprot, oprot):
        args = get_client_configs_by_client_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_configs_by_client_id_result()
        try:
            result.success = self._handler.get_client_configs_by_client_id(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_configs_by_client_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fp_user_status(self, seqid, iprot, oprot):
        args = get_fp_user_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fp_user_status_result()
        try:
            result.success = self._handler.get_fp_user_status(args.fp_id, args.user_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fp_user_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fp_by_node_ip(self, seqid, iprot, oprot):
        args = get_fp_by_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fp_by_node_ip_result()
        try:
            result.success = self._handler.get_fp_by_node_ip(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fp_by_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_contentcloudresourceid_resourceobj(self, seqid, iprot, oprot):
        args = get_contentcloudresourceid_resourceobj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_contentcloudresourceid_resourceobj_result()
        try:
            result.success = self._handler.get_contentcloudresourceid_resourceobj(args.request)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_contentcloudresourceid_resourceobj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_username_by_flguid(self, seqid, iprot, oprot):
        args = get_username_by_flguid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_username_by_flguid_result()
        try:
            result.success = self._handler.get_username_by_flguid(args.flguid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_username_by_flguid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_recovery_client(self, seqid, iprot, oprot):
        args = delete_recovery_client_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_recovery_client_result()
        try:
            self._handler.delete_recovery_client(args.client_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_recovery_client", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_recovery_clients(self, seqid, iprot, oprot):
        args = delete_recovery_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_recovery_clients_result()
        try:
            self._handler.delete_recovery_clients(args.client_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_recovery_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_job_message_for_ams(self, seqid, iprot, oprot):
        args = update_job_message_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_job_message_for_ams_result()
        try:
            self._handler.update_job_message_for_ams(args.jobId, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_job_message_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_recovery_job_for_ams(self, seqid, iprot, oprot):
        args = add_recovery_job_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_recovery_job_for_ams_result()
        try:
            self._handler.add_recovery_job_for_ams(args.jobId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_recovery_job_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_task_log_message(self, seqid, iprot, oprot):
        args = get_task_log_message_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_task_log_message_result()
        try:
            self._handler.get_task_log_message(args.instanceId, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_task_log_message", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_delete_job_message(self, seqid, iprot, oprot):
        args = get_delete_job_message_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_delete_job_message_result()
        try:
            self._handler.get_delete_job_message(args.taskId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_delete_job_message", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_clean_job(self, seqid, iprot, oprot):
        args = create_clean_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_clean_job_result()
        try:
            self._handler.create_clean_job(args.clean_job)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_clean_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_remote_job_log(self, seqid, iprot, oprot):
        args = update_remote_job_log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_remote_job_log_result()
        try:
            self._handler.update_remote_job_log(args.jobInstance, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_remote_job_log", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_remote_job(self, seqid, iprot, oprot):
        args = update_remote_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_remote_job_result()
        try:
            self._handler.update_remote_job(args.job, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_remote_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdm_backup_job(self, seqid, iprot, oprot):
        args = update_cdm_backup_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdm_backup_job_result()
        try:
            self._handler.update_cdm_backup_job(args.job, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdm_backup_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdm_backup_job_history(self, seqid, iprot, oprot):
        args = update_cdm_backup_job_history_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdm_backup_job_history_result()
        try:
            self._handler.update_cdm_backup_job_history(args.jobInstance, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdm_backup_job_history", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdm_mount_job(self, seqid, iprot, oprot):
        args = update_cdm_mount_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdm_mount_job_result()
        try:
            self._handler.update_cdm_mount_job(args.job, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdm_mount_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdp_job(self, seqid, iprot, oprot):
        args = update_cdp_job_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdp_job_result()
        try:
            self._handler.update_cdp_job(args.job, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdp_job", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdp_job_instance(self, seqid, iprot, oprot):
        args = update_cdp_job_instance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdp_job_instance_result()
        try:
            self._handler.update_cdp_job_instance(args.jobInstance, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdp_job_instance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_project_user_authorize(self, seqid, iprot, oprot):
        args = project_user_authorize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = project_user_authorize_result()
        try:
            result.success = self._handler.project_user_authorize(args.projectUserDisReq)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("project_user_authorize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_newest_projectuser(self, seqid, iprot, oprot):
        args = get_newest_projectuser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_newest_projectuser_result()
        try:
            result.success = self._handler.get_newest_projectuser(args.projectuserIds, args.decrypt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_newest_projectuser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_newest_projectstorage(self, seqid, iprot, oprot):
        args = get_newest_projectstorage_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_newest_projectstorage_result()
        try:
            result.success = self._handler.get_newest_projectstorage(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_newest_projectstorage", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_cdm_mount_job_instance(self, seqid, iprot, oprot):
        args = update_cdm_mount_job_instance_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_cdm_mount_job_instance_result()
        try:
            self._handler.update_cdm_mount_job_instance(args.jobInstance, args.msgMethod)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_cdm_mount_job_instance", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_count_by_auth_user(self, seqid, iprot, oprot):
        args = get_client_count_by_auth_user_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_count_by_auth_user_result()
        try:
            result.success = self._handler.get_client_count_by_auth_user(args.username)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_count_by_auth_user", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_clients_by_vir_platform(self, seqid, iprot, oprot):
        args = get_clients_by_vir_platform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_clients_by_vir_platform_result()
        try:
            result.success = self._handler.get_clients_by_vir_platform(args.vir_platform_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_clients_by_vir_platform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_by_vir_platform_and_node(self, seqid, iprot, oprot):
        args = get_client_by_vir_platform_and_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_by_vir_platform_and_node_result()
        try:
            result.success = self._handler.get_client_by_vir_platform_and_node(args.vir_platform_id, args.node_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_by_vir_platform_and_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_data_for_ams(self, seqid, iprot, oprot):
        args = get_data_for_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_data_for_ams_result()
        try:
            result.success = self._handler.get_data_for_ams(args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_data_for_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_do_operation_from_ams(self, seqid, iprot, oprot):
        args = do_operation_from_ams_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = do_operation_from_ams_result()
        try:
            result.success = self._handler.do_operation_from_ams(args.target, args.method, args.kwargs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("do_operation_from_ams", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_datasource(self, seqid, iprot, oprot):
        args = get_cluster_datasource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_datasource_result()
        try:
            result.success = self._handler.get_cluster_datasource(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_cluster_datasource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_virtual_machine_datasource(self, seqid, iprot, oprot):
        args = get_virtual_machine_datasource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_virtual_machine_datasource_result()
        try:
            result.success = self._handler.get_virtual_machine_datasource(args.client_id, args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_virtual_machine_datasource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_by_ip_or_id(self, seqid, iprot, oprot):
        args = get_client_by_ip_or_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_by_ip_or_id_result()
        try:
            result.success = self._handler.get_client_by_ip_or_id(args.client_ip, args.client_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_by_ip_or_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_in_kvm_platform(self, seqid, iprot, oprot):
        args = get_in_kvm_platform_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_in_kvm_platform_result()
        try:
            result.success = self._handler.get_in_kvm_platform()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_in_kvm_platform", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_or_create_fp_pool(self, seqid, iprot, oprot):
        args = update_or_create_fp_pool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_or_create_fp_pool_result()
        try:
            self._handler.update_or_create_fp_pool()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_or_create_fp_pool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_type_by_id(self, seqid, iprot, oprot):
        args = get_client_type_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_type_by_id_result()
        try:
            result.success = self._handler.get_client_type_by_id(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_type_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_user_source(self, seqid, iprot, oprot):
        args = check_user_source_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_user_source_result()
        try:
            self._handler.check_user_source(args.username, args.source)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_user_source", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server_by_client_ip(self, seqid, iprot, oprot):
        args = get_server_by_client_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_by_client_ip_result()
        try:
            result.success = self._handler.get_server_by_client_ip(args.ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_server_by_client_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_link_type(self, seqid, iprot, oprot):
        args = get_client_link_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_link_type_result()
        try:
            result.success = self._handler.get_client_link_type(args.configId, args.hostId, args.wwn)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_client_link_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_virtual_safety_users(self, seqid, iprot, oprot):
        args = get_virtual_safety_users_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_virtual_safety_users_result()
        try:
            result.success = self._handler.get_virtual_safety_users(args.infos)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_virtual_safety_users", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_clients_to_log(self, seqid, iprot, oprot):
        args = get_all_clients_to_log_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_clients_to_log_result()
        try:
            result.success = self._handler.get_all_clients_to_log(args.user_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_clients_to_log", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fp_node_info_by_node_ip(self, seqid, iprot, oprot):
        args = get_fp_node_info_by_node_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fp_node_info_by_node_ip_result()
        try:
            result.success = self._handler.get_fp_node_info_by_node_ip(args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fp_node_info_by_node_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fl_by_fpoor_id(self, seqid, iprot, oprot):
        args = get_fl_by_fpoor_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fl_by_fpoor_id_result()
        try:
            result.success = self._handler.get_fl_by_fpoor_id(args.fp_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fl_by_fpoor_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_finger_poor_nodes(self, seqid, iprot, oprot):
        args = update_finger_poor_nodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_finger_poor_nodes_result()
        try:
            self._handler.update_finger_poor_nodes(args.fp_id, args.node_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_finger_poor_nodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fl_guid_ids_by_fp_id(self, seqid, iprot, oprot):
        args = get_fl_guid_ids_by_fp_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fl_guid_ids_by_fp_id_result()
        try:
            result.success = self._handler.get_fl_guid_ids_by_fp_id(args.fp_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fl_guid_ids_by_fp_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_protect_object_count(self, seqid, iprot, oprot):
        args = get_protect_object_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_protect_object_count_result()
        try:
            result.success = self._handler.get_protect_object_count(args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_protect_object_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_clients(self, seqid, iprot, oprot):
        args = update_clients_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_clients_result()
        try:
            self._handler.update_clients(args.clientId, args.customer, args.clusterPort)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_clients", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fp_data_by_primary_key_id(self, seqid, iprot, oprot):
        args = get_fp_data_by_primary_key_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fp_data_by_primary_key_id_result()
        try:
            result.success = self._handler.get_fp_data_by_primary_key_id(args.primary_key_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fp_data_by_primary_key_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backup_cloud_jobs(self, seqid, iprot, oprot):
        args = get_backup_cloud_jobs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backup_cloud_jobs_result()
        try:
            result.success = self._handler.get_backup_cloud_jobs(args.query_all)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_backup_cloud_jobs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_projectuser_list(self, seqid, iprot, oprot):
        args = get_projectuser_list_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_projectuser_list_result()
        try:
            result.success = self._handler.get_projectuser_list(args.cplatform_types)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_projectuser_list", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_protect_object(self, seqid, iprot, oprot):
        args = get_all_protect_object_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_protect_object_result()
        try:
            result.success = self._handler.get_all_protect_object()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_protect_object", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abstract_public_interface(self, seqid, iprot, oprot):
        args = abstract_public_interface_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abstract_public_interface_result()
        try:
            result.success = self._handler.abstract_public_interface(args.msg, args.body)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abstract_public_interface", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_get_appsys(self, seqid, iprot, oprot):
        args = check_get_appsys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_get_appsys_result()
        try:
            result.success = self._handler.check_get_appsys(args.req)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_get_appsys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_eceph_info(self, seqid, iprot, oprot):
        args = update_eceph_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_eceph_info_result()
        try:
            self._handler.update_eceph_info(args.cinfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_eceph_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_schedule_job_cur_node(self, seqid, iprot, oprot):
        args = modify_schedule_job_cur_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_schedule_job_cur_node_result()
        try:
            self._handler.modify_schedule_job_cur_node(args.strategy_id, args.job_id, args.begin_time, args.is_modify_strategy)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_schedule_job_cur_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_user_has_data(self, seqid, iprot, oprot):
        args = check_user_has_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_user_has_data_result()
        try:
            result.success = self._handler.check_user_has_data(args.user_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_user_has_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_schedules_cur_node(self, seqid, iprot, oprot):
        args = create_schedules_cur_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_schedules_cur_node_result()
        try:
            self._handler.create_schedules_cur_node(args.schedules)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_schedules_cur_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modify_job_schedules_cur_node(self, seqid, iprot, oprot):
        args = modify_job_schedules_cur_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modify_job_schedules_cur_node_result()
        try:
            self._handler.modify_job_schedules_cur_node(args.schedules)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modify_job_schedules_cur_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schedule_start_time(self, seqid, iprot, oprot):
        args = get_schedule_start_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schedule_start_time_result()
        try:
            result.success = self._handler.get_schedule_start_time(args.schedules)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schedule_start_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_public_cloud_resource(self, seqid, iprot, oprot):
        args = get_public_cloud_resource_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_public_cloud_resource_result()
        try:
            result.success = self._handler.get_public_cloud_resource(args.public_cloud_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as error:
            msg_type = TMessageType.REPLY
            result.error = error
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_public_cloud_resource", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class microprobe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_args)
microprobe_args.thrift_spec = (
)


class microprobe_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('microprobe_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(microprobe_result)
microprobe_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_clients_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clients_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clients_args)
get_all_clients_args.thrift_spec = (
)


class get_all_clients_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = ncClient.ttypes.ncTClient()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clients_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clients_result)
get_all_clients_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_available_internal_client_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_available_internal_client_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_available_internal_client_args)
get_available_internal_client_args.thrift_spec = (
)


class get_available_internal_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncTClient()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_available_internal_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_available_internal_client_result)
get_available_internal_client_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncTClient, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clients_by_macs_args(object):
    """
    Attributes:
     - macs

    """


    def __init__(self, macs=None,):
        self.macs = macs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.macs = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.macs.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_macs_args')
        if self.macs is not None:
            oprot.writeFieldBegin('macs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.macs))
            for iter13 in self.macs:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_macs_args)
get_clients_by_macs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'macs', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_clients_by_macs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = ncClient.ttypes.ncTClient()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_macs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_macs_result)
get_clients_by_macs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clients_by_ids_args(object):
    """
    Attributes:
     - client_ids

    """


    def __init__(self, client_ids=None,):
        self.client_ids = client_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.client_ids = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.client_ids.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_ids_args')
        if self.client_ids is not None:
            oprot.writeFieldBegin('client_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.client_ids))
            for iter27 in self.client_ids:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_ids_args)
get_clients_by_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'client_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class get_clients_by_ids_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = ncClient.ttypes.ncTClient()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_ids_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_ids_result)
get_clients_by_ids_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clients_by_id_args(object):
    """
    Attributes:
     - client_id

    """


    def __init__(self, client_id=None,):
        self.client_id = client_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_id_args')
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 1)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_id_args)
get_clients_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_id', 'UTF8', None, ),  # 1
)


class get_clients_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = ncClient.ttypes.ncTClient()
                        _elem40.read(iprot)
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter41 in self.success:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_id_result)
get_clients_by_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_storage_by_name_args(object):
    """
    Attributes:
     - cloudStorageName

    """


    def __init__(self, cloudStorageName=None,):
        self.cloudStorageName = cloudStorageName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cloudStorageName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_by_name_args')
        if self.cloudStorageName is not None:
            oprot.writeFieldBegin('cloudStorageName', TType.STRING, 1)
            oprot.writeString(self.cloudStorageName.encode('utf-8') if sys.version_info[0] == 2 else self.cloudStorageName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_by_name_args)
get_storage_by_name_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cloudStorageName', 'UTF8', None, ),  # 1
)


class get_storage_by_name_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCloudStorage.ttypes.ncCloudStorage()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_by_name_result)
get_storage_by_name_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCloudStorage.ttypes.ncCloudStorage, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_storages_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storages_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storages_args)
get_storages_args.thrift_spec = (
)


class get_storages_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = ncEcssCommonDefinition.ttypes.ncCloudStorageInfo()
                        _elem47.read(iprot)
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter48 in self.success:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storages_result)
get_storages_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncEcssCommonDefinition.ttypes.ncCloudStorageInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_storage_by_type_args(object):
    """
    Attributes:
     - cloud_type
     - use_type

    """


    def __init__(self, cloud_type=None, use_type=None,):
        self.cloud_type = cloud_type
        self.use_type = use_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.cloud_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.use_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_by_type_args')
        if self.cloud_type is not None:
            oprot.writeFieldBegin('cloud_type', TType.I32, 1)
            oprot.writeI32(self.cloud_type)
            oprot.writeFieldEnd()
        if self.use_type is not None:
            oprot.writeFieldBegin('use_type', TType.I32, 2)
            oprot.writeI32(self.use_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_by_type_args)
get_storage_by_type_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'cloud_type', None, None, ),  # 1
    (2, TType.I32, 'use_type', None, None, ),  # 2
)


class get_storage_by_type_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = ncCloudStorage.ttypes.ncCloudStorage()
                        _elem54.read(iprot)
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_storage_by_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter55 in self.success:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_storage_by_type_result)
get_storage_by_type_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCloudStorage.ttypes.ncCloudStorage, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_storages_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_storages_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_storages_args)
get_all_storages_args.thrift_spec = (
)


class get_all_storages_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = ncCloudStorage.ttypes.ncCloudStorage()
                        _elem61.read(iprot)
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_storages_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter62 in self.success:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_storages_result)
get_all_storages_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCloudStorage.ttypes.ncCloudStorage, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_args)
get_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class get_client_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncTClient()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_result)
get_client_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncTClient, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_client_args(object):
    """
    Attributes:
     - clientId
     - isEmail

    """


    def __init__(self, clientId=None, isEmail=None,):
        self.clientId = clientId
        self.isEmail = isEmail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isEmail = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_client_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.isEmail is not None:
            oprot.writeFieldBegin('isEmail', TType.BOOL, 2)
            oprot.writeBool(self.isEmail)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_client_args)
update_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'isEmail', None, None, ),  # 2
)


class update_client_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_client_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_client_result)
update_client_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_by_mac_args(object):
    """
    Attributes:
     - clientMac

    """


    def __init__(self, clientMac=None,):
        self.clientMac = clientMac

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientMac = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_mac_args')
        if self.clientMac is not None:
            oprot.writeFieldBegin('clientMac', TType.STRING, 1)
            oprot.writeString(self.clientMac.encode('utf-8') if sys.version_info[0] == 2 else self.clientMac)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_mac_args)
get_client_by_mac_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientMac', 'UTF8', None, ),  # 1
)


class get_client_by_mac_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncTClient()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_mac_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_mac_result)
get_client_by_mac_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncTClient, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_platforms_by_request_config_args(object):
    """
    Attributes:
     - p_req

    """


    def __init__(self, p_req=None,):
        self.p_req = p_req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.p_req = ncPlatform.ttypes.ncGetPlatformsReq()
                    self.p_req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_platforms_by_request_config_args')
        if self.p_req is not None:
            oprot.writeFieldBegin('p_req', TType.STRUCT, 1)
            self.p_req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_platforms_by_request_config_args)
get_platforms_by_request_config_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'p_req', [ncPlatform.ttypes.ncGetPlatformsReq, None], None, ),  # 1
)


class get_platforms_by_request_config_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype64, _vtype65, _size63) = iprot.readMapBegin()
                    for _i67 in range(_size63):
                        _key68 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val69 = ncPlatform.ttypes.ncTPlatform()
                        _val69.read(iprot)
                        self.success[_key68] = _val69
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_platforms_by_request_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter70, viter71 in self.success.items():
                oprot.writeString(kiter70.encode('utf-8') if sys.version_info[0] == 2 else kiter70)
                viter71.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_platforms_by_request_config_result)
get_platforms_by_request_config_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncPlatform.ttypes.ncTPlatform, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_newest_platform_args(object):
    """
    Attributes:
     - vplatformId

    """


    def __init__(self, vplatformId=None,):
        self.vplatformId = vplatformId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.vplatformId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_platform_args')
        if self.vplatformId is not None:
            oprot.writeFieldBegin('vplatformId', TType.STRING, 1)
            oprot.writeString(self.vplatformId.encode('utf-8') if sys.version_info[0] == 2 else self.vplatformId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_platform_args)
get_newest_platform_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'vplatformId', 'UTF8', None, ),  # 1
)


class get_newest_platform_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncPlatform.ttypes.ncTPlatform()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_platform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_platform_result)
get_newest_platform_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncPlatform.ttypes.ncTPlatform, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_server_ip_args(object):
    """
    Attributes:
     - client_uuid

    """


    def __init__(self, client_uuid=None,):
        self.client_uuid = client_uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_server_ip_args')
        if self.client_uuid is not None:
            oprot.writeFieldBegin('client_uuid', TType.STRING, 1)
            oprot.writeString(self.client_uuid.encode('utf-8') if sys.version_info[0] == 2 else self.client_uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_server_ip_args)
get_client_server_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_uuid', 'UTF8', None, ),  # 1
)


class get_client_server_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_server_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_server_ip_result)
get_client_server_ip_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class commit_job_args(object):
    """
    Attributes:
     - clientId
     - baseInfo

    """


    def __init__(self, clientId=None, baseInfo=None,):
        self.clientId = clientId
        self.baseInfo = baseInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
                    self.baseInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.baseInfo is not None:
            oprot.writeFieldBegin('baseInfo', TType.STRUCT, 2)
            self.baseInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_args)
commit_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'baseInfo', [ncEEFJobBase.ttypes.ncEEFBase, None], None, ),  # 2
)


class commit_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_job_result)
commit_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class add_schedule_job_args(object):
    """
    Attributes:
     - tScheTaskInfo

    """


    def __init__(self, tScheTaskInfo=None,):
        self.tScheTaskInfo = tScheTaskInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tScheTaskInfo = ncScheTask.ttypes.ncTScheTaskInfo()
                    self.tScheTaskInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_schedule_job_args')
        if self.tScheTaskInfo is not None:
            oprot.writeFieldBegin('tScheTaskInfo', TType.STRUCT, 1)
            self.tScheTaskInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_schedule_job_args)
add_schedule_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tScheTaskInfo', [ncScheTask.ttypes.ncTScheTaskInfo, None], None, ),  # 1
)


class add_schedule_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_schedule_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_schedule_job_result)
add_schedule_job_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_plans_in_cache_args(object):
    """
    Attributes:
     - planIds

    """


    def __init__(self, planIds=None,):
        self.planIds = planIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.planIds = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.planIds.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_plans_in_cache_args')
        if self.planIds is not None:
            oprot.writeFieldBegin('planIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.planIds))
            for iter78 in self.planIds:
                oprot.writeString(iter78.encode('utf-8') if sys.version_info[0] == 2 else iter78)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_plans_in_cache_args)
remove_plans_in_cache_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'planIds', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class remove_plans_in_cache_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_plans_in_cache_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_plans_in_cache_result)
remove_plans_in_cache_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_schedule_job_args(object):
    """
    Attributes:
     - tScheTaskInfo

    """


    def __init__(self, tScheTaskInfo=None,):
        self.tScheTaskInfo = tScheTaskInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tScheTaskInfo = ncScheTask.ttypes.ncTScheTaskInfo()
                    self.tScheTaskInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_job_args')
        if self.tScheTaskInfo is not None:
            oprot.writeFieldBegin('tScheTaskInfo', TType.STRUCT, 1)
            self.tScheTaskInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_job_args)
modify_schedule_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tScheTaskInfo', [ncScheTask.ttypes.ncTScheTaskInfo, None], None, ),  # 1
)


class modify_schedule_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_job_result)
modify_schedule_job_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_schedule_list_job_args(object):
    """
    Attributes:
     - tScheTaskInfoList

    """


    def __init__(self, tScheTaskInfoList=None,):
        self.tScheTaskInfoList = tScheTaskInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tScheTaskInfoList = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = ncScheTask.ttypes.ncTScheTaskInfo()
                        _elem84.read(iprot)
                        self.tScheTaskInfoList.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_list_job_args')
        if self.tScheTaskInfoList is not None:
            oprot.writeFieldBegin('tScheTaskInfoList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.tScheTaskInfoList))
            for iter85 in self.tScheTaskInfoList:
                iter85.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_list_job_args)
modify_schedule_list_job_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tScheTaskInfoList', (TType.STRUCT, [ncScheTask.ttypes.ncTScheTaskInfo, None], False), None, ),  # 1
)


class modify_schedule_list_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_list_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_list_job_result)
modify_schedule_list_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_schedule_jobs_args(object):
    """
    Attributes:
     - planId_list
     - svcType

    """


    def __init__(self, planId_list=None, svcType=None,):
        self.planId_list = planId_list
        self.svcType = svcType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.planId_list = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.planId_list.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_schedule_jobs_args')
        if self.planId_list is not None:
            oprot.writeFieldBegin('planId_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.planId_list))
            for iter92 in self.planId_list:
                oprot.writeString(iter92.encode('utf-8') if sys.version_info[0] == 2 else iter92)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_schedule_jobs_args)
delete_schedule_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'planId_list', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
)


class delete_schedule_jobs_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_schedule_jobs_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_schedule_jobs_result)
delete_schedule_jobs_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_schedule_jobs_state_args(object):
    """
    Attributes:
     - planId_list
     - state
     - svcType

    """


    def __init__(self, planId_list=None, state=None, svcType=None,):
        self.planId_list = planId_list
        self.state = state
        self.svcType = svcType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.planId_list = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.planId_list.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_schedule_jobs_state_args')
        if self.planId_list is not None:
            oprot.writeFieldBegin('planId_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.planId_list))
            for iter99 in self.planId_list:
                oprot.writeString(iter99.encode('utf-8') if sys.version_info[0] == 2 else iter99)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 3)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_schedule_jobs_state_args)
update_schedule_jobs_state_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'planId_list', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
    (3, TType.I32, 'svcType', None, None, ),  # 3
)


class update_schedule_jobs_state_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_schedule_jobs_state_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_schedule_jobs_state_result)
update_schedule_jobs_state_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_all_jobs_args(object):
    """
    Attributes:
     - svcType
     - filter
     - count
     - index
     - auther

    """


    def __init__(self, svcType=None, filter=None, count=None, index=None, auther=None,):
        self.svcType = svcType
        self.filter = filter
        self.count = count
        self.index = index
        self.auther = auther

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.auther = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_all_jobs_args')
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 1)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 2)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 4)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.auther is not None:
            oprot.writeFieldBegin('auther', TType.STRING, 5)
            oprot.writeString(self.auther.encode('utf-8') if sys.version_info[0] == 2 else self.auther)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_all_jobs_args)
get_schedule_all_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'svcType', None, None, ),  # 1
    (2, TType.STRING, 'filter', 'UTF8', None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
    (4, TType.I32, 'index', None, None, ),  # 4
    (5, TType.STRING, 'auther', 'UTF8', None, ),  # 5
)


class get_schedule_all_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskInfoResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_all_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_all_jobs_result)
get_schedule_all_jobs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskInfoResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_job_args(object):
    """
    Attributes:
     - planId

    """


    def __init__(self, planId=None,):
        self.planId = planId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_job_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.STRING, 1)
            oprot.writeString(self.planId.encode('utf-8') if sys.version_info[0] == 2 else self.planId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_job_args)
get_schedule_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planId', 'UTF8', None, ),  # 1
)


class get_schedule_job_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_job_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_job_result)
get_schedule_job_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_jobs_args(object):
    """
    Attributes:
     - jobId
     - count
     - index

    """


    def __init__(self, jobId=None, count=None, index=None,):
        self.jobId = jobId
        self.count = count
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_jobs_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_jobs_args)
get_schedule_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class get_schedule_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskInfoResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_jobs_result)
get_schedule_jobs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskInfoResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_depend_jobs_args(object):
    """
    Attributes:
     - jobId
     - count
     - index

    """


    def __init__(self, jobId=None, count=None, index=None,):
        self.jobId = jobId
        self.count = count
        self.index = index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_depend_jobs_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 2)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 3)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_depend_jobs_args)
get_schedule_depend_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'count', None, None, ),  # 2
    (3, TType.I32, 'index', None, None, ),  # 3
)


class get_schedule_depend_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncTScheTaskInfoResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_depend_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_depend_jobs_result)
get_schedule_depend_jobs_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncTScheTaskInfoResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_plan_by_job_id_args(object):
    """
    Attributes:
     - jobId
     - svcType

    """


    def __init__(self, jobId=None, svcType=None,):
        self.jobId = jobId
        self.svcType = svcType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_plan_by_job_id_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_plan_by_job_id_args)
remove_all_plan_by_job_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
)


class remove_all_plan_by_job_id_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_plan_by_job_id_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_plan_by_job_id_result)
remove_all_plan_by_job_id_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class remove_all_plan_by_job_ids_args(object):
    """
    Attributes:
     - jobIds
     - svcType

    """


    def __init__(self, jobIds=None, svcType=None,):
        self.jobIds = jobIds
        self.svcType = svcType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobIds = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobIds.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_plan_by_job_ids_args')
        if self.jobIds is not None:
            oprot.writeFieldBegin('jobIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jobIds))
            for iter106 in self.jobIds:
                oprot.writeString(iter106.encode('utf-8') if sys.version_info[0] == 2 else iter106)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_plan_by_job_ids_args)
remove_all_plan_by_job_ids_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
)


class remove_all_plan_by_job_ids_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('remove_all_plan_by_job_ids_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(remove_all_plan_by_job_ids_result)
remove_all_plan_by_job_ids_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_next_run_sche_by_job_id_args(object):
    """
    Attributes:
     - jobIdList
     - svcType

    """


    def __init__(self, jobIdList=None, svcType=None,):
        self.jobIdList = jobIdList
        self.svcType = svcType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.jobIdList = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobIdList.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.svcType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_next_run_sche_by_job_id_args')
        if self.jobIdList is not None:
            oprot.writeFieldBegin('jobIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.jobIdList))
            for iter113 in self.jobIdList:
                oprot.writeString(iter113.encode('utf-8') if sys.version_info[0] == 2 else iter113)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.svcType is not None:
            oprot.writeFieldBegin('svcType', TType.I32, 2)
            oprot.writeI32(self.svcType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_next_run_sche_by_job_id_args)
get_next_run_sche_by_job_id_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'jobIdList', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'svcType', None, None, ),  # 2
)


class get_next_run_sche_by_job_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncScheTask.ttypes.ncNextScheResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_next_run_sche_by_job_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_next_run_sche_by_job_id_result)
get_next_run_sche_by_job_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncScheTask.ttypes.ncNextScheResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class verify_plan_exists_args(object):
    """
    Attributes:
     - planId

    """


    def __init__(self, planId=None,):
        self.planId = planId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.planId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_plan_exists_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.STRING, 1)
            oprot.writeString(self.planId.encode('utf-8') if sys.version_info[0] == 2 else self.planId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_plan_exists_args)
verify_plan_exists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'planId', 'UTF8', None, ),  # 1
)


class verify_plan_exists_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_plan_exists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_plan_exists_result)
verify_plan_exists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_sches_in_node_args(object):
    """
    Attributes:
     - real

    """


    def __init__(self, real=None,):
        self.real = real

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.real = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_sches_in_node_args')
        if self.real is not None:
            oprot.writeFieldBegin('real', TType.BOOL, 1)
            oprot.writeBool(self.real)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_sches_in_node_args)
get_all_sches_in_node_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'real', None, None, ),  # 1
)


class get_all_sches_in_node_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = ncScheTask.ttypes.ncTScheTaskInfo()
                        _elem119.read(iprot)
                        self.success.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_sches_in_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter120 in self.success:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_sches_in_node_result)
get_all_sches_in_node_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncScheTask.ttypes.ncTScheTaskInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_instance_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncDBInstance.ttypes.ncDBInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_instance_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_instance_args)
get_db_instance_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncDBInstance.ttypes.ncDBInstanceRequest, None], None, ),  # 1
)


class get_db_instance_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncDBInstance.ttypes.ncDBInstanceResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_instance_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_instance_result)
get_db_instance_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncDBInstance.ttypes.ncDBInstanceResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_db_instances_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncDBInstance.ttypes.ncDBInstanceRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_instances_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_instances_args)
get_db_instances_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncDBInstance.ttypes.ncDBInstanceRequest, None], None, ),  # 1
)


class get_db_instances_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncDBInstance.ttypes.ncDBInstancesResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_db_instances_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_db_instances_result)
get_db_instances_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncDBInstance.ttypes.ncDBInstancesResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_datasource_client_info_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_client_info_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_client_info_args)
get_datasource_client_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class get_datasource_client_info_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_datasource_client_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_datasource_client_info_result)
get_datasource_client_info_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_server_by_ip_args(object):
    """
    Attributes:
     - ip

    """


    def __init__(self, ip=None,):
        self.ip = ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_by_ip_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_by_ip_args)
get_server_by_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
)


class get_server_by_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncServer.ttypes.ncServer()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_by_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_by_ip_result)
get_server_by_ip_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncServer.ttypes.ncServer, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_available_child_clients_args(object):
    """
    Attributes:
     - nc_parent_client
     - filter_parameter

    """


    def __init__(self, nc_parent_client=None, filter_parameter=None,):
        self.nc_parent_client = nc_parent_client
        self.filter_parameter = filter_parameter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.nc_parent_client = ncClient.ttypes.ncParentClient()
                    self.nc_parent_client.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter_parameter = ncClient.ttypes.ncChildClientFilterParameter()
                    self.filter_parameter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_available_child_clients_args')
        if self.nc_parent_client is not None:
            oprot.writeFieldBegin('nc_parent_client', TType.STRUCT, 1)
            self.nc_parent_client.write(oprot)
            oprot.writeFieldEnd()
        if self.filter_parameter is not None:
            oprot.writeFieldBegin('filter_parameter', TType.STRUCT, 2)
            self.filter_parameter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nc_parent_client is None:
            raise TProtocolException(message='Required field nc_parent_client is unset!')
        if self.filter_parameter is None:
            raise TProtocolException(message='Required field filter_parameter is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_available_child_clients_args)
get_available_child_clients_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'nc_parent_client', [ncClient.ttypes.ncParentClient, None], None, ),  # 1
    (2, TType.STRUCT, 'filter_parameter', [ncClient.ttypes.ncChildClientFilterParameter, None], None, ),  # 2
)


class get_available_child_clients_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = ncClient.ttypes.ncTClient()
                        _elem126.read(iprot)
                        self.success.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_available_child_clients_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter127 in self.success:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_available_child_clients_result)
get_available_child_clients_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_child_clients_args(object):
    """
    Attributes:
     - nc_parent_client
     - filter_parameter

    """


    def __init__(self, nc_parent_client=None, filter_parameter=None,):
        self.nc_parent_client = nc_parent_client
        self.filter_parameter = filter_parameter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.nc_parent_client = ncClient.ttypes.ncParentClient()
                    self.nc_parent_client.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.filter_parameter = ncClient.ttypes.ncChildClientFilterParameter()
                    self.filter_parameter.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_child_clients_args')
        if self.nc_parent_client is not None:
            oprot.writeFieldBegin('nc_parent_client', TType.STRUCT, 1)
            self.nc_parent_client.write(oprot)
            oprot.writeFieldEnd()
        if self.filter_parameter is not None:
            oprot.writeFieldBegin('filter_parameter', TType.STRUCT, 2)
            self.filter_parameter.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nc_parent_client is None:
            raise TProtocolException(message='Required field nc_parent_client is unset!')
        if self.filter_parameter is None:
            raise TProtocolException(message='Required field filter_parameter is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_child_clients_args)
get_all_child_clients_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'nc_parent_client', [ncClient.ttypes.ncParentClient, None], None, ),  # 1
    (2, TType.STRUCT, 'filter_parameter', [ncClient.ttypes.ncChildClientFilterParameter, None], None, ),  # 2
)


class get_all_child_clients_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = ncClient.ttypes.ncTClient()
                        _elem133.read(iprot)
                        self.success.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_child_clients_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter134 in self.success:
                iter134.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_child_clients_result)
get_all_child_clients_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_parent_clients_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_parent_clients_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.clientId is None:
            raise TProtocolException(message='Required field clientId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_parent_clients_args)
get_parent_clients_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class get_parent_clients_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = ncClient.ttypes.ncTClient()
                        _elem140.read(iprot)
                        self.success.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_parent_clients_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter141 in self.success:
                iter141.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_parent_clients_result)
get_parent_clients_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_hadoop_info_args(object):
    """
    Attributes:
     - nc_parent_client

    """


    def __init__(self, nc_parent_client=None,):
        self.nc_parent_client = nc_parent_client

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.nc_parent_client = ncClient.ttypes.ncParentClient()
                    self.nc_parent_client.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_hadoop_info_args')
        if self.nc_parent_client is not None:
            oprot.writeFieldBegin('nc_parent_client', TType.STRUCT, 1)
            self.nc_parent_client.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nc_parent_client is None:
            raise TProtocolException(message='Required field nc_parent_client is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_hadoop_info_args)
get_hadoop_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'nc_parent_client', [ncClient.ttypes.ncParentClient, None], None, ),  # 1
)


class get_hadoop_info_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncClientHadoopInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_hadoop_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_hadoop_info_result)
get_hadoop_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncClientHadoopInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_mongodb_client_info_args(object):
    """
    Attributes:
     - parent_client_id
     - child_client_id

    """


    def __init__(self, parent_client_id=None, child_client_id=None,):
        self.parent_client_id = parent_client_id
        self.child_client_id = child_client_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.parent_client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.child_client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_mongodb_client_info_args')
        if self.parent_client_id is not None:
            oprot.writeFieldBegin('parent_client_id', TType.STRING, 1)
            oprot.writeString(self.parent_client_id.encode('utf-8') if sys.version_info[0] == 2 else self.parent_client_id)
            oprot.writeFieldEnd()
        if self.child_client_id is not None:
            oprot.writeFieldBegin('child_client_id', TType.STRING, 2)
            oprot.writeString(self.child_client_id.encode('utf-8') if sys.version_info[0] == 2 else self.child_client_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_mongodb_client_info_args)
get_mongodb_client_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'parent_client_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'child_client_id', 'UTF8', None, ),  # 2
)


class get_mongodb_client_info_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncMongodbClientInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_mongodb_client_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_mongodb_client_info_result)
get_mongodb_client_info_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncMongodbClientInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class client_authorize_args(object):
    """
    Attributes:
     - cliDisReq

    """


    def __init__(self, cliDisReq=None,):
        self.cliDisReq = cliDisReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cliDisReq = ncClient.ttypes.ncClientDistriReq()
                    self.cliDisReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_authorize_args')
        if self.cliDisReq is not None:
            oprot.writeFieldBegin('cliDisReq', TType.STRUCT, 1)
            self.cliDisReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cliDisReq is None:
            raise TProtocolException(message='Required field cliDisReq is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_authorize_args)
client_authorize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cliDisReq', [ncClient.ttypes.ncClientDistriReq, None], None, ),  # 1
)


class client_authorize_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncClientDistriRes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_authorize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_authorize_result)
client_authorize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncClientDistriRes, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class platform_authorize_args(object):
    """
    Attributes:
     - platDisReq

    """


    def __init__(self, platDisReq=None,):
        self.platDisReq = platDisReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.platDisReq = ncPlatform.ttypes.ncPlatformDistriReq()
                    self.platDisReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('platform_authorize_args')
        if self.platDisReq is not None:
            oprot.writeFieldBegin('platDisReq', TType.STRUCT, 1)
            self.platDisReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.platDisReq is None:
            raise TProtocolException(message='Required field platDisReq is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(platform_authorize_args)
platform_authorize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'platDisReq', [ncPlatform.ttypes.ncPlatformDistriReq, None], None, ),  # 1
)


class platform_authorize_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncPlatform.ttypes.ncPlatformDistriRes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('platform_authorize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(platform_authorize_result)
platform_authorize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncPlatform.ttypes.ncPlatformDistriRes, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_servers_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncServer.ttypes.ncGetServerRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_args)
get_servers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncServer.ttypes.ncGetServerRequest, None], None, ),  # 1
)


class get_servers_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype145, _size142) = iprot.readListBegin()
                    for _i146 in range(_size142):
                        _elem147 = ncServer.ttypes.ncServer()
                        _elem147.read(iprot)
                        self.success.append(_elem147)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_servers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter148 in self.success:
                iter148.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_servers_result)
get_servers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncServer.ttypes.ncServer, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class del_auth_users_task_args(object):
    """
    Attributes:
     - authReq

    """


    def __init__(self, authReq=None,):
        self.authReq = authReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.authReq = ncClient.ttypes.ncClientAuthReq()
                    self.authReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_auth_users_task_args')
        if self.authReq is not None:
            oprot.writeFieldBegin('authReq', TType.STRUCT, 1)
            self.authReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_auth_users_task_args)
del_auth_users_task_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'authReq', [ncClient.ttypes.ncClientAuthReq, None], None, ),  # 1
)


class del_auth_users_task_result(object):
    """
    Attributes:
     - success
     - errors

    """


    def __init__(self, success=None, errors=None,):
        self.success = success
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncClientAuthRes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.errors = ncException.ttypes.ncException()
                    self.errors.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('del_auth_users_task_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.STRUCT, 1)
            self.errors.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(del_auth_users_task_result)
del_auth_users_task_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncClientAuthRes, None], None, ),  # 0
    (1, TType.STRUCT, 'errors', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_state_auth_users_task_args(object):
    """
    Attributes:
     - authReq
     - state

    """


    def __init__(self, authReq=None, state=None,):
        self.authReq = authReq
        self.state = state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.authReq = ncClient.ttypes.ncClientAuthReq()
                    self.authReq.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_state_auth_users_task_args')
        if self.authReq is not None:
            oprot.writeFieldBegin('authReq', TType.STRUCT, 1)
            self.authReq.write(oprot)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_state_auth_users_task_args)
update_state_auth_users_task_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'authReq', [ncClient.ttypes.ncClientAuthReq, None], None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
)


class update_state_auth_users_task_result(object):
    """
    Attributes:
     - success
     - errors

    """


    def __init__(self, success=None, errors=None,):
        self.success = success
        self.errors = errors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncClientAuthRes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.errors = ncException.ttypes.ncException()
                    self.errors.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_state_auth_users_task_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.errors is not None:
            oprot.writeFieldBegin('errors', TType.STRUCT, 1)
            self.errors.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_state_auth_users_task_result)
update_state_auth_users_task_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncClientAuthRes, None], None, ),  # 0
    (1, TType.STRUCT, 'errors', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_strategy_args(object):
    """
    Attributes:
     - strategyId

    """


    def __init__(self, strategyId=None,):
        self.strategyId = strategyId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.strategyId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_args')
        if self.strategyId is not None:
            oprot.writeFieldBegin('strategyId', TType.STRING, 1)
            oprot.writeString(self.strategyId.encode('utf-8') if sys.version_info[0] == 2 else self.strategyId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_args)
get_strategy_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'strategyId', 'UTF8', None, ),  # 1
)


class get_strategy_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncStrategy.ttypes.ncStrategyInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_result)
get_strategy_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncStrategy.ttypes.ncStrategyInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_strategy_by_name_and_job_type_args(object):
    """
    Attributes:
     - strategy_name
     - job_type

    """


    def __init__(self, strategy_name=None, job_type=None,):
        self.strategy_name = strategy_name
        self.job_type = job_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.strategy_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_by_name_and_job_type_args')
        if self.strategy_name is not None:
            oprot.writeFieldBegin('strategy_name', TType.STRING, 1)
            oprot.writeString(self.strategy_name.encode('utf-8') if sys.version_info[0] == 2 else self.strategy_name)
            oprot.writeFieldEnd()
        if self.job_type is not None:
            oprot.writeFieldBegin('job_type', TType.STRING, 2)
            oprot.writeString(self.job_type.encode('utf-8') if sys.version_info[0] == 2 else self.job_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_by_name_and_job_type_args)
get_strategy_by_name_and_job_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'strategy_name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_type', 'UTF8', None, ),  # 2
)


class get_strategy_by_name_and_job_type_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncStrategy.ttypes.ncStrategyInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_strategy_by_name_and_job_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_strategy_by_name_and_job_type_result)
get_strategy_by_name_and_job_type_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncStrategy.ttypes.ncStrategyInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_strategy_schedule_args(object):
    """
    Attributes:
     - strategyId
     - job_id
     - begin_time

    """


    def __init__(self, strategyId=None, job_id=None, begin_time=None,):
        self.strategyId = strategyId
        self.job_id = job_id
        self.begin_time = begin_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.strategyId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.begin_time = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_strategy_schedule_args')
        if self.strategyId is not None:
            oprot.writeFieldBegin('strategyId', TType.STRING, 1)
            oprot.writeString(self.strategyId.encode('utf-8') if sys.version_info[0] == 2 else self.strategyId)
            oprot.writeFieldEnd()
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 2)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.begin_time is not None:
            oprot.writeFieldBegin('begin_time', TType.STRING, 3)
            oprot.writeString(self.begin_time.encode('utf-8') if sys.version_info[0] == 2 else self.begin_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_strategy_schedule_args)
create_strategy_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'strategyId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'begin_time', 'UTF8', None, ),  # 3
)


class create_strategy_schedule_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_strategy_schedule_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_strategy_schedule_result)
create_strategy_schedule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_strategy_schedule_args(object):
    """
    Attributes:
     - strategyId
     - job_id
     - begin_time

    """


    def __init__(self, strategyId=None, job_id=None, begin_time=None,):
        self.strategyId = strategyId
        self.job_id = job_id
        self.begin_time = begin_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.strategyId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.begin_time = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_strategy_schedule_args')
        if self.strategyId is not None:
            oprot.writeFieldBegin('strategyId', TType.STRING, 1)
            oprot.writeString(self.strategyId.encode('utf-8') if sys.version_info[0] == 2 else self.strategyId)
            oprot.writeFieldEnd()
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 2)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.begin_time is not None:
            oprot.writeFieldBegin('begin_time', TType.STRING, 3)
            oprot.writeString(self.begin_time.encode('utf-8') if sys.version_info[0] == 2 else self.begin_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_strategy_schedule_args)
modify_strategy_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'strategyId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'begin_time', 'UTF8', None, ),  # 3
)


class modify_strategy_schedule_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_strategy_schedule_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_strategy_schedule_result)
modify_strategy_schedule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class new_modify_strategy_schedule_args(object):
    """
    Attributes:
     - schedules

    """


    def __init__(self, schedules=None,):
        self.schedules = schedules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schedules = []
                    (_etype152, _size149) = iprot.readListBegin()
                    for _i153 in range(_size149):
                        _elem154 = ncStrategy.ttypes.ncScheduleInfo()
                        _elem154.read(iprot)
                        self.schedules.append(_elem154)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('new_modify_strategy_schedule_args')
        if self.schedules is not None:
            oprot.writeFieldBegin('schedules', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schedules))
            for iter155 in self.schedules:
                iter155.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(new_modify_strategy_schedule_args)
new_modify_strategy_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schedules', (TType.STRUCT, [ncStrategy.ttypes.ncScheduleInfo, None], False), None, ),  # 1
)


class new_modify_strategy_schedule_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('new_modify_strategy_schedule_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(new_modify_strategy_schedule_result)
new_modify_strategy_schedule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_strategy_schedule_args(object):
    """
    Attributes:
     - job_id
     - host_id

    """


    def __init__(self, job_id=None, host_id=None,):
        self.job_id = job_id
        self.host_id = host_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.host_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_strategy_schedule_args')
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 1)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.host_id is not None:
            oprot.writeFieldBegin('host_id', TType.STRING, 2)
            oprot.writeString(self.host_id.encode('utf-8') if sys.version_info[0] == 2 else self.host_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_strategy_schedule_args)
delete_strategy_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'job_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'host_id', 'UTF8', None, ),  # 2
)


class delete_strategy_schedule_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_strategy_schedule_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_strategy_schedule_result)
delete_strategy_schedule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_cur_strategy_schedule_args(object):
    """
    Attributes:
     - plan_id_list

    """


    def __init__(self, plan_id_list=None,):
        self.plan_id_list = plan_id_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.plan_id_list = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.plan_id_list.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_cur_strategy_schedule_args')
        if self.plan_id_list is not None:
            oprot.writeFieldBegin('plan_id_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.plan_id_list))
            for iter162 in self.plan_id_list:
                oprot.writeString(iter162.encode('utf-8') if sys.version_info[0] == 2 else iter162)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_cur_strategy_schedule_args)
delete_cur_strategy_schedule_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'plan_id_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class delete_cur_strategy_schedule_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_cur_strategy_schedule_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_cur_strategy_schedule_result)
delete_cur_strategy_schedule_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clientid_nctclient_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncClient.ttypes.ncClientFilterRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clientid_nctclient_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clientid_nctclient_args)
get_clientid_nctclient_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncClient.ttypes.ncClientFilterRequest, None], None, ),  # 1
)


class get_clientid_nctclient_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype164, _vtype165, _size163) = iprot.readMapBegin()
                    for _i167 in range(_size163):
                        _key168 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val169 = ncClient.ttypes.ncTClient()
                        _val169.read(iprot)
                        self.success[_key168] = _val169
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clientid_nctclient_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter170, viter171 in self.success.items():
                oprot.writeString(kiter170.encode('utf-8') if sys.version_info[0] == 2 else kiter170)
                viter171.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clientid_nctclient_result)
get_clientid_nctclient_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_configs_by_client_id_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_configs_by_client_id_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_configs_by_client_id_args)
get_client_configs_by_client_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class get_client_configs_by_client_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = ncClient.ttypes.ncTClientConfig()
                        _elem177.read(iprot)
                        self.success.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_configs_by_client_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter178 in self.success:
                iter178.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_configs_by_client_id_result)
get_client_configs_by_client_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClientConfig, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fp_user_status_args(object):
    """
    Attributes:
     - fp_id
     - user_name

    """


    def __init__(self, fp_id=None, user_name=None,):
        self.fp_id = fp_id
        self.user_name = user_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fp_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_user_status_args')
        if self.fp_id is not None:
            oprot.writeFieldBegin('fp_id', TType.STRING, 1)
            oprot.writeString(self.fp_id.encode('utf-8') if sys.version_info[0] == 2 else self.fp_id)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 2)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_user_status_args)
get_fp_user_status_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fp_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'user_name', 'UTF8', None, ),  # 2
)


class get_fp_user_status_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_user_status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_user_status_result)
get_fp_user_status_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fp_by_node_ip_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_by_node_ip_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_by_node_ip_args)
get_fp_by_node_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_fp_by_node_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_by_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_by_node_ip_result)
get_fp_by_node_ip_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_contentcloudresourceid_resourceobj_args(object):
    """
    Attributes:
     - request

    """


    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = ncClient.ttypes.ncContentCloudResourceQueryRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_contentcloudresourceid_resourceobj_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.request is None:
            raise TProtocolException(message='Required field request is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_contentcloudresourceid_resourceobj_args)
get_contentcloudresourceid_resourceobj_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'request', [ncClient.ttypes.ncContentCloudResourceQueryRequest, None], None, ),  # 1
)


class get_contentcloudresourceid_resourceobj_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype180, _vtype181, _size179) = iprot.readMapBegin()
                    for _i183 in range(_size179):
                        _key184 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val185 = ncClient.ttypes.ncContentCloudResourceResponse()
                        _val185.read(iprot)
                        self.success[_key184] = _val185
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_contentcloudresourceid_resourceobj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter186, viter187 in self.success.items():
                oprot.writeString(kiter186.encode('utf-8') if sys.version_info[0] == 2 else kiter186)
                viter187.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_contentcloudresourceid_resourceobj_result)
get_contentcloudresourceid_resourceobj_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncClient.ttypes.ncContentCloudResourceResponse, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_username_by_flguid_args(object):
    """
    Attributes:
     - flguid

    """


    def __init__(self, flguid=None,):
        self.flguid = flguid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flguid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_username_by_flguid_args')
        if self.flguid is not None:
            oprot.writeFieldBegin('flguid', TType.STRING, 1)
            oprot.writeString(self.flguid.encode('utf-8') if sys.version_info[0] == 2 else self.flguid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_username_by_flguid_args)
get_username_by_flguid_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flguid', 'UTF8', None, ),  # 1
)


class get_username_by_flguid_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_username_by_flguid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_username_by_flguid_result)
get_username_by_flguid_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_recovery_client_args(object):
    """
    Attributes:
     - client_id

    """


    def __init__(self, client_id=None,):
        self.client_id = client_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_recovery_client_args')
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 1)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_recovery_client_args)
delete_recovery_client_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_id', 'UTF8', None, ),  # 1
)


class delete_recovery_client_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_recovery_client_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_recovery_client_result)
delete_recovery_client_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class delete_recovery_clients_args(object):
    """
    Attributes:
     - client_ids

    """


    def __init__(self, client_ids=None,):
        self.client_ids = client_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.client_ids = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.client_ids.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_recovery_clients_args')
        if self.client_ids is not None:
            oprot.writeFieldBegin('client_ids', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.client_ids))
            for iter194 in self.client_ids:
                oprot.writeString(iter194.encode('utf-8') if sys.version_info[0] == 2 else iter194)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_recovery_clients_args)
delete_recovery_clients_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'client_ids', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class delete_recovery_clients_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_recovery_clients_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_recovery_clients_result)
delete_recovery_clients_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_job_message_for_ams_args(object):
    """
    Attributes:
     - jobId
     - msgMethod

    """


    def __init__(self, jobId=None, msgMethod=None,):
        self.jobId = jobId
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_job_message_for_ams_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_job_message_for_ams_args)
update_job_message_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_job_message_for_ams_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_job_message_for_ams_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_job_message_for_ams_result)
update_job_message_for_ams_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class add_recovery_job_for_ams_args(object):
    """
    Attributes:
     - jobId

    """


    def __init__(self, jobId=None,):
        self.jobId = jobId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jobId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_recovery_job_for_ams_args')
        if self.jobId is not None:
            oprot.writeFieldBegin('jobId', TType.STRING, 1)
            oprot.writeString(self.jobId.encode('utf-8') if sys.version_info[0] == 2 else self.jobId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_recovery_job_for_ams_args)
add_recovery_job_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jobId', 'UTF8', None, ),  # 1
)


class add_recovery_job_for_ams_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_recovery_job_for_ams_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_recovery_job_for_ams_result)
add_recovery_job_for_ams_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_task_log_message_args(object):
    """
    Attributes:
     - instanceId
     - msgMethod

    """


    def __init__(self, instanceId=None, msgMethod=None,):
        self.instanceId = instanceId
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instanceId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_log_message_args')
        if self.instanceId is not None:
            oprot.writeFieldBegin('instanceId', TType.STRING, 1)
            oprot.writeString(self.instanceId.encode('utf-8') if sys.version_info[0] == 2 else self.instanceId)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_log_message_args)
get_task_log_message_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'instanceId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class get_task_log_message_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_task_log_message_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_task_log_message_result)
get_task_log_message_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_delete_job_message_args(object):
    """
    Attributes:
     - taskId

    """


    def __init__(self, taskId=None,):
        self.taskId = taskId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.taskId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_delete_job_message_args')
        if self.taskId is not None:
            oprot.writeFieldBegin('taskId', TType.STRING, 1)
            oprot.writeString(self.taskId.encode('utf-8') if sys.version_info[0] == 2 else self.taskId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_delete_job_message_args)
get_delete_job_message_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'taskId', 'UTF8', None, ),  # 1
)


class get_delete_job_message_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_delete_job_message_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_delete_job_message_result)
get_delete_job_message_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_clean_job_args(object):
    """
    Attributes:
     - clean_job

    """


    def __init__(self, clean_job=None,):
        self.clean_job = clean_job

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.clean_job = ncAmsJob.ttypes.ncAmsJobType()
                    self.clean_job.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clean_job_args')
        if self.clean_job is not None:
            oprot.writeFieldBegin('clean_job', TType.STRUCT, 1)
            self.clean_job.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clean_job_args)
create_clean_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'clean_job', [ncAmsJob.ttypes.ncAmsJobType, None], None, ),  # 1
)


class create_clean_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_clean_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_clean_job_result)
create_clean_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_remote_job_log_args(object):
    """
    Attributes:
     - jobInstance
     - msgMethod

    """


    def __init__(self, jobInstance=None, msgMethod=None,):
        self.jobInstance = jobInstance
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.jobInstance = ncAmsJob.ttypes.ncJobLog()
                    self.jobInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_remote_job_log_args')
        if self.jobInstance is not None:
            oprot.writeFieldBegin('jobInstance', TType.STRUCT, 1)
            self.jobInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_remote_job_log_args)
update_remote_job_log_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'jobInstance', [ncAmsJob.ttypes.ncJobLog, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_remote_job_log_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_remote_job_log_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_remote_job_log_result)
update_remote_job_log_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_remote_job_args(object):
    """
    Attributes:
     - job
     - msgMethod

    """


    def __init__(self, job=None, msgMethod=None,):
        self.job = job
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.job = ncAmsJob.ttypes.ncAmsJobType()
                    self.job.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_remote_job_args')
        if self.job is not None:
            oprot.writeFieldBegin('job', TType.STRUCT, 1)
            self.job.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_remote_job_args)
update_remote_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'job', [ncAmsJob.ttypes.ncAmsJobType, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_remote_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_remote_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_remote_job_result)
update_remote_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdm_backup_job_args(object):
    """
    Attributes:
     - job
     - msgMethod

    """


    def __init__(self, job=None, msgMethod=None,):
        self.job = job
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.job = ncAmsJob.ttypes.ncAmsJobType()
                    self.job.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_backup_job_args')
        if self.job is not None:
            oprot.writeFieldBegin('job', TType.STRUCT, 1)
            self.job.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_backup_job_args)
update_cdm_backup_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'job', [ncAmsJob.ttypes.ncAmsJobType, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdm_backup_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_backup_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_backup_job_result)
update_cdm_backup_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdm_backup_job_history_args(object):
    """
    Attributes:
     - jobInstance
     - msgMethod

    """


    def __init__(self, jobInstance=None, msgMethod=None,):
        self.jobInstance = jobInstance
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.jobInstance = ncAmsJob.ttypes.ncJobLog()
                    self.jobInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_backup_job_history_args')
        if self.jobInstance is not None:
            oprot.writeFieldBegin('jobInstance', TType.STRUCT, 1)
            self.jobInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_backup_job_history_args)
update_cdm_backup_job_history_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'jobInstance', [ncAmsJob.ttypes.ncJobLog, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdm_backup_job_history_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_backup_job_history_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_backup_job_history_result)
update_cdm_backup_job_history_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdm_mount_job_args(object):
    """
    Attributes:
     - job
     - msgMethod

    """


    def __init__(self, job=None, msgMethod=None,):
        self.job = job
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.job = ncAmsJob.ttypes.ncAmsJobType()
                    self.job.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_mount_job_args')
        if self.job is not None:
            oprot.writeFieldBegin('job', TType.STRUCT, 1)
            self.job.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_mount_job_args)
update_cdm_mount_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'job', [ncAmsJob.ttypes.ncAmsJobType, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdm_mount_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_mount_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_mount_job_result)
update_cdm_mount_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdp_job_args(object):
    """
    Attributes:
     - job
     - msgMethod

    """


    def __init__(self, job=None, msgMethod=None,):
        self.job = job
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.job = ncAmsJob.ttypes.ncAmsJobType()
                    self.job.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdp_job_args')
        if self.job is not None:
            oprot.writeFieldBegin('job', TType.STRUCT, 1)
            self.job.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdp_job_args)
update_cdp_job_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'job', [ncAmsJob.ttypes.ncAmsJobType, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdp_job_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdp_job_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdp_job_result)
update_cdp_job_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdp_job_instance_args(object):
    """
    Attributes:
     - jobInstance
     - msgMethod

    """


    def __init__(self, jobInstance=None, msgMethod=None,):
        self.jobInstance = jobInstance
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.jobInstance = ncAmsJob.ttypes.ncJobLog()
                    self.jobInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdp_job_instance_args')
        if self.jobInstance is not None:
            oprot.writeFieldBegin('jobInstance', TType.STRUCT, 1)
            self.jobInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdp_job_instance_args)
update_cdp_job_instance_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'jobInstance', [ncAmsJob.ttypes.ncJobLog, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdp_job_instance_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdp_job_instance_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdp_job_instance_result)
update_cdp_job_instance_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class project_user_authorize_args(object):
    """
    Attributes:
     - projectUserDisReq

    """


    def __init__(self, projectUserDisReq=None,):
        self.projectUserDisReq = projectUserDisReq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.projectUserDisReq = ncProjectUser.ttypes.ncProjectUserDistriReq()
                    self.projectUserDisReq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('project_user_authorize_args')
        if self.projectUserDisReq is not None:
            oprot.writeFieldBegin('projectUserDisReq', TType.STRUCT, 1)
            self.projectUserDisReq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectUserDisReq is None:
            raise TProtocolException(message='Required field projectUserDisReq is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(project_user_authorize_args)
project_user_authorize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'projectUserDisReq', [ncProjectUser.ttypes.ncProjectUserDistriReq, None], None, ),  # 1
)


class project_user_authorize_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncProjectUser.ttypes.ncProjectUserDistriRes()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('project_user_authorize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(project_user_authorize_result)
project_user_authorize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncProjectUser.ttypes.ncProjectUserDistriRes, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_newest_projectuser_args(object):
    """
    Attributes:
     - projectuserIds
     - decrypt

    """


    def __init__(self, projectuserIds=None, decrypt=None,):
        self.projectuserIds = projectuserIds
        self.decrypt = decrypt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.projectuserIds = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.projectuserIds.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.decrypt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_projectuser_args')
        if self.projectuserIds is not None:
            oprot.writeFieldBegin('projectuserIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.projectuserIds))
            for iter201 in self.projectuserIds:
                oprot.writeString(iter201.encode('utf-8') if sys.version_info[0] == 2 else iter201)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.decrypt is not None:
            oprot.writeFieldBegin('decrypt', TType.BOOL, 2)
            oprot.writeBool(self.decrypt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_projectuser_args)
get_newest_projectuser_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'projectuserIds', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'decrypt', None, None, ),  # 2
)


class get_newest_projectuser_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype203, _vtype204, _size202) = iprot.readMapBegin()
                    for _i206 in range(_size202):
                        _key207 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val208 = ncProjectUser.ttypes.ncTProjectUser()
                        _val208.read(iprot)
                        self.success[_key207] = _val208
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_projectuser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter209, viter210 in self.success.items():
                oprot.writeString(kiter209.encode('utf-8') if sys.version_info[0] == 2 else kiter209)
                viter210.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_projectuser_result)
get_newest_projectuser_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncProjectUser.ttypes.ncTProjectUser, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_newest_projectstorage_args(object):
    """
    Attributes:
     - projectId

    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_projectstorage_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_projectstorage_args)
get_newest_projectstorage_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class get_newest_projectstorage_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype214, _size211) = iprot.readListBegin()
                    for _i215 in range(_size211):
                        _elem216 = ncProjectUser.ttypes.ncTProjectStorage()
                        _elem216.read(iprot)
                        self.success.append(_elem216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_newest_projectstorage_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter217 in self.success:
                iter217.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_newest_projectstorage_result)
get_newest_projectstorage_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncProjectUser.ttypes.ncTProjectStorage, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_cdm_mount_job_instance_args(object):
    """
    Attributes:
     - jobInstance
     - msgMethod

    """


    def __init__(self, jobInstance=None, msgMethod=None,):
        self.jobInstance = jobInstance
        self.msgMethod = msgMethod

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.jobInstance = ncAmsJob.ttypes.ncJobLog()
                    self.jobInstance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msgMethod = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_mount_job_instance_args')
        if self.jobInstance is not None:
            oprot.writeFieldBegin('jobInstance', TType.STRUCT, 1)
            self.jobInstance.write(oprot)
            oprot.writeFieldEnd()
        if self.msgMethod is not None:
            oprot.writeFieldBegin('msgMethod', TType.STRING, 2)
            oprot.writeString(self.msgMethod.encode('utf-8') if sys.version_info[0] == 2 else self.msgMethod)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_mount_job_instance_args)
update_cdm_mount_job_instance_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'jobInstance', [ncAmsJob.ttypes.ncJobLog, None], None, ),  # 1
    (2, TType.STRING, 'msgMethod', 'UTF8', None, ),  # 2
)


class update_cdm_mount_job_instance_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_cdm_mount_job_instance_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_cdm_mount_job_instance_result)
update_cdm_mount_job_instance_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_count_by_auth_user_args(object):
    """
    Attributes:
     - username

    """


    def __init__(self, username=None,):
        self.username = username

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_count_by_auth_user_args')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_count_by_auth_user_args)
get_client_count_by_auth_user_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
)


class get_client_count_by_auth_user_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_count_by_auth_user_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_count_by_auth_user_result)
get_client_count_by_auth_user_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_clients_by_vir_platform_args(object):
    """
    Attributes:
     - vir_platform_id

    """


    def __init__(self, vir_platform_id=None,):
        self.vir_platform_id = vir_platform_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.vir_platform_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_vir_platform_args')
        if self.vir_platform_id is not None:
            oprot.writeFieldBegin('vir_platform_id', TType.STRING, 1)
            oprot.writeString(self.vir_platform_id.encode('utf-8') if sys.version_info[0] == 2 else self.vir_platform_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_vir_platform_args)
get_clients_by_vir_platform_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'vir_platform_id', 'UTF8', None, ),  # 1
)


class get_clients_by_vir_platform_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype221, _size218) = iprot.readListBegin()
                    for _i222 in range(_size218):
                        _elem223 = ncClient.ttypes.ncTClient()
                        _elem223.read(iprot)
                        self.success.append(_elem223)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_clients_by_vir_platform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter224 in self.success:
                iter224.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_clients_by_vir_platform_result)
get_clients_by_vir_platform_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_by_vir_platform_and_node_args(object):
    """
    Attributes:
     - vir_platform_id
     - node_id

    """


    def __init__(self, vir_platform_id=None, node_id=None,):
        self.vir_platform_id = vir_platform_id
        self.node_id = node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.vir_platform_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_vir_platform_and_node_args')
        if self.vir_platform_id is not None:
            oprot.writeFieldBegin('vir_platform_id', TType.STRING, 1)
            oprot.writeString(self.vir_platform_id.encode('utf-8') if sys.version_info[0] == 2 else self.vir_platform_id)
            oprot.writeFieldEnd()
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 2)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_vir_platform_and_node_args)
get_client_by_vir_platform_and_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'vir_platform_id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'node_id', None, None, ),  # 2
)


class get_client_by_vir_platform_and_node_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncTClient()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_vir_platform_and_node_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_vir_platform_and_node_result)
get_client_by_vir_platform_and_node_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncTClient, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_data_for_ams_args(object):
    """
    Attributes:
     - kwargs

    """


    def __init__(self, kwargs=None,):
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_args')
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 1)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_args)
get_data_for_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'kwargs', 'UTF8', None, ),  # 1
)


class get_data_for_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_data_for_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_data_for_ams_result)
get_data_for_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class do_operation_from_ams_args(object):
    """
    Attributes:
     - target
     - method
     - kwargs

    """


    def __init__(self, target=None, method=None, kwargs=None,):
        self.target = target
        self.method = method
        self.kwargs = kwargs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.target = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.method = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.kwargs = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_args')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.STRING, 1)
            oprot.writeString(self.target.encode('utf-8') if sys.version_info[0] == 2 else self.target)
            oprot.writeFieldEnd()
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 2)
            oprot.writeString(self.method.encode('utf-8') if sys.version_info[0] == 2 else self.method)
            oprot.writeFieldEnd()
        if self.kwargs is not None:
            oprot.writeFieldBegin('kwargs', TType.STRING, 3)
            oprot.writeString(self.kwargs.encode('utf-8') if sys.version_info[0] == 2 else self.kwargs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_args)
do_operation_from_ams_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'target', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'method', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'kwargs', 'UTF8', None, ),  # 3
)


class do_operation_from_ams_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('do_operation_from_ams_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(do_operation_from_ams_result)
do_operation_from_ams_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_cluster_datasource_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = ncDataSource.ttypes.ncDataSourceRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_datasource_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_datasource_args)
get_cluster_datasource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [ncDataSource.ttypes.ncDataSourceRequest, None], None, ),  # 1
)


class get_cluster_datasource_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncDataSource.ttypes.ncClusterDataSourceSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_cluster_datasource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_cluster_datasource_result)
get_cluster_datasource_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncDataSource.ttypes.ncClusterDataSourceSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_virtual_machine_datasource_args(object):
    """
    Attributes:
     - client_id
     - req

    """


    def __init__(self, client_id=None, req=None,):
        self.client_id = client_id
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.req = ncDataSource.ttypes.ncDataSourceRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_virtual_machine_datasource_args')
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 1)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 2)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_virtual_machine_datasource_args)
get_virtual_machine_datasource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_id', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'req', [ncDataSource.ttypes.ncDataSourceRequest, None], None, ),  # 2
)


class get_virtual_machine_datasource_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncDataSource.ttypes.ncDataSourceSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_virtual_machine_datasource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_virtual_machine_datasource_result)
get_virtual_machine_datasource_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncDataSource.ttypes.ncDataSourceSet, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_by_ip_or_id_args(object):
    """
    Attributes:
     - client_ip
     - client_id

    """


    def __init__(self, client_ip=None, client_id=None,):
        self.client_ip = client_ip
        self.client_id = client_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.client_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.client_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_ip_or_id_args')
        if self.client_ip is not None:
            oprot.writeFieldBegin('client_ip', TType.STRING, 1)
            oprot.writeString(self.client_ip.encode('utf-8') if sys.version_info[0] == 2 else self.client_ip)
            oprot.writeFieldEnd()
        if self.client_id is not None:
            oprot.writeFieldBegin('client_id', TType.STRING, 2)
            oprot.writeString(self.client_id.encode('utf-8') if sys.version_info[0] == 2 else self.client_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_ip_or_id_args)
get_client_by_ip_or_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'client_ip', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'client_id', 'UTF8', None, ),  # 2
)


class get_client_by_ip_or_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncTClientDetails()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_by_ip_or_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_by_ip_or_id_result)
get_client_by_ip_or_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncTClientDetails, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_in_kvm_platform_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_in_kvm_platform_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_in_kvm_platform_args)
get_in_kvm_platform_args.thrift_spec = (
)


class get_in_kvm_platform_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype228, _size225) = iprot.readListBegin()
                    for _i229 in range(_size225):
                        _elem230 = ncPlatform.ttypes.ncInKvmTPlatform()
                        _elem230.read(iprot)
                        self.success.append(_elem230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_in_kvm_platform_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter231 in self.success:
                iter231.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_in_kvm_platform_result)
get_in_kvm_platform_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncPlatform.ttypes.ncInKvmTPlatform, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_or_create_fp_pool_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_or_create_fp_pool_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_or_create_fp_pool_args)
update_or_create_fp_pool_args.thrift_spec = (
)


class update_or_create_fp_pool_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_or_create_fp_pool_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_or_create_fp_pool_result)
update_or_create_fp_pool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_type_by_id_args(object):
    """
    Attributes:
     - clientId

    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_type_by_id_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_type_by_id_args)
get_client_type_by_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
)


class get_client_type_by_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_type_by_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_type_by_id_result)
get_client_type_by_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_user_source_args(object):
    """
    Attributes:
     - username
     - source

    """


    def __init__(self, username=None, source=None,):
        self.username = username
        self.source = source

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.source = ncClient.ttypes.ncSource()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_source_args')
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 1)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 2)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_source_args)
check_user_source_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'username', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'source', [ncClient.ttypes.ncSource, None], None, ),  # 2
)


class check_user_source_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_source_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_source_result)
check_user_source_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_server_by_client_ip_args(object):
    """
    Attributes:
     - ip

    """


    def __init__(self, ip=None,):
        self.ip = ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_by_client_ip_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_by_client_ip_args)
get_server_by_client_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
)


class get_server_by_client_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncServer.ttypes.ncServer()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_server_by_client_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_server_by_client_ip_result)
get_server_by_client_ip_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncServer.ttypes.ncServer, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_client_link_type_args(object):
    """
    Attributes:
     - configId
     - hostId
     - wwn

    """


    def __init__(self, configId=None, hostId=None, wwn=None,):
        self.configId = configId
        self.hostId = hostId
        self.wwn = wwn

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.configId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hostId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.wwn = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_link_type_args')
        if self.configId is not None:
            oprot.writeFieldBegin('configId', TType.STRING, 1)
            oprot.writeString(self.configId.encode('utf-8') if sys.version_info[0] == 2 else self.configId)
            oprot.writeFieldEnd()
        if self.hostId is not None:
            oprot.writeFieldBegin('hostId', TType.STRING, 2)
            oprot.writeString(self.hostId.encode('utf-8') if sys.version_info[0] == 2 else self.hostId)
            oprot.writeFieldEnd()
        if self.wwn is not None:
            oprot.writeFieldBegin('wwn', TType.STRING, 3)
            oprot.writeString(self.wwn.encode('utf-8') if sys.version_info[0] == 2 else self.wwn)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_link_type_args)
get_client_link_type_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'configId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hostId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'wwn', 'UTF8', None, ),  # 3
)


class get_client_link_type_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_client_link_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_client_link_type_result)
get_client_link_type_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_virtual_safety_users_args(object):
    """
    Attributes:
     - infos

    """


    def __init__(self, infos=None,):
        self.infos = infos

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.infos = ncVirtualSafety.ttypes.ncVirtualSafetyInfos()
                    self.infos.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_virtual_safety_users_args')
        if self.infos is not None:
            oprot.writeFieldBegin('infos', TType.STRUCT, 1)
            self.infos.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_virtual_safety_users_args)
get_virtual_safety_users_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'infos', [ncVirtualSafety.ttypes.ncVirtualSafetyInfos, None], None, ),  # 1
)


class get_virtual_safety_users_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncVirtualSafety.ttypes.ncVirtualSafetyUsers()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_virtual_safety_users_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_virtual_safety_users_result)
get_virtual_safety_users_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncVirtualSafety.ttypes.ncVirtualSafetyUsers, None], None, ),  # 0
)


class get_all_clients_to_log_args(object):
    """
    Attributes:
     - user_id

    """


    def __init__(self, user_id=None,):
        self.user_id = user_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clients_to_log_args')
        if self.user_id is not None:
            oprot.writeFieldBegin('user_id', TType.STRING, 1)
            oprot.writeString(self.user_id.encode('utf-8') if sys.version_info[0] == 2 else self.user_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clients_to_log_args)
get_all_clients_to_log_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user_id', 'UTF8', None, ),  # 1
)


class get_all_clients_to_log_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype235, _size232) = iprot.readListBegin()
                    for _i236 in range(_size232):
                        _elem237 = ncClient.ttypes.ncTClient()
                        _elem237.read(iprot)
                        self.success.append(_elem237)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_clients_to_log_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter238 in self.success:
                iter238.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_clients_to_log_result)
get_all_clients_to_log_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncTClient, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fp_node_info_by_node_ip_args(object):
    """
    Attributes:
     - node_ip

    """


    def __init__(self, node_ip=None,):
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_node_info_by_node_ip_args')
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 1)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_node_info_by_node_ip_args)
get_fp_node_info_by_node_ip_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'node_ip', 'UTF8', None, ),  # 1
)


class get_fp_node_info_by_node_ip_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype242, _size239) = iprot.readListBegin()
                    for _i243 in range(_size239):
                        _elem244 = ncClient.ttypes.ncFingerPoorInfo()
                        _elem244.read(iprot)
                        self.success.append(_elem244)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_node_info_by_node_ip_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter245 in self.success:
                iter245.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_node_info_by_node_ip_result)
get_fp_node_info_by_node_ip_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncFingerPoorInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fl_by_fpoor_id_args(object):
    """
    Attributes:
     - fp_id

    """


    def __init__(self, fp_id=None,):
        self.fp_id = fp_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fp_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fl_by_fpoor_id_args')
        if self.fp_id is not None:
            oprot.writeFieldBegin('fp_id', TType.STRING, 1)
            oprot.writeString(self.fp_id.encode('utf-8') if sys.version_info[0] == 2 else self.fp_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fl_by_fpoor_id_args)
get_fl_by_fpoor_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fp_id', 'UTF8', None, ),  # 1
)


class get_fl_by_fpoor_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fl_by_fpoor_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fl_by_fpoor_id_result)
get_fl_by_fpoor_id_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_finger_poor_nodes_args(object):
    """
    Attributes:
     - fp_id
     - node_ip

    """


    def __init__(self, fp_id=None, node_ip=None,):
        self.fp_id = fp_id
        self.node_ip = node_ip

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fp_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.node_ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_finger_poor_nodes_args')
        if self.fp_id is not None:
            oprot.writeFieldBegin('fp_id', TType.STRING, 1)
            oprot.writeString(self.fp_id.encode('utf-8') if sys.version_info[0] == 2 else self.fp_id)
            oprot.writeFieldEnd()
        if self.node_ip is not None:
            oprot.writeFieldBegin('node_ip', TType.STRING, 2)
            oprot.writeString(self.node_ip.encode('utf-8') if sys.version_info[0] == 2 else self.node_ip)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_finger_poor_nodes_args)
update_finger_poor_nodes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fp_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'node_ip', 'UTF8', None, ),  # 2
)


class update_finger_poor_nodes_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_finger_poor_nodes_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_finger_poor_nodes_result)
update_finger_poor_nodes_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fl_guid_ids_by_fp_id_args(object):
    """
    Attributes:
     - fp_id

    """


    def __init__(self, fp_id=None,):
        self.fp_id = fp_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fp_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fl_guid_ids_by_fp_id_args')
        if self.fp_id is not None:
            oprot.writeFieldBegin('fp_id', TType.STRING, 1)
            oprot.writeString(self.fp_id.encode('utf-8') if sys.version_info[0] == 2 else self.fp_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fl_guid_ids_by_fp_id_args)
get_fl_guid_ids_by_fp_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fp_id', 'UTF8', None, ),  # 1
)


class get_fl_guid_ids_by_fp_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype249, _size246) = iprot.readListBegin()
                    for _i250 in range(_size246):
                        _elem251 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem251)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fl_guid_ids_by_fp_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter252 in self.success:
                oprot.writeString(iter252.encode('utf-8') if sys.version_info[0] == 2 else iter252)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fl_guid_ids_by_fp_id_result)
get_fl_guid_ids_by_fp_id_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_protect_object_count_args(object):
    """
    Attributes:
     - user

    """


    def __init__(self, user=None,):
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = ncUser.ttypes.ncUserInfo()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_protect_object_count_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_protect_object_count_args)
get_protect_object_count_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [ncUser.ttypes.ncUserInfo, None], None, ),  # 1
)


class get_protect_object_count_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncProtectObjectCountInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_protect_object_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_protect_object_count_result)
get_protect_object_count_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncProtectObjectCountInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_clients_args(object):
    """
    Attributes:
     - clientId
     - customer
     - clusterPort

    """


    def __init__(self, clientId=None, customer=None, clusterPort=None,):
        self.clientId = clientId
        self.customer = customer
        self.clusterPort = clusterPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.customer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.clusterPort = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_clients_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 1)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.customer is not None:
            oprot.writeFieldBegin('customer', TType.STRING, 2)
            oprot.writeString(self.customer.encode('utf-8') if sys.version_info[0] == 2 else self.customer)
            oprot.writeFieldEnd()
        if self.clusterPort is not None:
            oprot.writeFieldBegin('clusterPort', TType.STRING, 3)
            oprot.writeString(self.clusterPort.encode('utf-8') if sys.version_info[0] == 2 else self.clusterPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_clients_args)
update_clients_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clientId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'customer', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'clusterPort', 'UTF8', None, ),  # 3
)


class update_clients_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_clients_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_clients_result)
update_clients_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_fp_data_by_primary_key_id_args(object):
    """
    Attributes:
     - primary_key_id

    """


    def __init__(self, primary_key_id=None,):
        self.primary_key_id = primary_key_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.primary_key_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_data_by_primary_key_id_args')
        if self.primary_key_id is not None:
            oprot.writeFieldBegin('primary_key_id', TType.STRING, 1)
            oprot.writeString(self.primary_key_id.encode('utf-8') if sys.version_info[0] == 2 else self.primary_key_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_data_by_primary_key_id_args)
get_fp_data_by_primary_key_id_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'primary_key_id', 'UTF8', None, ),  # 1
)


class get_fp_data_by_primary_key_id_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncClient.ttypes.ncFingerPoorsData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_fp_data_by_primary_key_id_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_fp_data_by_primary_key_id_result)
get_fp_data_by_primary_key_id_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncClient.ttypes.ncFingerPoorsData, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_backup_cloud_jobs_args(object):
    """
    Attributes:
     - query_all

    """


    def __init__(self, query_all=None,):
        self.query_all = query_all

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.query_all = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_cloud_jobs_args')
        if self.query_all is not None:
            oprot.writeFieldBegin('query_all', TType.BOOL, 1)
            oprot.writeBool(self.query_all)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_cloud_jobs_args)
get_backup_cloud_jobs_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'query_all', None, None, ),  # 1
)


class get_backup_cloud_jobs_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype256, _size253) = iprot.readListBegin()
                    for _i257 in range(_size253):
                        _elem258 = ncCloudStorage.ttypes.ncCloudTask()
                        _elem258.read(iprot)
                        self.success.append(_elem258)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_backup_cloud_jobs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter259 in self.success:
                iter259.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_backup_cloud_jobs_result)
get_backup_cloud_jobs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncCloudStorage.ttypes.ncCloudTask, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_projectuser_list_args(object):
    """
    Attributes:
     - cplatform_types

    """


    def __init__(self, cplatform_types=None,):
        self.cplatform_types = cplatform_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cplatform_types = []
                    (_etype263, _size260) = iprot.readListBegin()
                    for _i264 in range(_size260):
                        _elem265 = iprot.readI32()
                        self.cplatform_types.append(_elem265)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_projectuser_list_args')
        if self.cplatform_types is not None:
            oprot.writeFieldBegin('cplatform_types', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.cplatform_types))
            for iter266 in self.cplatform_types:
                oprot.writeI32(iter266)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_projectuser_list_args)
get_projectuser_list_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cplatform_types', (TType.I32, None, False), None, ),  # 1
)


class get_projectuser_list_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype268, _vtype269, _size267) = iprot.readMapBegin()
                    for _i271 in range(_size267):
                        _key272 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val273 = ncProjectUser.ttypes.ncTProjectUser()
                        _val273.read(iprot)
                        self.success[_key272] = _val273
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_projectuser_list_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter274, viter275 in self.success.items():
                oprot.writeString(kiter274.encode('utf-8') if sys.version_info[0] == 2 else kiter274)
                viter275.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_projectuser_list_result)
get_projectuser_list_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ncProjectUser.ttypes.ncTProjectUser, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_all_protect_object_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_protect_object_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_protect_object_args)
get_all_protect_object_args.thrift_spec = (
)


class get_all_protect_object_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype279, _size276) = iprot.readListBegin()
                    for _i280 in range(_size276):
                        _elem281 = ncClient.ttypes.ncProtectObjectInfo()
                        _elem281.read(iprot)
                        self.success.append(_elem281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_all_protect_object_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter282 in self.success:
                iter282.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_all_protect_object_result)
get_all_protect_object_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncClient.ttypes.ncProtectObjectInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class abstract_public_interface_args(object):
    """
    Attributes:
     - msg
     - body

    """


    def __init__(self, msg=None, body=None,):
        self.msg = msg
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.body = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abstract_public_interface_args')
        if self.msg is not None:
            oprot.writeFieldBegin('msg', TType.STRING, 1)
            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 2)
            oprot.writeString(self.body.encode('utf-8') if sys.version_info[0] == 2 else self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abstract_public_interface_args)
abstract_public_interface_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'body', 'UTF8', None, ),  # 2
)


class abstract_public_interface_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abstract_public_interface_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abstract_public_interface_result)
abstract_public_interface_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_get_appsys_args(object):
    """
    Attributes:
     - req

    """


    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = ncCCResource.ttypes.ncDatasourceCheckReq()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_get_appsys_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_get_appsys_args)
check_get_appsys_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'req', [ncCCResource.ttypes.ncDatasourceCheckReq, None], None, ),  # 1
)


class check_get_appsys_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncCCResource.ttypes.ncDatasourceResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_get_appsys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_get_appsys_result)
check_get_appsys_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncCCResource.ttypes.ncDatasourceResult, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class update_eceph_info_args(object):
    """
    Attributes:
     - cinfo

    """


    def __init__(self, cinfo=None,):
        self.cinfo = cinfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cinfo = ncCCResource.ttypes.ncCephInfo()
                    self.cinfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_eceph_info_args')
        if self.cinfo is not None:
            oprot.writeFieldBegin('cinfo', TType.STRUCT, 1)
            self.cinfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_eceph_info_args)
update_eceph_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cinfo', [ncCCResource.ttypes.ncCephInfo, None], None, ),  # 1
)


class update_eceph_info_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('update_eceph_info_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(update_eceph_info_result)
update_eceph_info_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_schedule_job_cur_node_args(object):
    """
    Attributes:
     - strategy_id
     - job_id
     - begin_time
     - is_modify_strategy

    """


    def __init__(self, strategy_id=None, job_id=None, begin_time=None, is_modify_strategy=None,):
        self.strategy_id = strategy_id
        self.job_id = job_id
        self.begin_time = begin_time
        self.is_modify_strategy = is_modify_strategy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.strategy_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.job_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.begin_time = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_modify_strategy = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_job_cur_node_args')
        if self.strategy_id is not None:
            oprot.writeFieldBegin('strategy_id', TType.STRING, 1)
            oprot.writeString(self.strategy_id.encode('utf-8') if sys.version_info[0] == 2 else self.strategy_id)
            oprot.writeFieldEnd()
        if self.job_id is not None:
            oprot.writeFieldBegin('job_id', TType.STRING, 2)
            oprot.writeString(self.job_id.encode('utf-8') if sys.version_info[0] == 2 else self.job_id)
            oprot.writeFieldEnd()
        if self.begin_time is not None:
            oprot.writeFieldBegin('begin_time', TType.STRING, 3)
            oprot.writeString(self.begin_time.encode('utf-8') if sys.version_info[0] == 2 else self.begin_time)
            oprot.writeFieldEnd()
        if self.is_modify_strategy is not None:
            oprot.writeFieldBegin('is_modify_strategy', TType.BOOL, 4)
            oprot.writeBool(self.is_modify_strategy)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_job_cur_node_args)
modify_schedule_job_cur_node_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'strategy_id', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'job_id', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'begin_time', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'is_modify_strategy', None, None, ),  # 4
)


class modify_schedule_job_cur_node_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_schedule_job_cur_node_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_schedule_job_cur_node_result)
modify_schedule_job_cur_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class check_user_has_data_args(object):
    """
    Attributes:
     - user_list

    """


    def __init__(self, user_list=None,):
        self.user_list = user_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.user_list = []
                    (_etype286, _size283) = iprot.readListBegin()
                    for _i287 in range(_size283):
                        _elem288 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.user_list.append(_elem288)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_args')
        if self.user_list is not None:
            oprot.writeFieldBegin('user_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.user_list))
            for iter289 in self.user_list:
                oprot.writeString(iter289.encode('utf-8') if sys.version_info[0] == 2 else iter289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_args)
check_user_has_data_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'user_list', (TType.STRING, 'UTF8', False), None, ),  # 1
)


class check_user_has_data_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype293, _size290) = iprot.readListBegin()
                    for _i294 in range(_size290):
                        _elem295 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('check_user_has_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter296 in self.success:
                oprot.writeString(iter296.encode('utf-8') if sys.version_info[0] == 2 else iter296)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(check_user_has_data_result)
check_user_has_data_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class create_schedules_cur_node_args(object):
    """
    Attributes:
     - schedules

    """


    def __init__(self, schedules=None,):
        self.schedules = schedules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schedules = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = ncStrategy.ttypes.ncScheduleInfo()
                        _elem302.read(iprot)
                        self.schedules.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_schedules_cur_node_args')
        if self.schedules is not None:
            oprot.writeFieldBegin('schedules', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schedules))
            for iter303 in self.schedules:
                iter303.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_schedules_cur_node_args)
create_schedules_cur_node_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schedules', (TType.STRUCT, [ncStrategy.ttypes.ncScheduleInfo, None], False), None, ),  # 1
)


class create_schedules_cur_node_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('create_schedules_cur_node_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(create_schedules_cur_node_result)
create_schedules_cur_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class modify_job_schedules_cur_node_args(object):
    """
    Attributes:
     - schedules

    """


    def __init__(self, schedules=None,):
        self.schedules = schedules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schedules = []
                    (_etype307, _size304) = iprot.readListBegin()
                    for _i308 in range(_size304):
                        _elem309 = ncStrategy.ttypes.ncScheduleInfo()
                        _elem309.read(iprot)
                        self.schedules.append(_elem309)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_job_schedules_cur_node_args')
        if self.schedules is not None:
            oprot.writeFieldBegin('schedules', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schedules))
            for iter310 in self.schedules:
                iter310.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_job_schedules_cur_node_args)
modify_job_schedules_cur_node_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schedules', (TType.STRUCT, [ncStrategy.ttypes.ncScheduleInfo, None], False), None, ),  # 1
)


class modify_job_schedules_cur_node_result(object):
    """
    Attributes:
     - error

    """


    def __init__(self, error=None,):
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modify_job_schedules_cur_node_result')
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modify_job_schedules_cur_node_result)
modify_job_schedules_cur_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_schedule_start_time_args(object):
    """
    Attributes:
     - schedules

    """


    def __init__(self, schedules=None,):
        self.schedules = schedules

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schedules = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = ncStrategy.ttypes.ncScheduleStartTimeInfo()
                        _elem316.read(iprot)
                        self.schedules.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_start_time_args')
        if self.schedules is not None:
            oprot.writeFieldBegin('schedules', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schedules))
            for iter317 in self.schedules:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_start_time_args)
get_schedule_start_time_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schedules', (TType.STRUCT, [ncStrategy.ttypes.ncScheduleStartTimeInfo, None], False), None, ),  # 1
)


class get_schedule_start_time_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = ncStrategy.ttypes.ncScheduleStartTimeResponse()
                        _elem323.read(iprot)
                        self.success.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_schedule_start_time_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter324 in self.success:
                iter324.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_schedule_start_time_result)
get_schedule_start_time_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncStrategy.ttypes.ncScheduleStartTimeResponse, None], False), None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)


class get_public_cloud_resource_args(object):
    """
    Attributes:
     - public_cloud_id

    """


    def __init__(self, public_cloud_id=None,):
        self.public_cloud_id = public_cloud_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_cloud_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_public_cloud_resource_args')
        if self.public_cloud_id is not None:
            oprot.writeFieldBegin('public_cloud_id', TType.STRING, 1)
            oprot.writeString(self.public_cloud_id.encode('utf-8') if sys.version_info[0] == 2 else self.public_cloud_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_public_cloud_resource_args)
get_public_cloud_resource_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'public_cloud_id', 'UTF8', None, ),  # 1
)


class get_public_cloud_resource_result(object):
    """
    Attributes:
     - success
     - error

    """


    def __init__(self, success=None, error=None,):
        self.success = success
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ncPublicCloud.ttypes.ncPublicCloudResource()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.error = ncException.ttypes.ncException()
                    self.error.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_public_cloud_resource_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRUCT, 1)
            self.error.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_public_cloud_resource_result)
get_public_cloud_resource_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ncPublicCloud.ttypes.ncPublicCloudResource, None], None, ),  # 0
    (1, TType.STRUCT, 'error', [ncException.ttypes.ncException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

