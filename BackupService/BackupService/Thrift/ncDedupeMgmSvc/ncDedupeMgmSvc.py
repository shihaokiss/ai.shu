# -*- coding: UTF-8 -*-
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=UTF-8
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    Dedupe服务接口

    """
    def GetDedupeNodes(self):
        """
        获取可用的重删节点ip
        @ return list<string>: 重删节点IP集合


        """
        pass

    def CreateFingerprintPool(self, poolInfo):
        """
           * 添加逻辑指纹库
           * @param poolInfo.poolName: 指纹库名称
        * @param poolInfo.poolType: 指纹库类型
        * @param poolInfo.poolGuid: 指纹库guid, 用于获取所有指纹库时的返回结果，创建指纹库时置空
        * @param poolInfo.nodeIPs:  指纹库节点IP列表
        * @param poolInfo.minSize: 数据切片最小值，固定写16
        * @param poolInfo.maxSize: 数据切片最大值，固定写128
        * @return string: 指纹库guid
           *
           * @throw 转抛内部调用异常

        Parameters:
         - poolInfo

        """
        pass

    def EditFingerprintPool(self, guid, nodeIPs):
        """
        编辑指纹库
        @param guid: 指纹库guid
        @param nodeIPs: 扩展的节点IP列表


        Parameters:
         - guid
         - nodeIPs

        """
        pass

    def GetFingerprintPoolNodes(self, guid):
        """
        获取指纹库下所有节点
        @param guid: 指纹库guid
        @param nodeIPs: 扩展的节点IP列表
        @return list<string>: 指纹库所用节点IP列表


        Parameters:
         - guid

        """
        pass

    def CheckFingerprintPoolStatus(self, guid):
        """
        检查指纹库是否被占用
        @param guid: 指纹库guid
        @return string: ""表示未占用，其他表示占用，内容为提示信息


        Parameters:
         - guid

        """
        pass

    def CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
        """
        检查节点指纹库是否被占用
        @param guid: 指纹库guid
        @param nodeGuid: 节点指纹库标识
        @return 未被占用返回true,占用返回false


        Parameters:
         - guid
         - nodeguid

        """
        pass

    def FaultDDcache(self):
        pass

    def DeleteFingerprintPool(self, guid):
        """
        删除指纹池

        @param guid: 指纹池guid

        @throw 转抛内部调用异常

        Parameters:
         - guid

        """
        pass

    def CleanFingerprintPool(self, guid):
        """
        清理指纹库

        @param guid: 指纹池guid

        @throw 转抛内部调用异常

        Parameters:
         - guid

        """
        pass

    def DeleteFingerprintPoolNodeLib(self):
        """
        通知删除节点指纹库

        @throw 转抛内部调用异常

        """
        pass

    def CleanFingerprintPoolNodeLib(self):
        """
        通知清理节点指纹库

        @throw 转抛内部调用异常

        """
        pass

    def GetAllFingerprintPools(self):
        """
        获取全部指纹库信息
         
        @return 指纹库信息列表

        @throw 转抛内部调用异常

        """
        pass

    def CreateDDcache(self, ddcachename, ddcachepath, size):
        """
        创建DDcache卷
        @param ddcachename: ddcache卷名称
        @param ddcachepath: ddcache卷路径
        @param size:ddcache卷大小


        Parameters:
         - ddcachename
         - ddcachepath
         - size

        """
        pass

    def DeleteDDcache(self, ddcachename):
        """
        删除DDcache卷
        @param ddcachename: ddcache卷名称


        Parameters:
         - ddcachename

        """
        pass

    def ExpansionDDcache(self, ddcachename, size):
        """
        DDcache卷扩容
        @param ddcachename: ddcache卷名称
        @param size: ddcache扩容容量

        Parameters:
         - ddcachename
         - size

        """
        pass

    def GetLocalAllDDcache(self):
        """
        查询ddcache
        @return list<ncDedupeMgmType.ncDDCacheInfo> :ddcache卷信息集


        """
        pass

    def CheckDDcacheCanDelete(self, ddcachename):
        """
        检测ddcache是否可删除
        @param ddcachename: ddcache卷名称
        @return list<string>: 指纹库名称


        Parameters:
         - ddcachename

        """
        pass


class Client(Iface):
    """
    Dedupe服务接口

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def GetDedupeNodes(self):
        """
        获取可用的重删节点ip
        @ return list<string>: 重删节点IP集合


        """
        self.send_GetDedupeNodes()
        return self.recv_GetDedupeNodes()

    def send_GetDedupeNodes(self):
        self._oprot.writeMessageBegin('GetDedupeNodes', TMessageType.CALL, self._seqid)
        args = GetDedupeNodes_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetDedupeNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetDedupeNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDedupeNodes failed: unknown result")

    def CreateFingerprintPool(self, poolInfo):
        """
           * 添加逻辑指纹库
           * @param poolInfo.poolName: 指纹库名称
        * @param poolInfo.poolType: 指纹库类型
        * @param poolInfo.poolGuid: 指纹库guid, 用于获取所有指纹库时的返回结果，创建指纹库时置空
        * @param poolInfo.nodeIPs:  指纹库节点IP列表
        * @param poolInfo.minSize: 数据切片最小值，固定写16
        * @param poolInfo.maxSize: 数据切片最大值，固定写128
        * @return string: 指纹库guid
           *
           * @throw 转抛内部调用异常

        Parameters:
         - poolInfo

        """
        self.send_CreateFingerprintPool(poolInfo)
        return self.recv_CreateFingerprintPool()

    def send_CreateFingerprintPool(self, poolInfo):
        self._oprot.writeMessageBegin('CreateFingerprintPool', TMessageType.CALL, self._seqid)
        args = CreateFingerprintPool_args()
        args.poolInfo = poolInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateFingerprintPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateFingerprintPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateFingerprintPool failed: unknown result")

    def EditFingerprintPool(self, guid, nodeIPs):
        """
        编辑指纹库
        @param guid: 指纹库guid
        @param nodeIPs: 扩展的节点IP列表


        Parameters:
         - guid
         - nodeIPs

        """
        self.send_EditFingerprintPool(guid, nodeIPs)
        self.recv_EditFingerprintPool()

    def send_EditFingerprintPool(self, guid, nodeIPs):
        self._oprot.writeMessageBegin('EditFingerprintPool', TMessageType.CALL, self._seqid)
        args = EditFingerprintPool_args()
        args.guid = guid
        args.nodeIPs = nodeIPs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_EditFingerprintPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = EditFingerprintPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def GetFingerprintPoolNodes(self, guid):
        """
        获取指纹库下所有节点
        @param guid: 指纹库guid
        @param nodeIPs: 扩展的节点IP列表
        @return list<string>: 指纹库所用节点IP列表


        Parameters:
         - guid

        """
        self.send_GetFingerprintPoolNodes(guid)
        return self.recv_GetFingerprintPoolNodes()

    def send_GetFingerprintPoolNodes(self, guid):
        self._oprot.writeMessageBegin('GetFingerprintPoolNodes', TMessageType.CALL, self._seqid)
        args = GetFingerprintPoolNodes_args()
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetFingerprintPoolNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetFingerprintPoolNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFingerprintPoolNodes failed: unknown result")

    def CheckFingerprintPoolStatus(self, guid):
        """
        检查指纹库是否被占用
        @param guid: 指纹库guid
        @return string: ""表示未占用，其他表示占用，内容为提示信息


        Parameters:
         - guid

        """
        self.send_CheckFingerprintPoolStatus(guid)
        return self.recv_CheckFingerprintPoolStatus()

    def send_CheckFingerprintPoolStatus(self, guid):
        self._oprot.writeMessageBegin('CheckFingerprintPoolStatus', TMessageType.CALL, self._seqid)
        args = CheckFingerprintPoolStatus_args()
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CheckFingerprintPoolStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CheckFingerprintPoolStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckFingerprintPoolStatus failed: unknown result")

    def CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
        """
        检查节点指纹库是否被占用
        @param guid: 指纹库guid
        @param nodeGuid: 节点指纹库标识
        @return 未被占用返回true,占用返回false


        Parameters:
         - guid
         - nodeguid

        """
        self.send_CheckFingerprintPoolNodeLibStatus(guid, nodeguid)
        return self.recv_CheckFingerprintPoolNodeLibStatus()

    def send_CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
        self._oprot.writeMessageBegin('CheckFingerprintPoolNodeLibStatus', TMessageType.CALL, self._seqid)
        args = CheckFingerprintPoolNodeLibStatus_args()
        args.guid = guid
        args.nodeguid = nodeguid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CheckFingerprintPoolNodeLibStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CheckFingerprintPoolNodeLibStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckFingerprintPoolNodeLibStatus failed: unknown result")

    def FaultDDcache(self):
        self.send_FaultDDcache()
        return self.recv_FaultDDcache()

    def send_FaultDDcache(self):
        self._oprot.writeMessageBegin('FaultDDcache', TMessageType.CALL, self._seqid)
        args = FaultDDcache_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_FaultDDcache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = FaultDDcache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "FaultDDcache failed: unknown result")

    def DeleteFingerprintPool(self, guid):
        """
        删除指纹池

        @param guid: 指纹池guid

        @throw 转抛内部调用异常

        Parameters:
         - guid

        """
        self.send_DeleteFingerprintPool(guid)
        self.recv_DeleteFingerprintPool()

    def send_DeleteFingerprintPool(self, guid):
        self._oprot.writeMessageBegin('DeleteFingerprintPool', TMessageType.CALL, self._seqid)
        args = DeleteFingerprintPool_args()
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteFingerprintPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteFingerprintPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def CleanFingerprintPool(self, guid):
        """
        清理指纹库

        @param guid: 指纹池guid

        @throw 转抛内部调用异常

        Parameters:
         - guid

        """
        self.send_CleanFingerprintPool(guid)
        self.recv_CleanFingerprintPool()

    def send_CleanFingerprintPool(self, guid):
        self._oprot.writeMessageBegin('CleanFingerprintPool', TMessageType.CALL, self._seqid)
        args = CleanFingerprintPool_args()
        args.guid = guid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CleanFingerprintPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CleanFingerprintPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def DeleteFingerprintPoolNodeLib(self):
        """
        通知删除节点指纹库

        @throw 转抛内部调用异常

        """
        self.send_DeleteFingerprintPoolNodeLib()
        self.recv_DeleteFingerprintPoolNodeLib()

    def send_DeleteFingerprintPoolNodeLib(self):
        self._oprot.writeMessageBegin('DeleteFingerprintPoolNodeLib', TMessageType.CALL, self._seqid)
        args = DeleteFingerprintPoolNodeLib_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteFingerprintPoolNodeLib(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteFingerprintPoolNodeLib_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def CleanFingerprintPoolNodeLib(self):
        """
        通知清理节点指纹库

        @throw 转抛内部调用异常

        """
        self.send_CleanFingerprintPoolNodeLib()
        self.recv_CleanFingerprintPoolNodeLib()

    def send_CleanFingerprintPoolNodeLib(self):
        self._oprot.writeMessageBegin('CleanFingerprintPoolNodeLib', TMessageType.CALL, self._seqid)
        args = CleanFingerprintPoolNodeLib_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CleanFingerprintPoolNodeLib(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CleanFingerprintPoolNodeLib_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def GetAllFingerprintPools(self):
        """
        获取全部指纹库信息
         
        @return 指纹库信息列表

        @throw 转抛内部调用异常

        """
        self.send_GetAllFingerprintPools()
        return self.recv_GetAllFingerprintPools()

    def send_GetAllFingerprintPools(self):
        self._oprot.writeMessageBegin('GetAllFingerprintPools', TMessageType.CALL, self._seqid)
        args = GetAllFingerprintPools_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAllFingerprintPools(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAllFingerprintPools_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAllFingerprintPools failed: unknown result")

    def CreateDDcache(self, ddcachename, ddcachepath, size):
        """
        创建DDcache卷
        @param ddcachename: ddcache卷名称
        @param ddcachepath: ddcache卷路径
        @param size:ddcache卷大小


        Parameters:
         - ddcachename
         - ddcachepath
         - size

        """
        self.send_CreateDDcache(ddcachename, ddcachepath, size)
        self.recv_CreateDDcache()

    def send_CreateDDcache(self, ddcachename, ddcachepath, size):
        self._oprot.writeMessageBegin('CreateDDcache', TMessageType.CALL, self._seqid)
        args = CreateDDcache_args()
        args.ddcachename = ddcachename
        args.ddcachepath = ddcachepath
        args.size = size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateDDcache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateDDcache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def DeleteDDcache(self, ddcachename):
        """
        删除DDcache卷
        @param ddcachename: ddcache卷名称


        Parameters:
         - ddcachename

        """
        self.send_DeleteDDcache(ddcachename)
        self.recv_DeleteDDcache()

    def send_DeleteDDcache(self, ddcachename):
        self._oprot.writeMessageBegin('DeleteDDcache', TMessageType.CALL, self._seqid)
        args = DeleteDDcache_args()
        args.ddcachename = ddcachename
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteDDcache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteDDcache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def ExpansionDDcache(self, ddcachename, size):
        """
        DDcache卷扩容
        @param ddcachename: ddcache卷名称
        @param size: ddcache扩容容量

        Parameters:
         - ddcachename
         - size

        """
        self.send_ExpansionDDcache(ddcachename, size)
        self.recv_ExpansionDDcache()

    def send_ExpansionDDcache(self, ddcachename, size):
        self._oprot.writeMessageBegin('ExpansionDDcache', TMessageType.CALL, self._seqid)
        args = ExpansionDDcache_args()
        args.ddcachename = ddcachename
        args.size = size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExpansionDDcache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExpansionDDcache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.exp is not None:
            raise result.exp
        return

    def GetLocalAllDDcache(self):
        """
        查询ddcache
        @return list<ncDedupeMgmType.ncDDCacheInfo> :ddcache卷信息集


        """
        self.send_GetLocalAllDDcache()
        return self.recv_GetLocalAllDDcache()

    def send_GetLocalAllDDcache(self):
        self._oprot.writeMessageBegin('GetLocalAllDDcache', TMessageType.CALL, self._seqid)
        args = GetLocalAllDDcache_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLocalAllDDcache(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLocalAllDDcache_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLocalAllDDcache failed: unknown result")

    def CheckDDcacheCanDelete(self, ddcachename):
        """
        检测ddcache是否可删除
        @param ddcachename: ddcache卷名称
        @return list<string>: 指纹库名称


        Parameters:
         - ddcachename

        """
        self.send_CheckDDcacheCanDelete(ddcachename)
        return self.recv_CheckDDcacheCanDelete()

    def send_CheckDDcacheCanDelete(self, ddcachename):
        self._oprot.writeMessageBegin('CheckDDcacheCanDelete', TMessageType.CALL, self._seqid)
        args = CheckDDcacheCanDelete_args()
        args.ddcachename = ddcachename
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CheckDDcacheCanDelete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CheckDDcacheCanDelete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.exp is not None:
            raise result.exp
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckDDcacheCanDelete failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["GetDedupeNodes"] = Processor.process_GetDedupeNodes
        self._processMap["CreateFingerprintPool"] = Processor.process_CreateFingerprintPool
        self._processMap["EditFingerprintPool"] = Processor.process_EditFingerprintPool
        self._processMap["GetFingerprintPoolNodes"] = Processor.process_GetFingerprintPoolNodes
        self._processMap["CheckFingerprintPoolStatus"] = Processor.process_CheckFingerprintPoolStatus
        self._processMap["CheckFingerprintPoolNodeLibStatus"] = Processor.process_CheckFingerprintPoolNodeLibStatus
        self._processMap["FaultDDcache"] = Processor.process_FaultDDcache
        self._processMap["DeleteFingerprintPool"] = Processor.process_DeleteFingerprintPool
        self._processMap["CleanFingerprintPool"] = Processor.process_CleanFingerprintPool
        self._processMap["DeleteFingerprintPoolNodeLib"] = Processor.process_DeleteFingerprintPoolNodeLib
        self._processMap["CleanFingerprintPoolNodeLib"] = Processor.process_CleanFingerprintPoolNodeLib
        self._processMap["GetAllFingerprintPools"] = Processor.process_GetAllFingerprintPools
        self._processMap["CreateDDcache"] = Processor.process_CreateDDcache
        self._processMap["DeleteDDcache"] = Processor.process_DeleteDDcache
        self._processMap["ExpansionDDcache"] = Processor.process_ExpansionDDcache
        self._processMap["GetLocalAllDDcache"] = Processor.process_GetLocalAllDDcache
        self._processMap["CheckDDcacheCanDelete"] = Processor.process_CheckDDcacheCanDelete
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_GetDedupeNodes(self, seqid, iprot, oprot):
        args = GetDedupeNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetDedupeNodes_result()
        try:
            result.success = self._handler.GetDedupeNodes()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetDedupeNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateFingerprintPool(self, seqid, iprot, oprot):
        args = CreateFingerprintPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateFingerprintPool_result()
        try:
            result.success = self._handler.CreateFingerprintPool(args.poolInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateFingerprintPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_EditFingerprintPool(self, seqid, iprot, oprot):
        args = EditFingerprintPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = EditFingerprintPool_result()
        try:
            self._handler.EditFingerprintPool(args.guid, args.nodeIPs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("EditFingerprintPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetFingerprintPoolNodes(self, seqid, iprot, oprot):
        args = GetFingerprintPoolNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetFingerprintPoolNodes_result()
        try:
            result.success = self._handler.GetFingerprintPoolNodes(args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetFingerprintPoolNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CheckFingerprintPoolStatus(self, seqid, iprot, oprot):
        args = CheckFingerprintPoolStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CheckFingerprintPoolStatus_result()
        try:
            result.success = self._handler.CheckFingerprintPoolStatus(args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CheckFingerprintPoolStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CheckFingerprintPoolNodeLibStatus(self, seqid, iprot, oprot):
        args = CheckFingerprintPoolNodeLibStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CheckFingerprintPoolNodeLibStatus_result()
        try:
            result.success = self._handler.CheckFingerprintPoolNodeLibStatus(args.guid, args.nodeguid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CheckFingerprintPoolNodeLibStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_FaultDDcache(self, seqid, iprot, oprot):
        args = FaultDDcache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = FaultDDcache_result()
        try:
            result.success = self._handler.FaultDDcache()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("FaultDDcache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteFingerprintPool(self, seqid, iprot, oprot):
        args = DeleteFingerprintPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteFingerprintPool_result()
        try:
            self._handler.DeleteFingerprintPool(args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteFingerprintPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CleanFingerprintPool(self, seqid, iprot, oprot):
        args = CleanFingerprintPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CleanFingerprintPool_result()
        try:
            self._handler.CleanFingerprintPool(args.guid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CleanFingerprintPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteFingerprintPoolNodeLib(self, seqid, iprot, oprot):
        args = DeleteFingerprintPoolNodeLib_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteFingerprintPoolNodeLib_result()
        try:
            self._handler.DeleteFingerprintPoolNodeLib()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteFingerprintPoolNodeLib", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CleanFingerprintPoolNodeLib(self, seqid, iprot, oprot):
        args = CleanFingerprintPoolNodeLib_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CleanFingerprintPoolNodeLib_result()
        try:
            self._handler.CleanFingerprintPoolNodeLib()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CleanFingerprintPoolNodeLib", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAllFingerprintPools(self, seqid, iprot, oprot):
        args = GetAllFingerprintPools_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAllFingerprintPools_result()
        try:
            result.success = self._handler.GetAllFingerprintPools()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAllFingerprintPools", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateDDcache(self, seqid, iprot, oprot):
        args = CreateDDcache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateDDcache_result()
        try:
            self._handler.CreateDDcache(args.ddcachename, args.ddcachepath, args.size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateDDcache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteDDcache(self, seqid, iprot, oprot):
        args = DeleteDDcache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteDDcache_result()
        try:
            self._handler.DeleteDDcache(args.ddcachename)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteDDcache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExpansionDDcache(self, seqid, iprot, oprot):
        args = ExpansionDDcache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExpansionDDcache_result()
        try:
            self._handler.ExpansionDDcache(args.ddcachename, args.size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExpansionDDcache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLocalAllDDcache(self, seqid, iprot, oprot):
        args = GetLocalAllDDcache_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLocalAllDDcache_result()
        try:
            result.success = self._handler.GetLocalAllDDcache()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLocalAllDDcache", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CheckDDcacheCanDelete(self, seqid, iprot, oprot):
        args = CheckDDcacheCanDelete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CheckDDcacheCanDelete_result()
        try:
            result.success = self._handler.CheckDDcacheCanDelete(args.ddcachename)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ncException.ttypes.ncException as exp:
            msg_type = TMessageType.REPLY
            result.exp = exp
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CheckDDcacheCanDelete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class GetDedupeNodes_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDedupeNodes_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDedupeNodes_args)
GetDedupeNodes_args.thrift_spec = (
)


class GetDedupeNodes_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDedupeNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter6 in self.success:
                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDedupeNodes_result)
GetDedupeNodes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CreateFingerprintPool_args(object):
    """
    Attributes:
     - poolInfo

    """


    def __init__(self, poolInfo=None,):
        self.poolInfo = poolInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.poolInfo = ncDedupeMgmType.ttypes.ncFPPoolInfo()
                    self.poolInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateFingerprintPool_args')
        if self.poolInfo is not None:
            oprot.writeFieldBegin('poolInfo', TType.STRUCT, 1)
            self.poolInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateFingerprintPool_args)
CreateFingerprintPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'poolInfo', [ncDedupeMgmType.ttypes.ncFPPoolInfo, None], None, ),  # 1
)


class CreateFingerprintPool_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateFingerprintPool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateFingerprintPool_result)
CreateFingerprintPool_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class EditFingerprintPool_args(object):
    """
    Attributes:
     - guid
     - nodeIPs

    """


    def __init__(self, guid=None, nodeIPs=None,):
        self.guid = guid
        self.nodeIPs = nodeIPs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.nodeIPs = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.nodeIPs.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EditFingerprintPool_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.nodeIPs is not None:
            oprot.writeFieldBegin('nodeIPs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.nodeIPs))
            for iter13 in self.nodeIPs:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EditFingerprintPool_args)
EditFingerprintPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'nodeIPs', (TType.STRING, 'UTF8', False), None, ),  # 2
)


class EditFingerprintPool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EditFingerprintPool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(EditFingerprintPool_result)
EditFingerprintPool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class GetFingerprintPoolNodes_args(object):
    """
    Attributes:
     - guid

    """


    def __init__(self, guid=None,):
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFingerprintPoolNodes_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFingerprintPoolNodes_args)
GetFingerprintPoolNodes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
)


class GetFingerprintPoolNodes_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFingerprintPoolNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter20 in self.success:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFingerprintPoolNodes_result)
GetFingerprintPoolNodes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CheckFingerprintPoolStatus_args(object):
    """
    Attributes:
     - guid

    """


    def __init__(self, guid=None,):
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckFingerprintPoolStatus_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckFingerprintPoolStatus_args)
CheckFingerprintPoolStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
)


class CheckFingerprintPoolStatus_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckFingerprintPoolStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckFingerprintPoolStatus_result)
CheckFingerprintPoolStatus_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CheckFingerprintPoolNodeLibStatus_args(object):
    """
    Attributes:
     - guid
     - nodeguid

    """


    def __init__(self, guid=None, nodeguid=None,):
        self.guid = guid
        self.nodeguid = nodeguid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.nodeguid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckFingerprintPoolNodeLibStatus_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        if self.nodeguid is not None:
            oprot.writeFieldBegin('nodeguid', TType.I64, 2)
            oprot.writeI64(self.nodeguid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckFingerprintPoolNodeLibStatus_args)
CheckFingerprintPoolNodeLibStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
    (2, TType.I64, 'nodeguid', None, None, ),  # 2
)


class CheckFingerprintPoolNodeLibStatus_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckFingerprintPoolNodeLibStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckFingerprintPoolNodeLibStatus_result)
CheckFingerprintPoolNodeLibStatus_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class FaultDDcache_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FaultDDcache_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(FaultDDcache_args)
FaultDDcache_args.thrift_spec = (
)


class FaultDDcache_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FaultDDcache_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(FaultDDcache_result)
FaultDDcache_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class DeleteFingerprintPool_args(object):
    """
    Attributes:
     - guid

    """


    def __init__(self, guid=None,):
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteFingerprintPool_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteFingerprintPool_args)
DeleteFingerprintPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
)


class DeleteFingerprintPool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteFingerprintPool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteFingerprintPool_result)
DeleteFingerprintPool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CleanFingerprintPool_args(object):
    """
    Attributes:
     - guid

    """


    def __init__(self, guid=None,):
        self.guid = guid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.guid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CleanFingerprintPool_args')
        if self.guid is not None:
            oprot.writeFieldBegin('guid', TType.STRING, 1)
            oprot.writeString(self.guid.encode('utf-8') if sys.version_info[0] == 2 else self.guid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CleanFingerprintPool_args)
CleanFingerprintPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'guid', 'UTF8', None, ),  # 1
)


class CleanFingerprintPool_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CleanFingerprintPool_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CleanFingerprintPool_result)
CleanFingerprintPool_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class DeleteFingerprintPoolNodeLib_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteFingerprintPoolNodeLib_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteFingerprintPoolNodeLib_args)
DeleteFingerprintPoolNodeLib_args.thrift_spec = (
)


class DeleteFingerprintPoolNodeLib_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteFingerprintPoolNodeLib_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteFingerprintPoolNodeLib_result)
DeleteFingerprintPoolNodeLib_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CleanFingerprintPoolNodeLib_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CleanFingerprintPoolNodeLib_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CleanFingerprintPoolNodeLib_args)
CleanFingerprintPoolNodeLib_args.thrift_spec = (
)


class CleanFingerprintPoolNodeLib_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CleanFingerprintPoolNodeLib_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CleanFingerprintPoolNodeLib_result)
CleanFingerprintPoolNodeLib_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class GetAllFingerprintPools_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAllFingerprintPools_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAllFingerprintPools_args)
GetAllFingerprintPools_args.thrift_spec = (
)


class GetAllFingerprintPools_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = ncDedupeMgmType.ttypes.ncFPPoolInfo()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAllFingerprintPools_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAllFingerprintPools_result)
GetAllFingerprintPools_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncDedupeMgmType.ttypes.ncFPPoolInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CreateDDcache_args(object):
    """
    Attributes:
     - ddcachename
     - ddcachepath
     - size

    """


    def __init__(self, ddcachename=None, ddcachepath=None, size=None,):
        self.ddcachename = ddcachename
        self.ddcachepath = ddcachepath
        self.size = size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ddcachename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ddcachepath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateDDcache_args')
        if self.ddcachename is not None:
            oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
            oprot.writeString(self.ddcachename.encode('utf-8') if sys.version_info[0] == 2 else self.ddcachename)
            oprot.writeFieldEnd()
        if self.ddcachepath is not None:
            oprot.writeFieldBegin('ddcachepath', TType.STRING, 2)
            oprot.writeString(self.ddcachepath.encode('utf-8') if sys.version_info[0] == 2 else self.ddcachepath)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I64, 3)
            oprot.writeI64(self.size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateDDcache_args)
CreateDDcache_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ddcachename', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'ddcachepath', 'UTF8', None, ),  # 2
    (3, TType.I64, 'size', None, None, ),  # 3
)


class CreateDDcache_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateDDcache_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateDDcache_result)
CreateDDcache_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class DeleteDDcache_args(object):
    """
    Attributes:
     - ddcachename

    """


    def __init__(self, ddcachename=None,):
        self.ddcachename = ddcachename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ddcachename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteDDcache_args')
        if self.ddcachename is not None:
            oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
            oprot.writeString(self.ddcachename.encode('utf-8') if sys.version_info[0] == 2 else self.ddcachename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteDDcache_args)
DeleteDDcache_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ddcachename', 'UTF8', None, ),  # 1
)


class DeleteDDcache_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteDDcache_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteDDcache_result)
DeleteDDcache_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class ExpansionDDcache_args(object):
    """
    Attributes:
     - ddcachename
     - size

    """


    def __init__(self, ddcachename=None, size=None,):
        self.ddcachename = ddcachename
        self.size = size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ddcachename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExpansionDDcache_args')
        if self.ddcachename is not None:
            oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
            oprot.writeString(self.ddcachename.encode('utf-8') if sys.version_info[0] == 2 else self.ddcachename)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I64, 2)
            oprot.writeI64(self.size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExpansionDDcache_args)
ExpansionDDcache_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ddcachename', 'UTF8', None, ),  # 1
    (2, TType.I64, 'size', None, None, ),  # 2
)


class ExpansionDDcache_result(object):
    """
    Attributes:
     - exp

    """


    def __init__(self, exp=None,):
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExpansionDDcache_result')
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExpansionDDcache_result)
ExpansionDDcache_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class GetLocalAllDDcache_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLocalAllDDcache_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLocalAllDDcache_args)
GetLocalAllDDcache_args.thrift_spec = (
)


class GetLocalAllDDcache_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = ncDedupeMgmType.ttypes.ncDDCacheInfo()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLocalAllDDcache_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLocalAllDDcache_result)
GetLocalAllDDcache_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ncDedupeMgmType.ttypes.ncDDCacheInfo, None], False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)


class CheckDDcacheCanDelete_args(object):
    """
    Attributes:
     - ddcachename

    """


    def __init__(self, ddcachename=None,):
        self.ddcachename = ddcachename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ddcachename = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckDDcacheCanDelete_args')
        if self.ddcachename is not None:
            oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
            oprot.writeString(self.ddcachename.encode('utf-8') if sys.version_info[0] == 2 else self.ddcachename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckDDcacheCanDelete_args)
CheckDDcacheCanDelete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ddcachename', 'UTF8', None, ),  # 1
)


class CheckDDcacheCanDelete_result(object):
    """
    Attributes:
     - success
     - exp

    """


    def __init__(self, success=None, exp=None,):
        self.success = success
        self.exp = exp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.exp = ncException.ttypes.ncException()
                    self.exp.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckDDcacheCanDelete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter41 in self.success:
                oprot.writeString(iter41.encode('utf-8') if sys.version_info[0] == 2 else iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.exp is not None:
            oprot.writeFieldBegin('exp', TType.STRUCT, 1)
            self.exp.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckDDcacheCanDelete_result)
CheckDDcacheCanDelete_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'exp', [ncException.ttypes.ncException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

