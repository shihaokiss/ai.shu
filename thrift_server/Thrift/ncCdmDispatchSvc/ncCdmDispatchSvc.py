#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def microprobe(self):
    """
    服务探针，测试服务可用性

    @ throw ncException
    """
    pass

  def get_all_jobs(self):
    pass

  def get_all_mount_jobs(self):
    pass

  def get_all_mounted_images(self):
    pass

  def get_backup_jobs_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    pass

  def get_mount_jobs_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    pass

  def get_residue_mount_jobs_by_pool(self, pool_id):
    """
    根据存储池Ip获取有残留的克隆卷的mount任务
    @param pool_id 存储池ID
    @return  有残留的克隆卷的mount任务 list<ncJob.ncTJob>

    Parameters:
     - pool_id
    """
    pass

  def get_images_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    pass

  def get_job(self, jobId):
    """
    Parameters:
     - jobId
    """
    pass

  def update_jobs_nstart_time(self, jobs_params):
    """
    Parameters:
     - jobs_params
    """
    pass

  def get_jobs_like_for_schedule(self, jobName, clientIds):
    """
    Parameters:
     - jobName
     - clientIds
    """
    pass

  def get_jobs_for_schedule_by_ids(self, jobIds):
    """
    根据id组获取job

    @return

    @throw ncException

    Parameters:
     - jobIds
    """
    pass

  def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
    """
    Parameters:
     - jobId
     - customer
     - backupType
     - desc
     - is_auto_execute
     - nstart_time
     - strategy_id
    """
    pass

  def get_support_backup_type(self, job_id):
    """
    Parameters:
     - job_id
    """
    pass

  def get_jobs_by_instance_name(self, instance_name):
    """
    Parameters:
     - instance_name
    """
    pass

  def client_exsit_job(self, clientId):
    """
    检测客户端是否关联任务

    @param clientId: 客户端ID

    Parameters:
     - clientId
    """
    pass

  def get_db_job_instances(self, request):
    """
    Parameters:
     - request
    """
    pass

  def get_db_job_mappings(self, request):
    """
    Parameters:
     - request
    """
    pass

  def ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
    """
    对存储卷执行一次快照

    @param poolUuid: 存储池Uuid
    @param volUuids: 虚拟卷Uuid集合
    @param copiesNum: 快照保留副本数
    @param timePoint: windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

    @return 执行结果，0：代表不需要删除日志时间点，大于零需删除最旧快照点之前的所有日志时间点

    Parameters:
     - lunUuids
     - copiesNum
     - timePoint
    """
    pass

  def ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
    """
    Parameters:
     - lunUuids
     - copiesNum
     - timePoint
    """
    pass

  def del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
    """
    Parameters:
     - lunUuids
     - copiesNum
    """
    pass

  def ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
    """
     @param lunUuids:虚拟卷ID集合
      @param backupType:备份方式 全备(1) 增备(2)
      @param jobCid:jobcid
      @param protocol:FC/ISCSI FC(1) ISCSI(0)
      @return 执行结果 mirrorRelationShip
    mirrorRelationShip = backup_volid + "#"+back_snapshotid+"#" + createTime + "#" +base_snapshotid+"#"+volid+"#"+"volname"+"*"
    createTime可以传回执行快照时间，保证同一个任务中所有数据源中的时间一致
    basevolid 需要备份的快照volid
    back_snapshotid需要备份的快照id
    base_snapshotid 增量备份需要的，上一个快照的id,如果是全量备份，传递空值
    volid 源LUN的void
    volname 源LUN的volname

    Parameters:
     - lunUuids
     - backupType
     - jobCid
     - protocol
    """
    pass

  def UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
    """
    更新snapshot mapping数据库
    @param clientInfo:客户短信息
    @param snapshotName:快照名字
    @param drivername:挂载后的盘符名字
    @return 执行结果

    Parameters:
     - clientMac
     - connector
     - snapshotName
     - drivername
    """
    pass

  def GetLunCopyStatus(self, volId, lunCopyId):
    """
    获取卷拷贝的执行进度
    @param volId:源卷ID
    @param lunCopyId:拷贝任务ID
    @return 执行进度

    Parameters:
     - volId
     - lunCopyId
    """
    pass

  def CreateTimepoint(self, lunUuids, timePoint):
    """
    将任务中的卷快照间隔的CDP时间戳存入服务器中

    @param lunUuids:虚拟镜像卷ID集合
    @param timePoint:windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

    @return null

    Parameters:
     - lunUuids
     - timePoint
    """
    pass

  def remove_all_jobs_by_client_ids(self, clientIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - clientIds
    """
    pass

  def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - vplatformIds
    """
    pass

  def stop_backup_jobs_by_pool(self, pool_id, pool_name):
    """
    停止存储池相关的备份任务


    Parameters:
     - pool_id
     - pool_name
    """
    pass

  def getTaskCdmLuns(self, jobid):
    """
    获取任务的信息

    @param jobid 任务id

    @return list <string> 任务关联的基本卷


    Parameters:
     - jobid
    """
    pass

  def createCdmLun(self, size, jobId):
    """
    创建CDM卷

    @param size,       申请的空间大小

    @return ncReplyVmDiskInfo,        返回CDM卷

    Parameters:
     - size
     - jobId
    """
    pass

  def updateCdmLunInfo(self, cdmLuns, jobId):
    """
    更新CDM卷容量信息

    @param cdmLuns,

    @return

    Parameters:
     - cdmLuns
     - jobId
    """
    pass

  def createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
    """
    记录虚拟机与CDM卷信息

    @param cdmLuns,

    @return

    Parameters:
     - vmVolumes
     - job_id
     - timepoint
    """
    pass

  def getVmCdmLunInfo(self, job_id, vmuuid):
    """
    查询虚拟机与CDM卷信息

    @param cdmLuns,

    @return

    Parameters:
     - job_id
     - vmuuid
    """
    pass

  def createVmwareTimePoint(self, vminfos, timepoint, job_id):
    """
    记录虚拟机备份成功信息

    @param ncRequestVmInfo,

    @return

    Parameters:
     - vminfos
     - timepoint
     - job_id
    """
    pass

  def get_all_backup_jobs_historys_for_ams(self):
    """
    获取任务执行记录，用来与AMS消息推送

    @return 任务执行记录
    """
    pass

  def get_all_backup_jobs_for_ams(self):
    """
    获取所有任务,用来推送给AMS

    @return 任务对象列表
    """
    pass

  def get_all_mount_job_for_ams(self):
    """
    获取数据访问任务,用来推送给AMS

    @return 任务对象列表
    """
    pass

  def get_all_mount_jobInstance_for_ams(self):
    """
    获取数据访问任务的执行记录,用来推送给AMS

    @return 任务对象列表
    """
    pass

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    pass

  def do_operation_from_ams(self, target, method, kwargs):
    """
    执行从AMS7.0下发的操作


    Parameters:
     - target
     - method
     - kwargs
    """
    pass

  def is_exists_running_job_on_client(self, clientId):
    """
    *  客户端上是否存在正则运行的任务
       @ return True:存在正在运行的任务, False： 不存在正在运行的任务
    *

    Parameters:
     - clientId
    """
    pass

  def is_exists_time_points_by_backup_job_id(self, backup_job_id):
    """
    *  根据备份任务id是否存在时间点
       @ return True:存在时间点, False： 不存在时间点
    *

    Parameters:
     - backup_job_id
    """
    pass

  def is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
    """
    *  根据备份任务id是否存在基本卷
       @ return True:存在基本卷, False： 不存在基本卷
    *

    Parameters:
     - backup_job_id
    """
    pass

  def get_origin_job_by_id(self, originJobId):
    """
    获取本地的同步任务信息，源端最原始的backupJobId,
     @ return ncCanSyncJobResponseData


    Parameters:
     - originJobId
    """
    pass

  def get_time_points_by_origin_job_id(self, TimePointReq):
    """
    获取最原始的backupJobId的时间点，默认按照时间戳降序
     @ return list<ncTimePointInfo>


    Parameters:
     - TimePointReq
    """
    pass

  def create_sync_job(self, createSyncJobReq):
    """
    根据createSyncJobReq创建在目的端创建任务同步任务


    Parameters:
     - createSyncJobReq
    """
    pass

  def get_can_sync_jobs(self, canSyncJobReq):
    """
    根据canSyncJobReq获取可以被远程复制的任务，包括拷贝的备份任务的数据和远程复制过来的任务
     @ return ncCdmDispatchProto.ncCanSyncJobResponse


    Parameters:
     - canSyncJobReq
    """
    pass

  def create_sync_time_point(self, createSyncTimePointReq):
    """
    根据时间点信息在目的端创建同步任务的时间点


    Parameters:
     - createSyncTimePointReq
    """
    pass

  def is_exists_origin_job_by_id(self, originJobId):
    """
    根据最原始的backupJobId，判断目的端是否已经同步过
     @ return bool


    Parameters:
     - originJobId
    """
    pass

  def create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
    """
    远程复制开始的时候根据时间点的信息在目的端创建未完成的时间点
    @ return ncCdmDispatchProto.ncCreateSyncTimePointResponse


    Parameters:
     - createSyncTimePointReq
    """
    pass

  def update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
    """
    远程复制结束的时候根据时间点的信息在目的端更新时间点信息为已完成的时间点


    Parameters:
     - updateSyncTimePointReq
    """
    pass

  def update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
    """
    远程复制中途的时候根据时间点快照卷的信息更新同步的时间点的快照卷的信息


    Parameters:
     - updateSyncTimePointVolumeReq
    """
    pass

  def delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
    """
    远程复制删除未完成的时间点
     @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


    Parameters:
     - deleteSyncTimePointIds
    """
    pass

  def update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
    """
    远程复制过程中更新任务的状态
     @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


    Parameters:
     - UpdateJobStatusReq
    """
    pass

  def check_time_point_is_exist(self, timePointId):
    """
    检测时间点是否存在，只检测状态是完成状态的时间点，其他状态视为不存在时间点
    @ return True:存在时间点, False： 不存在时间点


    Parameters:
     - timePointId
    """
    pass

  def get_dict_export(self, body, jobInstanceId, userId):
    """
    获取image的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def mount_get_dict_export(self, body, jobInstanceId, userId):
    """
    获取mount任务的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def backup_get_dict_export(self, body, jobInstanceId, userId):
    """
    获取备份任务的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    """
    生产资源类型 sourceType
    服务类型     svcType
    生产资源标识 sourceId
    @ return


    Parameters:
     - sourceType
     - svcType
     - sourceId
     - relation
    """
    pass

  def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    """
    数据源       datasource
    客户端ID     clientId
    数据源的用户名(适用于多用户场景)   dbRunUserName
    @ return


    Parameters:
     - datasource
     - clientId
     - dbRunUserName
    """
    pass

  def get_sync_job_origin_job_by_id(self, originJobId):
    """
    根据originJobId获取同步任务的信息
    @ return


    Parameters:
     - originJobId
    """
    pass

  def check_user_has_data(self, user_list):
    """
    检测用户是否存在存储数据
    @ return 返回有存储数据的用户列表


    Parameters:
     - user_list
    """
    pass

  def resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id):
    """
     清理CDM数据清理任务的时间点
    input:清理任务的id,清理类型,时间点,当前登陆用户
     @ return


    Parameters:
     - job_id
     - clean_type
     - time_points
     - user
     - clean_job_id
    """
    pass

  def get_job_count_info(self, startTime, userId):
    """
    获取CDM备份任务数
    @ return 备份任务的数量


    Parameters:
     - startTime
     - userId
    """
    pass

  def run_backup_job_handler(self, job_instance_id, user_id):
    """
    运行备份任务转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    pass

  def run_mount_job_handler(self, job_instance_id, user_id):
    """
    运行挂载任务转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    pass

  def image_mount_handler(self, job_instance_id, user_id):
    """
    image mount操作转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    pass

  def image_unmount_handler(self, job_instance_id, user_id):
    """
    image unmount操作转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def microprobe(self):
    """
    服务探针，测试服务可用性

    @ throw ncException
    """
    self.send_microprobe()
    self.recv_microprobe()

  def send_microprobe(self):
    self._oprot.writeMessageBegin('microprobe', TMessageType.CALL, self._seqid)
    args = microprobe_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_microprobe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = microprobe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_all_jobs(self):
    self.send_get_all_jobs()
    return self.recv_get_all_jobs()

  def send_get_all_jobs(self):
    self._oprot.writeMessageBegin('get_all_jobs', TMessageType.CALL, self._seqid)
    args = get_all_jobs_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_jobs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_jobs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs failed: unknown result")

  def get_all_mount_jobs(self):
    self.send_get_all_mount_jobs()
    return self.recv_get_all_mount_jobs()

  def send_get_all_mount_jobs(self):
    self._oprot.writeMessageBegin('get_all_mount_jobs', TMessageType.CALL, self._seqid)
    args = get_all_mount_jobs_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_mount_jobs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_mount_jobs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_jobs failed: unknown result")

  def get_all_mounted_images(self):
    self.send_get_all_mounted_images()
    return self.recv_get_all_mounted_images()

  def send_get_all_mounted_images(self):
    self._oprot.writeMessageBegin('get_all_mounted_images', TMessageType.CALL, self._seqid)
    args = get_all_mounted_images_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_mounted_images(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_mounted_images_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mounted_images failed: unknown result")

  def get_backup_jobs_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    self.send_get_backup_jobs_by_pool(pool_id)
    return self.recv_get_backup_jobs_by_pool()

  def send_get_backup_jobs_by_pool(self, pool_id):
    self._oprot.writeMessageBegin('get_backup_jobs_by_pool', TMessageType.CALL, self._seqid)
    args = get_backup_jobs_by_pool_args()
    args.pool_id = pool_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_backup_jobs_by_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_backup_jobs_by_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_backup_jobs_by_pool failed: unknown result")

  def get_mount_jobs_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    self.send_get_mount_jobs_by_pool(pool_id)
    return self.recv_get_mount_jobs_by_pool()

  def send_get_mount_jobs_by_pool(self, pool_id):
    self._oprot.writeMessageBegin('get_mount_jobs_by_pool', TMessageType.CALL, self._seqid)
    args = get_mount_jobs_by_pool_args()
    args.pool_id = pool_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_mount_jobs_by_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_mount_jobs_by_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_mount_jobs_by_pool failed: unknown result")

  def get_residue_mount_jobs_by_pool(self, pool_id):
    """
    根据存储池Ip获取有残留的克隆卷的mount任务
    @param pool_id 存储池ID
    @return  有残留的克隆卷的mount任务 list<ncJob.ncTJob>

    Parameters:
     - pool_id
    """
    self.send_get_residue_mount_jobs_by_pool(pool_id)
    return self.recv_get_residue_mount_jobs_by_pool()

  def send_get_residue_mount_jobs_by_pool(self, pool_id):
    self._oprot.writeMessageBegin('get_residue_mount_jobs_by_pool', TMessageType.CALL, self._seqid)
    args = get_residue_mount_jobs_by_pool_args()
    args.pool_id = pool_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_residue_mount_jobs_by_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_residue_mount_jobs_by_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_residue_mount_jobs_by_pool failed: unknown result")

  def get_images_by_pool(self, pool_id):
    """
    Parameters:
     - pool_id
    """
    self.send_get_images_by_pool(pool_id)
    return self.recv_get_images_by_pool()

  def send_get_images_by_pool(self, pool_id):
    self._oprot.writeMessageBegin('get_images_by_pool', TMessageType.CALL, self._seqid)
    args = get_images_by_pool_args()
    args.pool_id = pool_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_images_by_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_images_by_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_images_by_pool failed: unknown result")

  def get_job(self, jobId):
    """
    Parameters:
     - jobId
    """
    self.send_get_job(jobId)
    return self.recv_get_job()

  def send_get_job(self, jobId):
    self._oprot.writeMessageBegin('get_job', TMessageType.CALL, self._seqid)
    args = get_job_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_job(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_job_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job failed: unknown result")

  def update_jobs_nstart_time(self, jobs_params):
    """
    Parameters:
     - jobs_params
    """
    self.send_update_jobs_nstart_time(jobs_params)
    self.recv_update_jobs_nstart_time()

  def send_update_jobs_nstart_time(self, jobs_params):
    self._oprot.writeMessageBegin('update_jobs_nstart_time', TMessageType.CALL, self._seqid)
    args = update_jobs_nstart_time_args()
    args.jobs_params = jobs_params
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_jobs_nstart_time(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_jobs_nstart_time_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_jobs_like_for_schedule(self, jobName, clientIds):
    """
    Parameters:
     - jobName
     - clientIds
    """
    self.send_get_jobs_like_for_schedule(jobName, clientIds)
    return self.recv_get_jobs_like_for_schedule()

  def send_get_jobs_like_for_schedule(self, jobName, clientIds):
    self._oprot.writeMessageBegin('get_jobs_like_for_schedule', TMessageType.CALL, self._seqid)
    args = get_jobs_like_for_schedule_args()
    args.jobName = jobName
    args.clientIds = clientIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_like_for_schedule(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_like_for_schedule_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_like_for_schedule failed: unknown result")

  def get_jobs_for_schedule_by_ids(self, jobIds):
    """
    根据id组获取job

    @return

    @throw ncException

    Parameters:
     - jobIds
    """
    self.send_get_jobs_for_schedule_by_ids(jobIds)
    return self.recv_get_jobs_for_schedule_by_ids()

  def send_get_jobs_for_schedule_by_ids(self, jobIds):
    self._oprot.writeMessageBegin('get_jobs_for_schedule_by_ids', TMessageType.CALL, self._seqid)
    args = get_jobs_for_schedule_by_ids_args()
    args.jobIds = jobIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_for_schedule_by_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_for_schedule_by_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_for_schedule_by_ids failed: unknown result")

  def commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
    """
    Parameters:
     - jobId
     - customer
     - backupType
     - desc
     - is_auto_execute
     - nstart_time
     - strategy_id
    """
    self.send_commit_job(jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id)
    self.recv_commit_job()

  def send_commit_job(self, jobId, customer, backupType, desc, is_auto_execute, nstart_time, strategy_id):
    self._oprot.writeMessageBegin('commit_job', TMessageType.CALL, self._seqid)
    args = commit_job_args()
    args.jobId = jobId
    args.customer = customer
    args.backupType = backupType
    args.desc = desc
    args.is_auto_execute = is_auto_execute
    args.nstart_time = nstart_time
    args.strategy_id = strategy_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit_job(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_job_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_support_backup_type(self, job_id):
    """
    Parameters:
     - job_id
    """
    self.send_get_support_backup_type(job_id)
    return self.recv_get_support_backup_type()

  def send_get_support_backup_type(self, job_id):
    self._oprot.writeMessageBegin('get_support_backup_type', TMessageType.CALL, self._seqid)
    args = get_support_backup_type_args()
    args.job_id = job_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_support_backup_type(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_support_backup_type_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_support_backup_type failed: unknown result")

  def get_jobs_by_instance_name(self, instance_name):
    """
    Parameters:
     - instance_name
    """
    self.send_get_jobs_by_instance_name(instance_name)
    return self.recv_get_jobs_by_instance_name()

  def send_get_jobs_by_instance_name(self, instance_name):
    self._oprot.writeMessageBegin('get_jobs_by_instance_name', TMessageType.CALL, self._seqid)
    args = get_jobs_by_instance_name_args()
    args.instance_name = instance_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_by_instance_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_by_instance_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_instance_name failed: unknown result")

  def client_exsit_job(self, clientId):
    """
    检测客户端是否关联任务

    @param clientId: 客户端ID

    Parameters:
     - clientId
    """
    self.send_client_exsit_job(clientId)
    return self.recv_client_exsit_job()

  def send_client_exsit_job(self, clientId):
    self._oprot.writeMessageBegin('client_exsit_job', TMessageType.CALL, self._seqid)
    args = client_exsit_job_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_client_exsit_job(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = client_exsit_job_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "client_exsit_job failed: unknown result")

  def get_db_job_instances(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_db_job_instances(request)
    return self.recv_get_db_job_instances()

  def send_get_db_job_instances(self, request):
    self._oprot.writeMessageBegin('get_db_job_instances', TMessageType.CALL, self._seqid)
    args = get_db_job_instances_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_db_job_instances(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_db_job_instances_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_instances failed: unknown result")

  def get_db_job_mappings(self, request):
    """
    Parameters:
     - request
    """
    self.send_get_db_job_mappings(request)
    return self.recv_get_db_job_mappings()

  def send_get_db_job_mappings(self, request):
    self._oprot.writeMessageBegin('get_db_job_mappings', TMessageType.CALL, self._seqid)
    args = get_db_job_mappings_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_db_job_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_db_job_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_db_job_mappings failed: unknown result")

  def ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
    """
    对存储卷执行一次快照

    @param poolUuid: 存储池Uuid
    @param volUuids: 虚拟卷Uuid集合
    @param copiesNum: 快照保留副本数
    @param timePoint: windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

    @return 执行结果，0：代表不需要删除日志时间点，大于零需删除最旧快照点之前的所有日志时间点

    Parameters:
     - lunUuids
     - copiesNum
     - timePoint
    """
    self.send_ExcuteSnapshot(lunUuids, copiesNum, timePoint)
    self.recv_ExcuteSnapshot()

  def send_ExcuteSnapshot(self, lunUuids, copiesNum, timePoint):
    self._oprot.writeMessageBegin('ExcuteSnapshot', TMessageType.CALL, self._seqid)
    args = ExcuteSnapshot_args()
    args.lunUuids = lunUuids
    args.copiesNum = copiesNum
    args.timePoint = timePoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ExcuteSnapshot(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ExcuteSnapshot_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
    """
    Parameters:
     - lunUuids
     - copiesNum
     - timePoint
    """
    self.send_ExcuteSnapshotHw(lunUuids, copiesNum, timePoint)
    self.recv_ExcuteSnapshotHw()

  def send_ExcuteSnapshotHw(self, lunUuids, copiesNum, timePoint):
    self._oprot.writeMessageBegin('ExcuteSnapshotHw', TMessageType.CALL, self._seqid)
    args = ExcuteSnapshotHw_args()
    args.lunUuids = lunUuids
    args.copiesNum = copiesNum
    args.timePoint = timePoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ExcuteSnapshotHw(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ExcuteSnapshotHw_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
    """
    Parameters:
     - lunUuids
     - copiesNum
    """
    self.send_del_exceeded_snapshot_copies(lunUuids, copiesNum)
    return self.recv_del_exceeded_snapshot_copies()

  def send_del_exceeded_snapshot_copies(self, lunUuids, copiesNum):
    self._oprot.writeMessageBegin('del_exceeded_snapshot_copies', TMessageType.CALL, self._seqid)
    args = del_exceeded_snapshot_copies_args()
    args.lunUuids = lunUuids
    args.copiesNum = copiesNum
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_del_exceeded_snapshot_copies(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = del_exceeded_snapshot_copies_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "del_exceeded_snapshot_copies failed: unknown result")

  def ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
    """
     @param lunUuids:虚拟卷ID集合
      @param backupType:备份方式 全备(1) 增备(2)
      @param jobCid:jobcid
      @param protocol:FC/ISCSI FC(1) ISCSI(0)
      @return 执行结果 mirrorRelationShip
    mirrorRelationShip = backup_volid + "#"+back_snapshotid+"#" + createTime + "#" +base_snapshotid+"#"+volid+"#"+"volname"+"*"
    createTime可以传回执行快照时间，保证同一个任务中所有数据源中的时间一致
    basevolid 需要备份的快照volid
    back_snapshotid需要备份的快照id
    base_snapshotid 增量备份需要的，上一个快照的id,如果是全量备份，传递空值
    volid 源LUN的void
    volname 源LUN的volname

    Parameters:
     - lunUuids
     - backupType
     - jobCid
     - protocol
    """
    self.send_ExcuteSnapshot_mount(lunUuids, backupType, jobCid, protocol)
    return self.recv_ExcuteSnapshot_mount()

  def send_ExcuteSnapshot_mount(self, lunUuids, backupType, jobCid, protocol):
    self._oprot.writeMessageBegin('ExcuteSnapshot_mount', TMessageType.CALL, self._seqid)
    args = ExcuteSnapshot_mount_args()
    args.lunUuids = lunUuids
    args.backupType = backupType
    args.jobCid = jobCid
    args.protocol = protocol
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ExcuteSnapshot_mount(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ExcuteSnapshot_mount_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ExcuteSnapshot_mount failed: unknown result")

  def UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
    """
    更新snapshot mapping数据库
    @param clientInfo:客户短信息
    @param snapshotName:快照名字
    @param drivername:挂载后的盘符名字
    @return 执行结果

    Parameters:
     - clientMac
     - connector
     - snapshotName
     - drivername
    """
    self.send_UpdateMountPoint(clientMac, connector, snapshotName, drivername)
    self.recv_UpdateMountPoint()

  def send_UpdateMountPoint(self, clientMac, connector, snapshotName, drivername):
    self._oprot.writeMessageBegin('UpdateMountPoint', TMessageType.CALL, self._seqid)
    args = UpdateMountPoint_args()
    args.clientMac = clientMac
    args.connector = connector
    args.snapshotName = snapshotName
    args.drivername = drivername
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_UpdateMountPoint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = UpdateMountPoint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def GetLunCopyStatus(self, volId, lunCopyId):
    """
    获取卷拷贝的执行进度
    @param volId:源卷ID
    @param lunCopyId:拷贝任务ID
    @return 执行进度

    Parameters:
     - volId
     - lunCopyId
    """
    self.send_GetLunCopyStatus(volId, lunCopyId)
    return self.recv_GetLunCopyStatus()

  def send_GetLunCopyStatus(self, volId, lunCopyId):
    self._oprot.writeMessageBegin('GetLunCopyStatus', TMessageType.CALL, self._seqid)
    args = GetLunCopyStatus_args()
    args.volId = volId
    args.lunCopyId = lunCopyId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLunCopyStatus(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetLunCopyStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLunCopyStatus failed: unknown result")

  def CreateTimepoint(self, lunUuids, timePoint):
    """
    将任务中的卷快照间隔的CDP时间戳存入服务器中

    @param lunUuids:虚拟镜像卷ID集合
    @param timePoint:windowsTimestamp is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601.

    @return null

    Parameters:
     - lunUuids
     - timePoint
    """
    self.send_CreateTimepoint(lunUuids, timePoint)
    self.recv_CreateTimepoint()

  def send_CreateTimepoint(self, lunUuids, timePoint):
    self._oprot.writeMessageBegin('CreateTimepoint', TMessageType.CALL, self._seqid)
    args = CreateTimepoint_args()
    args.lunUuids = lunUuids
    args.timePoint = timePoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateTimepoint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CreateTimepoint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def remove_all_jobs_by_client_ids(self, clientIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - clientIds
    """
    self.send_remove_all_jobs_by_client_ids(clientIds)
    return self.recv_remove_all_jobs_by_client_ids()

  def send_remove_all_jobs_by_client_ids(self, clientIds):
    self._oprot.writeMessageBegin('remove_all_jobs_by_client_ids', TMessageType.CALL, self._seqid)
    args = remove_all_jobs_by_client_ids_args()
    args.clientIds = clientIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove_all_jobs_by_client_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = remove_all_jobs_by_client_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_client_ids failed: unknown result")

  def remove_all_jobs_by_vplatform_ids(self, vplatformIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - vplatformIds
    """
    self.send_remove_all_jobs_by_vplatform_ids(vplatformIds)
    return self.recv_remove_all_jobs_by_vplatform_ids()

  def send_remove_all_jobs_by_vplatform_ids(self, vplatformIds):
    self._oprot.writeMessageBegin('remove_all_jobs_by_vplatform_ids', TMessageType.CALL, self._seqid)
    args = remove_all_jobs_by_vplatform_ids_args()
    args.vplatformIds = vplatformIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove_all_jobs_by_vplatform_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = remove_all_jobs_by_vplatform_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_vplatform_ids failed: unknown result")

  def stop_backup_jobs_by_pool(self, pool_id, pool_name):
    """
    停止存储池相关的备份任务


    Parameters:
     - pool_id
     - pool_name
    """
    self.send_stop_backup_jobs_by_pool(pool_id, pool_name)
    self.recv_stop_backup_jobs_by_pool()

  def send_stop_backup_jobs_by_pool(self, pool_id, pool_name):
    self._oprot.writeMessageBegin('stop_backup_jobs_by_pool', TMessageType.CALL, self._seqid)
    args = stop_backup_jobs_by_pool_args()
    args.pool_id = pool_id
    args.pool_name = pool_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stop_backup_jobs_by_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stop_backup_jobs_by_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def getTaskCdmLuns(self, jobid):
    """
    获取任务的信息

    @param jobid 任务id

    @return list <string> 任务关联的基本卷


    Parameters:
     - jobid
    """
    self.send_getTaskCdmLuns(jobid)
    return self.recv_getTaskCdmLuns()

  def send_getTaskCdmLuns(self, jobid):
    self._oprot.writeMessageBegin('getTaskCdmLuns', TMessageType.CALL, self._seqid)
    args = getTaskCdmLuns_args()
    args.jobid = jobid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTaskCdmLuns(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getTaskCdmLuns_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTaskCdmLuns failed: unknown result")

  def createCdmLun(self, size, jobId):
    """
    创建CDM卷

    @param size,       申请的空间大小

    @return ncReplyVmDiskInfo,        返回CDM卷

    Parameters:
     - size
     - jobId
    """
    self.send_createCdmLun(size, jobId)
    return self.recv_createCdmLun()

  def send_createCdmLun(self, size, jobId):
    self._oprot.writeMessageBegin('createCdmLun', TMessageType.CALL, self._seqid)
    args = createCdmLun_args()
    args.size = size
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createCdmLun(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createCdmLun_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createCdmLun failed: unknown result")

  def updateCdmLunInfo(self, cdmLuns, jobId):
    """
    更新CDM卷容量信息

    @param cdmLuns,

    @return

    Parameters:
     - cdmLuns
     - jobId
    """
    self.send_updateCdmLunInfo(cdmLuns, jobId)
    self.recv_updateCdmLunInfo()

  def send_updateCdmLunInfo(self, cdmLuns, jobId):
    self._oprot.writeMessageBegin('updateCdmLunInfo', TMessageType.CALL, self._seqid)
    args = updateCdmLunInfo_args()
    args.cdmLuns = cdmLuns
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateCdmLunInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateCdmLunInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
    """
    记录虚拟机与CDM卷信息

    @param cdmLuns,

    @return

    Parameters:
     - vmVolumes
     - job_id
     - timepoint
    """
    self.send_createVmCdmLunInfo(vmVolumes, job_id, timepoint)
    self.recv_createVmCdmLunInfo()

  def send_createVmCdmLunInfo(self, vmVolumes, job_id, timepoint):
    self._oprot.writeMessageBegin('createVmCdmLunInfo', TMessageType.CALL, self._seqid)
    args = createVmCdmLunInfo_args()
    args.vmVolumes = vmVolumes
    args.job_id = job_id
    args.timepoint = timepoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createVmCdmLunInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createVmCdmLunInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def getVmCdmLunInfo(self, job_id, vmuuid):
    """
    查询虚拟机与CDM卷信息

    @param cdmLuns,

    @return

    Parameters:
     - job_id
     - vmuuid
    """
    self.send_getVmCdmLunInfo(job_id, vmuuid)
    return self.recv_getVmCdmLunInfo()

  def send_getVmCdmLunInfo(self, job_id, vmuuid):
    self._oprot.writeMessageBegin('getVmCdmLunInfo', TMessageType.CALL, self._seqid)
    args = getVmCdmLunInfo_args()
    args.job_id = job_id
    args.vmuuid = vmuuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getVmCdmLunInfo(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getVmCdmLunInfo_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getVmCdmLunInfo failed: unknown result")

  def createVmwareTimePoint(self, vminfos, timepoint, job_id):
    """
    记录虚拟机备份成功信息

    @param ncRequestVmInfo,

    @return

    Parameters:
     - vminfos
     - timepoint
     - job_id
    """
    self.send_createVmwareTimePoint(vminfos, timepoint, job_id)
    self.recv_createVmwareTimePoint()

  def send_createVmwareTimePoint(self, vminfos, timepoint, job_id):
    self._oprot.writeMessageBegin('createVmwareTimePoint', TMessageType.CALL, self._seqid)
    args = createVmwareTimePoint_args()
    args.vminfos = vminfos
    args.timepoint = timepoint
    args.job_id = job_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createVmwareTimePoint(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createVmwareTimePoint_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_all_backup_jobs_historys_for_ams(self):
    """
    获取任务执行记录，用来与AMS消息推送

    @return 任务执行记录
    """
    self.send_get_all_backup_jobs_historys_for_ams()
    return self.recv_get_all_backup_jobs_historys_for_ams()

  def send_get_all_backup_jobs_historys_for_ams(self):
    self._oprot.writeMessageBegin('get_all_backup_jobs_historys_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_backup_jobs_historys_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_backup_jobs_historys_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_backup_jobs_historys_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_backup_jobs_historys_for_ams failed: unknown result")

  def get_all_backup_jobs_for_ams(self):
    """
    获取所有任务,用来推送给AMS

    @return 任务对象列表
    """
    self.send_get_all_backup_jobs_for_ams()
    return self.recv_get_all_backup_jobs_for_ams()

  def send_get_all_backup_jobs_for_ams(self):
    self._oprot.writeMessageBegin('get_all_backup_jobs_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_backup_jobs_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_backup_jobs_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_backup_jobs_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_backup_jobs_for_ams failed: unknown result")

  def get_all_mount_job_for_ams(self):
    """
    获取数据访问任务,用来推送给AMS

    @return 任务对象列表
    """
    self.send_get_all_mount_job_for_ams()
    return self.recv_get_all_mount_job_for_ams()

  def send_get_all_mount_job_for_ams(self):
    self._oprot.writeMessageBegin('get_all_mount_job_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_mount_job_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_mount_job_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_mount_job_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_job_for_ams failed: unknown result")

  def get_all_mount_jobInstance_for_ams(self):
    """
    获取数据访问任务的执行记录,用来推送给AMS

    @return 任务对象列表
    """
    self.send_get_all_mount_jobInstance_for_ams()
    return self.recv_get_all_mount_jobInstance_for_ams()

  def send_get_all_mount_jobInstance_for_ams(self):
    self._oprot.writeMessageBegin('get_all_mount_jobInstance_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_mount_jobInstance_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_mount_jobInstance_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_mount_jobInstance_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_mount_jobInstance_for_ams failed: unknown result")

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    self.send_get_data_for_ams(kwargs)
    return self.recv_get_data_for_ams()

  def send_get_data_for_ams(self, kwargs):
    self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
    args = get_data_for_ams_args()
    args.kwargs = kwargs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_data_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_data_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

  def do_operation_from_ams(self, target, method, kwargs):
    """
    执行从AMS7.0下发的操作


    Parameters:
     - target
     - method
     - kwargs
    """
    self.send_do_operation_from_ams(target, method, kwargs)
    return self.recv_do_operation_from_ams()

  def send_do_operation_from_ams(self, target, method, kwargs):
    self._oprot.writeMessageBegin('do_operation_from_ams', TMessageType.CALL, self._seqid)
    args = do_operation_from_ams_args()
    args.target = target
    args.method = method
    args.kwargs = kwargs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_do_operation_from_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = do_operation_from_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "do_operation_from_ams failed: unknown result")

  def is_exists_running_job_on_client(self, clientId):
    """
    *  客户端上是否存在正则运行的任务
       @ return True:存在正在运行的任务, False： 不存在正在运行的任务
    *

    Parameters:
     - clientId
    """
    self.send_is_exists_running_job_on_client(clientId)
    return self.recv_is_exists_running_job_on_client()

  def send_is_exists_running_job_on_client(self, clientId):
    self._oprot.writeMessageBegin('is_exists_running_job_on_client', TMessageType.CALL, self._seqid)
    args = is_exists_running_job_on_client_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_exists_running_job_on_client(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = is_exists_running_job_on_client_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_running_job_on_client failed: unknown result")

  def is_exists_time_points_by_backup_job_id(self, backup_job_id):
    """
    *  根据备份任务id是否存在时间点
       @ return True:存在时间点, False： 不存在时间点
    *

    Parameters:
     - backup_job_id
    """
    self.send_is_exists_time_points_by_backup_job_id(backup_job_id)
    return self.recv_is_exists_time_points_by_backup_job_id()

  def send_is_exists_time_points_by_backup_job_id(self, backup_job_id):
    self._oprot.writeMessageBegin('is_exists_time_points_by_backup_job_id', TMessageType.CALL, self._seqid)
    args = is_exists_time_points_by_backup_job_id_args()
    args.backup_job_id = backup_job_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_exists_time_points_by_backup_job_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = is_exists_time_points_by_backup_job_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_time_points_by_backup_job_id failed: unknown result")

  def is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
    """
    *  根据备份任务id是否存在基本卷
       @ return True:存在基本卷, False： 不存在基本卷
    *

    Parameters:
     - backup_job_id
    """
    self.send_is_exists_base_volumes_by_backup_job_id(backup_job_id)
    return self.recv_is_exists_base_volumes_by_backup_job_id()

  def send_is_exists_base_volumes_by_backup_job_id(self, backup_job_id):
    self._oprot.writeMessageBegin('is_exists_base_volumes_by_backup_job_id', TMessageType.CALL, self._seqid)
    args = is_exists_base_volumes_by_backup_job_id_args()
    args.backup_job_id = backup_job_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_exists_base_volumes_by_backup_job_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = is_exists_base_volumes_by_backup_job_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_base_volumes_by_backup_job_id failed: unknown result")

  def get_origin_job_by_id(self, originJobId):
    """
    获取本地的同步任务信息，源端最原始的backupJobId,
     @ return ncCanSyncJobResponseData


    Parameters:
     - originJobId
    """
    self.send_get_origin_job_by_id(originJobId)
    return self.recv_get_origin_job_by_id()

  def send_get_origin_job_by_id(self, originJobId):
    self._oprot.writeMessageBegin('get_origin_job_by_id', TMessageType.CALL, self._seqid)
    args = get_origin_job_by_id_args()
    args.originJobId = originJobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_origin_job_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_origin_job_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_origin_job_by_id failed: unknown result")

  def get_time_points_by_origin_job_id(self, TimePointReq):
    """
    获取最原始的backupJobId的时间点，默认按照时间戳降序
     @ return list<ncTimePointInfo>


    Parameters:
     - TimePointReq
    """
    self.send_get_time_points_by_origin_job_id(TimePointReq)
    return self.recv_get_time_points_by_origin_job_id()

  def send_get_time_points_by_origin_job_id(self, TimePointReq):
    self._oprot.writeMessageBegin('get_time_points_by_origin_job_id', TMessageType.CALL, self._seqid)
    args = get_time_points_by_origin_job_id_args()
    args.TimePointReq = TimePointReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_time_points_by_origin_job_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_time_points_by_origin_job_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_time_points_by_origin_job_id failed: unknown result")

  def create_sync_job(self, createSyncJobReq):
    """
    根据createSyncJobReq创建在目的端创建任务同步任务


    Parameters:
     - createSyncJobReq
    """
    self.send_create_sync_job(createSyncJobReq)
    self.recv_create_sync_job()

  def send_create_sync_job(self, createSyncJobReq):
    self._oprot.writeMessageBegin('create_sync_job', TMessageType.CALL, self._seqid)
    args = create_sync_job_args()
    args.createSyncJobReq = createSyncJobReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_sync_job(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_sync_job_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_can_sync_jobs(self, canSyncJobReq):
    """
    根据canSyncJobReq获取可以被远程复制的任务，包括拷贝的备份任务的数据和远程复制过来的任务
     @ return ncCdmDispatchProto.ncCanSyncJobResponse


    Parameters:
     - canSyncJobReq
    """
    self.send_get_can_sync_jobs(canSyncJobReq)
    return self.recv_get_can_sync_jobs()

  def send_get_can_sync_jobs(self, canSyncJobReq):
    self._oprot.writeMessageBegin('get_can_sync_jobs', TMessageType.CALL, self._seqid)
    args = get_can_sync_jobs_args()
    args.canSyncJobReq = canSyncJobReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_can_sync_jobs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_can_sync_jobs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_can_sync_jobs failed: unknown result")

  def create_sync_time_point(self, createSyncTimePointReq):
    """
    根据时间点信息在目的端创建同步任务的时间点


    Parameters:
     - createSyncTimePointReq
    """
    self.send_create_sync_time_point(createSyncTimePointReq)
    self.recv_create_sync_time_point()

  def send_create_sync_time_point(self, createSyncTimePointReq):
    self._oprot.writeMessageBegin('create_sync_time_point', TMessageType.CALL, self._seqid)
    args = create_sync_time_point_args()
    args.createSyncTimePointReq = createSyncTimePointReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_sync_time_point(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_sync_time_point_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def is_exists_origin_job_by_id(self, originJobId):
    """
    根据最原始的backupJobId，判断目的端是否已经同步过
     @ return bool


    Parameters:
     - originJobId
    """
    self.send_is_exists_origin_job_by_id(originJobId)
    return self.recv_is_exists_origin_job_by_id()

  def send_is_exists_origin_job_by_id(self, originJobId):
    self._oprot.writeMessageBegin('is_exists_origin_job_by_id', TMessageType.CALL, self._seqid)
    args = is_exists_origin_job_by_id_args()
    args.originJobId = originJobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_exists_origin_job_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = is_exists_origin_job_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_origin_job_by_id failed: unknown result")

  def create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
    """
    远程复制开始的时候根据时间点的信息在目的端创建未完成的时间点
    @ return ncCdmDispatchProto.ncCreateSyncTimePointResponse


    Parameters:
     - createSyncTimePointReq
    """
    self.send_create_sync_time_point_on_sync_start(createSyncTimePointReq)
    return self.recv_create_sync_time_point_on_sync_start()

  def send_create_sync_time_point_on_sync_start(self, createSyncTimePointReq):
    self._oprot.writeMessageBegin('create_sync_time_point_on_sync_start', TMessageType.CALL, self._seqid)
    args = create_sync_time_point_on_sync_start_args()
    args.createSyncTimePointReq = createSyncTimePointReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_sync_time_point_on_sync_start(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_sync_time_point_on_sync_start_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_sync_time_point_on_sync_start failed: unknown result")

  def update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
    """
    远程复制结束的时候根据时间点的信息在目的端更新时间点信息为已完成的时间点


    Parameters:
     - updateSyncTimePointReq
    """
    self.send_update_sync_time_point_on_sync_finish(updateSyncTimePointReq)
    self.recv_update_sync_time_point_on_sync_finish()

  def send_update_sync_time_point_on_sync_finish(self, updateSyncTimePointReq):
    self._oprot.writeMessageBegin('update_sync_time_point_on_sync_finish', TMessageType.CALL, self._seqid)
    args = update_sync_time_point_on_sync_finish_args()
    args.updateSyncTimePointReq = updateSyncTimePointReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_sync_time_point_on_sync_finish(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_sync_time_point_on_sync_finish_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
    """
    远程复制中途的时候根据时间点快照卷的信息更新同步的时间点的快照卷的信息


    Parameters:
     - updateSyncTimePointVolumeReq
    """
    self.send_update_sync_time_point_base_map_snap(updateSyncTimePointVolumeReq)
    self.recv_update_sync_time_point_base_map_snap()

  def send_update_sync_time_point_base_map_snap(self, updateSyncTimePointVolumeReq):
    self._oprot.writeMessageBegin('update_sync_time_point_base_map_snap', TMessageType.CALL, self._seqid)
    args = update_sync_time_point_base_map_snap_args()
    args.updateSyncTimePointVolumeReq = updateSyncTimePointVolumeReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_sync_time_point_base_map_snap(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_sync_time_point_base_map_snap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
    """
    远程复制删除未完成的时间点
     @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


    Parameters:
     - deleteSyncTimePointIds
    """
    self.send_delete_sync_time_point_by_id(deleteSyncTimePointIds)
    return self.recv_delete_sync_time_point_by_id()

  def send_delete_sync_time_point_by_id(self, deleteSyncTimePointIds):
    self._oprot.writeMessageBegin('delete_sync_time_point_by_id', TMessageType.CALL, self._seqid)
    args = delete_sync_time_point_by_id_args()
    args.deleteSyncTimePointIds = deleteSyncTimePointIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_sync_time_point_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_sync_time_point_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_sync_time_point_by_id failed: unknown result")

  def update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
    """
    远程复制过程中更新任务的状态
     @ return ncCdmDispatchProto.ncDeleteSyncTimePointResponse


    Parameters:
     - UpdateJobStatusReq
    """
    self.send_update_job_status_origin_job_by_id(UpdateJobStatusReq)
    self.recv_update_job_status_origin_job_by_id()

  def send_update_job_status_origin_job_by_id(self, UpdateJobStatusReq):
    self._oprot.writeMessageBegin('update_job_status_origin_job_by_id', TMessageType.CALL, self._seqid)
    args = update_job_status_origin_job_by_id_args()
    args.UpdateJobStatusReq = UpdateJobStatusReq
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_job_status_origin_job_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = update_job_status_origin_job_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def check_time_point_is_exist(self, timePointId):
    """
    检测时间点是否存在，只检测状态是完成状态的时间点，其他状态视为不存在时间点
    @ return True:存在时间点, False： 不存在时间点


    Parameters:
     - timePointId
    """
    self.send_check_time_point_is_exist(timePointId)
    return self.recv_check_time_point_is_exist()

  def send_check_time_point_is_exist(self, timePointId):
    self._oprot.writeMessageBegin('check_time_point_is_exist', TMessageType.CALL, self._seqid)
    args = check_time_point_is_exist_args()
    args.timePointId = timePointId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_time_point_is_exist(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_time_point_is_exist_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_time_point_is_exist failed: unknown result")

  def get_dict_export(self, body, jobInstanceId, userId):
    """
    获取image的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_get_dict_export(body, jobInstanceId, userId)
    return self.recv_get_dict_export()

  def send_get_dict_export(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('get_dict_export', TMessageType.CALL, self._seqid)
    args = get_dict_export_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_dict_export(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_dict_export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dict_export failed: unknown result")

  def mount_get_dict_export(self, body, jobInstanceId, userId):
    """
    获取mount任务的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_mount_get_dict_export(body, jobInstanceId, userId)
    return self.recv_mount_get_dict_export()

  def send_mount_get_dict_export(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('mount_get_dict_export', TMessageType.CALL, self._seqid)
    args = mount_get_dict_export_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mount_get_dict_export(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = mount_get_dict_export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mount_get_dict_export failed: unknown result")

  def backup_get_dict_export(self, body, jobInstanceId, userId):
    """
    获取备份任务的执行输出，并导出日志
    @ return


    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_backup_get_dict_export(body, jobInstanceId, userId)
    return self.recv_backup_get_dict_export()

  def send_backup_get_dict_export(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('backup_get_dict_export', TMessageType.CALL, self._seqid)
    args = backup_get_dict_export_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_backup_get_dict_export(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = backup_get_dict_export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "backup_get_dict_export failed: unknown result")

  def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    """
    生产资源类型 sourceType
    服务类型     svcType
    生产资源标识 sourceId
    @ return


    Parameters:
     - sourceType
     - svcType
     - sourceId
     - relation
    """
    self.send_get_jobs_by_sourceId(sourceType, svcType, sourceId, relation)
    return self.recv_get_jobs_by_sourceId()

  def send_get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    self._oprot.writeMessageBegin('get_jobs_by_sourceId', TMessageType.CALL, self._seqid)
    args = get_jobs_by_sourceId_args()
    args.sourceType = sourceType
    args.svcType = svcType
    args.sourceId = sourceId
    args.relation = relation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_by_sourceId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_by_sourceId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_sourceId failed: unknown result")

  def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    """
    数据源       datasource
    客户端ID     clientId
    数据源的用户名(适用于多用户场景)   dbRunUserName
    @ return


    Parameters:
     - datasource
     - clientId
     - dbRunUserName
    """
    self.send_get_jobs_by_datasource(datasource, clientId, dbRunUserName)
    return self.recv_get_jobs_by_datasource()

  def send_get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    self._oprot.writeMessageBegin('get_jobs_by_datasource', TMessageType.CALL, self._seqid)
    args = get_jobs_by_datasource_args()
    args.datasource = datasource
    args.clientId = clientId
    args.dbRunUserName = dbRunUserName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_by_datasource(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_by_datasource_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_datasource failed: unknown result")

  def get_sync_job_origin_job_by_id(self, originJobId):
    """
    根据originJobId获取同步任务的信息
    @ return


    Parameters:
     - originJobId
    """
    self.send_get_sync_job_origin_job_by_id(originJobId)
    return self.recv_get_sync_job_origin_job_by_id()

  def send_get_sync_job_origin_job_by_id(self, originJobId):
    self._oprot.writeMessageBegin('get_sync_job_origin_job_by_id', TMessageType.CALL, self._seqid)
    args = get_sync_job_origin_job_by_id_args()
    args.originJobId = originJobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_sync_job_origin_job_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_sync_job_origin_job_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sync_job_origin_job_by_id failed: unknown result")

  def check_user_has_data(self, user_list):
    """
    检测用户是否存在存储数据
    @ return 返回有存储数据的用户列表


    Parameters:
     - user_list
    """
    self.send_check_user_has_data(user_list)
    return self.recv_check_user_has_data()

  def send_check_user_has_data(self, user_list):
    self._oprot.writeMessageBegin('check_user_has_data', TMessageType.CALL, self._seqid)
    args = check_user_has_data_args()
    args.user_list = user_list
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_user_has_data(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_user_has_data_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_user_has_data failed: unknown result")

  def resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id):
    """
     清理CDM数据清理任务的时间点
    input:清理任务的id,清理类型,时间点,当前登陆用户
     @ return


    Parameters:
     - job_id
     - clean_type
     - time_points
     - user
     - clean_job_id
    """
    self.send_resolve_clean_job_time_points(job_id, clean_type, time_points, user, clean_job_id)
    self.recv_resolve_clean_job_time_points()

  def send_resolve_clean_job_time_points(self, job_id, clean_type, time_points, user, clean_job_id):
    self._oprot.writeMessageBegin('resolve_clean_job_time_points', TMessageType.CALL, self._seqid)
    args = resolve_clean_job_time_points_args()
    args.job_id = job_id
    args.clean_type = clean_type
    args.time_points = time_points
    args.user = user
    args.clean_job_id = clean_job_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_clean_job_time_points(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = resolve_clean_job_time_points_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_job_count_info(self, startTime, userId):
    """
    获取CDM备份任务数
    @ return 备份任务的数量


    Parameters:
     - startTime
     - userId
    """
    self.send_get_job_count_info(startTime, userId)
    return self.recv_get_job_count_info()

  def send_get_job_count_info(self, startTime, userId):
    self._oprot.writeMessageBegin('get_job_count_info', TMessageType.CALL, self._seqid)
    args = get_job_count_info_args()
    args.startTime = startTime
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_job_count_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_job_count_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_job_count_info failed: unknown result")

  def run_backup_job_handler(self, job_instance_id, user_id):
    """
    运行备份任务转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    self.send_run_backup_job_handler(job_instance_id, user_id)
    self.recv_run_backup_job_handler()

  def send_run_backup_job_handler(self, job_instance_id, user_id):
    self._oprot.writeMessageBegin('run_backup_job_handler', TMessageType.CALL, self._seqid)
    args = run_backup_job_handler_args()
    args.job_instance_id = job_instance_id
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run_backup_job_handler(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = run_backup_job_handler_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def run_mount_job_handler(self, job_instance_id, user_id):
    """
    运行挂载任务转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    self.send_run_mount_job_handler(job_instance_id, user_id)
    self.recv_run_mount_job_handler()

  def send_run_mount_job_handler(self, job_instance_id, user_id):
    self._oprot.writeMessageBegin('run_mount_job_handler', TMessageType.CALL, self._seqid)
    args = run_mount_job_handler_args()
    args.job_instance_id = job_instance_id
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run_mount_job_handler(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = run_mount_job_handler_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def image_mount_handler(self, job_instance_id, user_id):
    """
    image mount操作转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    self.send_image_mount_handler(job_instance_id, user_id)
    self.recv_image_mount_handler()

  def send_image_mount_handler(self, job_instance_id, user_id):
    self._oprot.writeMessageBegin('image_mount_handler', TMessageType.CALL, self._seqid)
    args = image_mount_handler_args()
    args.job_instance_id = job_instance_id
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_image_mount_handler(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = image_mount_handler_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def image_unmount_handler(self, job_instance_id, user_id):
    """
    image unmount操作转接接口
    @ return


    Parameters:
     - job_instance_id
     - user_id
    """
    self.send_image_unmount_handler(job_instance_id, user_id)
    self.recv_image_unmount_handler()

  def send_image_unmount_handler(self, job_instance_id, user_id):
    self._oprot.writeMessageBegin('image_unmount_handler', TMessageType.CALL, self._seqid)
    args = image_unmount_handler_args()
    args.job_instance_id = job_instance_id
    args.user_id = user_id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_image_unmount_handler(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = image_unmount_handler_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["microprobe"] = Processor.process_microprobe
    self._processMap["get_all_jobs"] = Processor.process_get_all_jobs
    self._processMap["get_all_mount_jobs"] = Processor.process_get_all_mount_jobs
    self._processMap["get_all_mounted_images"] = Processor.process_get_all_mounted_images
    self._processMap["get_backup_jobs_by_pool"] = Processor.process_get_backup_jobs_by_pool
    self._processMap["get_mount_jobs_by_pool"] = Processor.process_get_mount_jobs_by_pool
    self._processMap["get_residue_mount_jobs_by_pool"] = Processor.process_get_residue_mount_jobs_by_pool
    self._processMap["get_images_by_pool"] = Processor.process_get_images_by_pool
    self._processMap["get_job"] = Processor.process_get_job
    self._processMap["update_jobs_nstart_time"] = Processor.process_update_jobs_nstart_time
    self._processMap["get_jobs_like_for_schedule"] = Processor.process_get_jobs_like_for_schedule
    self._processMap["get_jobs_for_schedule_by_ids"] = Processor.process_get_jobs_for_schedule_by_ids
    self._processMap["commit_job"] = Processor.process_commit_job
    self._processMap["get_support_backup_type"] = Processor.process_get_support_backup_type
    self._processMap["get_jobs_by_instance_name"] = Processor.process_get_jobs_by_instance_name
    self._processMap["client_exsit_job"] = Processor.process_client_exsit_job
    self._processMap["get_db_job_instances"] = Processor.process_get_db_job_instances
    self._processMap["get_db_job_mappings"] = Processor.process_get_db_job_mappings
    self._processMap["ExcuteSnapshot"] = Processor.process_ExcuteSnapshot
    self._processMap["ExcuteSnapshotHw"] = Processor.process_ExcuteSnapshotHw
    self._processMap["del_exceeded_snapshot_copies"] = Processor.process_del_exceeded_snapshot_copies
    self._processMap["ExcuteSnapshot_mount"] = Processor.process_ExcuteSnapshot_mount
    self._processMap["UpdateMountPoint"] = Processor.process_UpdateMountPoint
    self._processMap["GetLunCopyStatus"] = Processor.process_GetLunCopyStatus
    self._processMap["CreateTimepoint"] = Processor.process_CreateTimepoint
    self._processMap["remove_all_jobs_by_client_ids"] = Processor.process_remove_all_jobs_by_client_ids
    self._processMap["remove_all_jobs_by_vplatform_ids"] = Processor.process_remove_all_jobs_by_vplatform_ids
    self._processMap["stop_backup_jobs_by_pool"] = Processor.process_stop_backup_jobs_by_pool
    self._processMap["getTaskCdmLuns"] = Processor.process_getTaskCdmLuns
    self._processMap["createCdmLun"] = Processor.process_createCdmLun
    self._processMap["updateCdmLunInfo"] = Processor.process_updateCdmLunInfo
    self._processMap["createVmCdmLunInfo"] = Processor.process_createVmCdmLunInfo
    self._processMap["getVmCdmLunInfo"] = Processor.process_getVmCdmLunInfo
    self._processMap["createVmwareTimePoint"] = Processor.process_createVmwareTimePoint
    self._processMap["get_all_backup_jobs_historys_for_ams"] = Processor.process_get_all_backup_jobs_historys_for_ams
    self._processMap["get_all_backup_jobs_for_ams"] = Processor.process_get_all_backup_jobs_for_ams
    self._processMap["get_all_mount_job_for_ams"] = Processor.process_get_all_mount_job_for_ams
    self._processMap["get_all_mount_jobInstance_for_ams"] = Processor.process_get_all_mount_jobInstance_for_ams
    self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
    self._processMap["do_operation_from_ams"] = Processor.process_do_operation_from_ams
    self._processMap["is_exists_running_job_on_client"] = Processor.process_is_exists_running_job_on_client
    self._processMap["is_exists_time_points_by_backup_job_id"] = Processor.process_is_exists_time_points_by_backup_job_id
    self._processMap["is_exists_base_volumes_by_backup_job_id"] = Processor.process_is_exists_base_volumes_by_backup_job_id
    self._processMap["get_origin_job_by_id"] = Processor.process_get_origin_job_by_id
    self._processMap["get_time_points_by_origin_job_id"] = Processor.process_get_time_points_by_origin_job_id
    self._processMap["create_sync_job"] = Processor.process_create_sync_job
    self._processMap["get_can_sync_jobs"] = Processor.process_get_can_sync_jobs
    self._processMap["create_sync_time_point"] = Processor.process_create_sync_time_point
    self._processMap["is_exists_origin_job_by_id"] = Processor.process_is_exists_origin_job_by_id
    self._processMap["create_sync_time_point_on_sync_start"] = Processor.process_create_sync_time_point_on_sync_start
    self._processMap["update_sync_time_point_on_sync_finish"] = Processor.process_update_sync_time_point_on_sync_finish
    self._processMap["update_sync_time_point_base_map_snap"] = Processor.process_update_sync_time_point_base_map_snap
    self._processMap["delete_sync_time_point_by_id"] = Processor.process_delete_sync_time_point_by_id
    self._processMap["update_job_status_origin_job_by_id"] = Processor.process_update_job_status_origin_job_by_id
    self._processMap["check_time_point_is_exist"] = Processor.process_check_time_point_is_exist
    self._processMap["get_dict_export"] = Processor.process_get_dict_export
    self._processMap["mount_get_dict_export"] = Processor.process_mount_get_dict_export
    self._processMap["backup_get_dict_export"] = Processor.process_backup_get_dict_export
    self._processMap["get_jobs_by_sourceId"] = Processor.process_get_jobs_by_sourceId
    self._processMap["get_jobs_by_datasource"] = Processor.process_get_jobs_by_datasource
    self._processMap["get_sync_job_origin_job_by_id"] = Processor.process_get_sync_job_origin_job_by_id
    self._processMap["check_user_has_data"] = Processor.process_check_user_has_data
    self._processMap["resolve_clean_job_time_points"] = Processor.process_resolve_clean_job_time_points
    self._processMap["get_job_count_info"] = Processor.process_get_job_count_info
    self._processMap["run_backup_job_handler"] = Processor.process_run_backup_job_handler
    self._processMap["run_mount_job_handler"] = Processor.process_run_mount_job_handler
    self._processMap["image_mount_handler"] = Processor.process_image_mount_handler
    self._processMap["image_unmount_handler"] = Processor.process_image_unmount_handler

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_microprobe(self, seqid, iprot, oprot):
    args = microprobe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = microprobe_result()
    try:
      self._handler.microprobe()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("microprobe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_jobs(self, seqid, iprot, oprot):
    args = get_all_jobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_jobs_result()
    try:
      result.success = self._handler.get_all_jobs()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_jobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_mount_jobs(self, seqid, iprot, oprot):
    args = get_all_mount_jobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_mount_jobs_result()
    try:
      result.success = self._handler.get_all_mount_jobs()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_mount_jobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_mounted_images(self, seqid, iprot, oprot):
    args = get_all_mounted_images_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_mounted_images_result()
    try:
      result.success = self._handler.get_all_mounted_images()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_mounted_images", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_backup_jobs_by_pool(self, seqid, iprot, oprot):
    args = get_backup_jobs_by_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_backup_jobs_by_pool_result()
    try:
      result.success = self._handler.get_backup_jobs_by_pool(args.pool_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_backup_jobs_by_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_mount_jobs_by_pool(self, seqid, iprot, oprot):
    args = get_mount_jobs_by_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_mount_jobs_by_pool_result()
    try:
      result.success = self._handler.get_mount_jobs_by_pool(args.pool_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_mount_jobs_by_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_residue_mount_jobs_by_pool(self, seqid, iprot, oprot):
    args = get_residue_mount_jobs_by_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_residue_mount_jobs_by_pool_result()
    try:
      result.success = self._handler.get_residue_mount_jobs_by_pool(args.pool_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_residue_mount_jobs_by_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_images_by_pool(self, seqid, iprot, oprot):
    args = get_images_by_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_images_by_pool_result()
    try:
      result.success = self._handler.get_images_by_pool(args.pool_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_images_by_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_job(self, seqid, iprot, oprot):
    args = get_job_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_job_result()
    try:
      result.success = self._handler.get_job(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_job", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_jobs_nstart_time(self, seqid, iprot, oprot):
    args = update_jobs_nstart_time_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_jobs_nstart_time_result()
    try:
      self._handler.update_jobs_nstart_time(args.jobs_params)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("update_jobs_nstart_time", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_like_for_schedule(self, seqid, iprot, oprot):
    args = get_jobs_like_for_schedule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_like_for_schedule_result()
    try:
      result.success = self._handler.get_jobs_like_for_schedule(args.jobName, args.clientIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_like_for_schedule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_for_schedule_by_ids(self, seqid, iprot, oprot):
    args = get_jobs_for_schedule_by_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_for_schedule_by_ids_result()
    try:
      result.success = self._handler.get_jobs_for_schedule_by_ids(args.jobIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_for_schedule_by_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit_job(self, seqid, iprot, oprot):
    args = commit_job_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_job_result()
    try:
      self._handler.commit_job(args.jobId, args.customer, args.backupType, args.desc, args.is_auto_execute, args.nstart_time, args.strategy_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("commit_job", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_support_backup_type(self, seqid, iprot, oprot):
    args = get_support_backup_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_support_backup_type_result()
    try:
      result.success = self._handler.get_support_backup_type(args.job_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_support_backup_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_by_instance_name(self, seqid, iprot, oprot):
    args = get_jobs_by_instance_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_by_instance_name_result()
    try:
      result.success = self._handler.get_jobs_by_instance_name(args.instance_name)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_by_instance_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_client_exsit_job(self, seqid, iprot, oprot):
    args = client_exsit_job_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = client_exsit_job_result()
    try:
      result.success = self._handler.client_exsit_job(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("client_exsit_job", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_db_job_instances(self, seqid, iprot, oprot):
    args = get_db_job_instances_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_db_job_instances_result()
    try:
      result.success = self._handler.get_db_job_instances(args.request)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_db_job_instances", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_db_job_mappings(self, seqid, iprot, oprot):
    args = get_db_job_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_db_job_mappings_result()
    try:
      result.success = self._handler.get_db_job_mappings(args.request)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_db_job_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ExcuteSnapshot(self, seqid, iprot, oprot):
    args = ExcuteSnapshot_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExcuteSnapshot_result()
    try:
      self._handler.ExcuteSnapshot(args.lunUuids, args.copiesNum, args.timePoint)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("ExcuteSnapshot", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ExcuteSnapshotHw(self, seqid, iprot, oprot):
    args = ExcuteSnapshotHw_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExcuteSnapshotHw_result()
    try:
      self._handler.ExcuteSnapshotHw(args.lunUuids, args.copiesNum, args.timePoint)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("ExcuteSnapshotHw", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_del_exceeded_snapshot_copies(self, seqid, iprot, oprot):
    args = del_exceeded_snapshot_copies_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = del_exceeded_snapshot_copies_result()
    try:
      result.success = self._handler.del_exceeded_snapshot_copies(args.lunUuids, args.copiesNum)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("del_exceeded_snapshot_copies", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ExcuteSnapshot_mount(self, seqid, iprot, oprot):
    args = ExcuteSnapshot_mount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExcuteSnapshot_mount_result()
    try:
      result.success = self._handler.ExcuteSnapshot_mount(args.lunUuids, args.backupType, args.jobCid, args.protocol)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("ExcuteSnapshot_mount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UpdateMountPoint(self, seqid, iprot, oprot):
    args = UpdateMountPoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UpdateMountPoint_result()
    try:
      self._handler.UpdateMountPoint(args.clientMac, args.connector, args.snapshotName, args.drivername)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("UpdateMountPoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLunCopyStatus(self, seqid, iprot, oprot):
    args = GetLunCopyStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLunCopyStatus_result()
    try:
      result.success = self._handler.GetLunCopyStatus(args.volId, args.lunCopyId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("GetLunCopyStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateTimepoint(self, seqid, iprot, oprot):
    args = CreateTimepoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateTimepoint_result()
    try:
      self._handler.CreateTimepoint(args.lunUuids, args.timePoint)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("CreateTimepoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove_all_jobs_by_client_ids(self, seqid, iprot, oprot):
    args = remove_all_jobs_by_client_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_all_jobs_by_client_ids_result()
    try:
      result.success = self._handler.remove_all_jobs_by_client_ids(args.clientIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("remove_all_jobs_by_client_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove_all_jobs_by_vplatform_ids(self, seqid, iprot, oprot):
    args = remove_all_jobs_by_vplatform_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_all_jobs_by_vplatform_ids_result()
    try:
      result.success = self._handler.remove_all_jobs_by_vplatform_ids(args.vplatformIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("remove_all_jobs_by_vplatform_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stop_backup_jobs_by_pool(self, seqid, iprot, oprot):
    args = stop_backup_jobs_by_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stop_backup_jobs_by_pool_result()
    try:
      self._handler.stop_backup_jobs_by_pool(args.pool_id, args.pool_name)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("stop_backup_jobs_by_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTaskCdmLuns(self, seqid, iprot, oprot):
    args = getTaskCdmLuns_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTaskCdmLuns_result()
    try:
      result.success = self._handler.getTaskCdmLuns(args.jobid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("getTaskCdmLuns", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createCdmLun(self, seqid, iprot, oprot):
    args = createCdmLun_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createCdmLun_result()
    try:
      result.success = self._handler.createCdmLun(args.size, args.jobId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("createCdmLun", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateCdmLunInfo(self, seqid, iprot, oprot):
    args = updateCdmLunInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateCdmLunInfo_result()
    try:
      self._handler.updateCdmLunInfo(args.cdmLuns, args.jobId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("updateCdmLunInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createVmCdmLunInfo(self, seqid, iprot, oprot):
    args = createVmCdmLunInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createVmCdmLunInfo_result()
    try:
      self._handler.createVmCdmLunInfo(args.vmVolumes, args.job_id, args.timepoint)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("createVmCdmLunInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getVmCdmLunInfo(self, seqid, iprot, oprot):
    args = getVmCdmLunInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getVmCdmLunInfo_result()
    try:
      result.success = self._handler.getVmCdmLunInfo(args.job_id, args.vmuuid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("getVmCdmLunInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createVmwareTimePoint(self, seqid, iprot, oprot):
    args = createVmwareTimePoint_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createVmwareTimePoint_result()
    try:
      self._handler.createVmwareTimePoint(args.vminfos, args.timepoint, args.job_id)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("createVmwareTimePoint", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_backup_jobs_historys_for_ams(self, seqid, iprot, oprot):
    args = get_all_backup_jobs_historys_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_backup_jobs_historys_for_ams_result()
    try:
      result.success = self._handler.get_all_backup_jobs_historys_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_backup_jobs_historys_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_backup_jobs_for_ams(self, seqid, iprot, oprot):
    args = get_all_backup_jobs_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_backup_jobs_for_ams_result()
    try:
      result.success = self._handler.get_all_backup_jobs_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_backup_jobs_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_mount_job_for_ams(self, seqid, iprot, oprot):
    args = get_all_mount_job_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_mount_job_for_ams_result()
    try:
      result.success = self._handler.get_all_mount_job_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_mount_job_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_mount_jobInstance_for_ams(self, seqid, iprot, oprot):
    args = get_all_mount_jobInstance_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_mount_jobInstance_for_ams_result()
    try:
      result.success = self._handler.get_all_mount_jobInstance_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_mount_jobInstance_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_data_for_ams(self, seqid, iprot, oprot):
    args = get_data_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_data_for_ams_result()
    try:
      result.success = self._handler.get_data_for_ams(args.kwargs)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_data_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_do_operation_from_ams(self, seqid, iprot, oprot):
    args = do_operation_from_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = do_operation_from_ams_result()
    try:
      result.success = self._handler.do_operation_from_ams(args.target, args.method, args.kwargs)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("do_operation_from_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_exists_running_job_on_client(self, seqid, iprot, oprot):
    args = is_exists_running_job_on_client_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_exists_running_job_on_client_result()
    try:
      result.success = self._handler.is_exists_running_job_on_client(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("is_exists_running_job_on_client", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_exists_time_points_by_backup_job_id(self, seqid, iprot, oprot):
    args = is_exists_time_points_by_backup_job_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_exists_time_points_by_backup_job_id_result()
    try:
      result.success = self._handler.is_exists_time_points_by_backup_job_id(args.backup_job_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("is_exists_time_points_by_backup_job_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_exists_base_volumes_by_backup_job_id(self, seqid, iprot, oprot):
    args = is_exists_base_volumes_by_backup_job_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_exists_base_volumes_by_backup_job_id_result()
    try:
      result.success = self._handler.is_exists_base_volumes_by_backup_job_id(args.backup_job_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("is_exists_base_volumes_by_backup_job_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_origin_job_by_id(self, seqid, iprot, oprot):
    args = get_origin_job_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_origin_job_by_id_result()
    try:
      result.success = self._handler.get_origin_job_by_id(args.originJobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_origin_job_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_time_points_by_origin_job_id(self, seqid, iprot, oprot):
    args = get_time_points_by_origin_job_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_time_points_by_origin_job_id_result()
    try:
      result.success = self._handler.get_time_points_by_origin_job_id(args.TimePointReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_time_points_by_origin_job_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_sync_job(self, seqid, iprot, oprot):
    args = create_sync_job_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_sync_job_result()
    try:
      self._handler.create_sync_job(args.createSyncJobReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("create_sync_job", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_can_sync_jobs(self, seqid, iprot, oprot):
    args = get_can_sync_jobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_can_sync_jobs_result()
    try:
      result.success = self._handler.get_can_sync_jobs(args.canSyncJobReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_can_sync_jobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_sync_time_point(self, seqid, iprot, oprot):
    args = create_sync_time_point_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_sync_time_point_result()
    try:
      self._handler.create_sync_time_point(args.createSyncTimePointReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("create_sync_time_point", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_exists_origin_job_by_id(self, seqid, iprot, oprot):
    args = is_exists_origin_job_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_exists_origin_job_by_id_result()
    try:
      result.success = self._handler.is_exists_origin_job_by_id(args.originJobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("is_exists_origin_job_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_sync_time_point_on_sync_start(self, seqid, iprot, oprot):
    args = create_sync_time_point_on_sync_start_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_sync_time_point_on_sync_start_result()
    try:
      result.success = self._handler.create_sync_time_point_on_sync_start(args.createSyncTimePointReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("create_sync_time_point_on_sync_start", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_sync_time_point_on_sync_finish(self, seqid, iprot, oprot):
    args = update_sync_time_point_on_sync_finish_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_sync_time_point_on_sync_finish_result()
    try:
      self._handler.update_sync_time_point_on_sync_finish(args.updateSyncTimePointReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("update_sync_time_point_on_sync_finish", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_sync_time_point_base_map_snap(self, seqid, iprot, oprot):
    args = update_sync_time_point_base_map_snap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_sync_time_point_base_map_snap_result()
    try:
      self._handler.update_sync_time_point_base_map_snap(args.updateSyncTimePointVolumeReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("update_sync_time_point_base_map_snap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_sync_time_point_by_id(self, seqid, iprot, oprot):
    args = delete_sync_time_point_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_sync_time_point_by_id_result()
    try:
      result.success = self._handler.delete_sync_time_point_by_id(args.deleteSyncTimePointIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_sync_time_point_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_job_status_origin_job_by_id(self, seqid, iprot, oprot):
    args = update_job_status_origin_job_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_job_status_origin_job_by_id_result()
    try:
      self._handler.update_job_status_origin_job_by_id(args.UpdateJobStatusReq)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("update_job_status_origin_job_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_time_point_is_exist(self, seqid, iprot, oprot):
    args = check_time_point_is_exist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_time_point_is_exist_result()
    try:
      result.success = self._handler.check_time_point_is_exist(args.timePointId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("check_time_point_is_exist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_dict_export(self, seqid, iprot, oprot):
    args = get_dict_export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_dict_export_result()
    try:
      result.success = self._handler.get_dict_export(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_dict_export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mount_get_dict_export(self, seqid, iprot, oprot):
    args = mount_get_dict_export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mount_get_dict_export_result()
    try:
      result.success = self._handler.mount_get_dict_export(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("mount_get_dict_export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_backup_get_dict_export(self, seqid, iprot, oprot):
    args = backup_get_dict_export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = backup_get_dict_export_result()
    try:
      result.success = self._handler.backup_get_dict_export(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("backup_get_dict_export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_by_sourceId(self, seqid, iprot, oprot):
    args = get_jobs_by_sourceId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_by_sourceId_result()
    try:
      result.success = self._handler.get_jobs_by_sourceId(args.sourceType, args.svcType, args.sourceId, args.relation)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_by_sourceId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_by_datasource(self, seqid, iprot, oprot):
    args = get_jobs_by_datasource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_by_datasource_result()
    try:
      result.success = self._handler.get_jobs_by_datasource(args.datasource, args.clientId, args.dbRunUserName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_by_datasource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_sync_job_origin_job_by_id(self, seqid, iprot, oprot):
    args = get_sync_job_origin_job_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_sync_job_origin_job_by_id_result()
    try:
      result.success = self._handler.get_sync_job_origin_job_by_id(args.originJobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_sync_job_origin_job_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_user_has_data(self, seqid, iprot, oprot):
    args = check_user_has_data_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_user_has_data_result()
    try:
      result.success = self._handler.check_user_has_data(args.user_list)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("check_user_has_data", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_clean_job_time_points(self, seqid, iprot, oprot):
    args = resolve_clean_job_time_points_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_clean_job_time_points_result()
    try:
      self._handler.resolve_clean_job_time_points(args.job_id, args.clean_type, args.time_points, args.user, args.clean_job_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("resolve_clean_job_time_points", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_job_count_info(self, seqid, iprot, oprot):
    args = get_job_count_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_job_count_info_result()
    try:
      result.success = self._handler.get_job_count_info(args.startTime, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_job_count_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_run_backup_job_handler(self, seqid, iprot, oprot):
    args = run_backup_job_handler_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = run_backup_job_handler_result()
    try:
      self._handler.run_backup_job_handler(args.job_instance_id, args.user_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("run_backup_job_handler", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_run_mount_job_handler(self, seqid, iprot, oprot):
    args = run_mount_job_handler_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = run_mount_job_handler_result()
    try:
      self._handler.run_mount_job_handler(args.job_instance_id, args.user_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("run_mount_job_handler", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_image_mount_handler(self, seqid, iprot, oprot):
    args = image_mount_handler_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = image_mount_handler_result()
    try:
      self._handler.image_mount_handler(args.job_instance_id, args.user_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("image_mount_handler", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_image_unmount_handler(self, seqid, iprot, oprot):
    args = image_unmount_handler_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = image_unmount_handler_result()
    try:
      self._handler.image_unmount_handler(args.job_instance_id, args.user_id)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("image_unmount_handler", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class microprobe_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('microprobe_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class microprobe_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('microprobe_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_jobs_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_jobs_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_jobs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncJob.ttypes.ncTJob()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_jobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_jobs_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_jobs_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_jobs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = ncJob.ttypes.ncTJob()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_jobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mounted_images_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mounted_images_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mounted_images_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = ncJob.ttypes.ncTJob()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mounted_images_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_backup_jobs_by_pool_args(object):
  """
  Attributes:
   - pool_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_id', None, None, ), # 1
  )

  def __init__(self, pool_id=None,):
    self.pool_id = pool_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_backup_jobs_by_pool_args')
    if self.pool_id is not None:
      oprot.writeFieldBegin('pool_id', TType.STRING, 1)
      oprot.writeString(self.pool_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_backup_jobs_by_pool_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = ncJob.ttypes.ncTJob()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_backup_jobs_by_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mount_jobs_by_pool_args(object):
  """
  Attributes:
   - pool_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_id', None, None, ), # 1
  )

  def __init__(self, pool_id=None,):
    self.pool_id = pool_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mount_jobs_by_pool_args')
    if self.pool_id is not None:
      oprot.writeFieldBegin('pool_id', TType.STRING, 1)
      oprot.writeString(self.pool_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_mount_jobs_by_pool_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = ncJob.ttypes.ncTJob()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_mount_jobs_by_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_residue_mount_jobs_by_pool_args(object):
  """
  Attributes:
   - pool_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_id', None, None, ), # 1
  )

  def __init__(self, pool_id=None,):
    self.pool_id = pool_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_residue_mount_jobs_by_pool_args')
    if self.pool_id is not None:
      oprot.writeFieldBegin('pool_id', TType.STRING, 1)
      oprot.writeString(self.pool_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_residue_mount_jobs_by_pool_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = ncJob.ttypes.ncTJob()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_residue_mount_jobs_by_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_images_by_pool_args(object):
  """
  Attributes:
   - pool_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_id', None, None, ), # 1
  )

  def __init__(self, pool_id=None,):
    self.pool_id = pool_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_images_by_pool_args')
    if self.pool_id is not None:
      oprot.writeFieldBegin('pool_id', TType.STRING, 1)
      oprot.writeString(self.pool_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_images_by_pool_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncImage, ncCdmDispatchProto.ttypes.ncImage.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = ncCdmDispatchProto.ttypes.ncImage()
            _elem47.read(iprot)
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_images_by_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter48 in self.success:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_job_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_job_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_job_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncJob.ttypes.ncTJob()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_job_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_jobs_nstart_time_args(object):
  """
  Attributes:
   - jobs_params
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'jobs_params', (TType.STRING,None,TType.I64,None), None, ), # 1
  )

  def __init__(self, jobs_params=None,):
    self.jobs_params = jobs_params

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.jobs_params = {}
          (_ktype50, _vtype51, _size49 ) = iprot.readMapBegin()
          for _i53 in xrange(_size49):
            _key54 = iprot.readString().decode('utf-8')
            _val55 = iprot.readI64()
            self.jobs_params[_key54] = _val55
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_jobs_nstart_time_args')
    if self.jobs_params is not None:
      oprot.writeFieldBegin('jobs_params', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.jobs_params))
      for kiter56,viter57 in self.jobs_params.items():
        oprot.writeString(kiter56.encode('utf-8'))
        oprot.writeI64(viter57)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobs_params is None:
      raise TProtocol.TProtocolException(message='Required field jobs_params is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobs_params)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_jobs_nstart_time_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_jobs_nstart_time_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_like_for_schedule_args(object):
  """
  Attributes:
   - jobName
   - clientIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobName', None, None, ), # 1
    (2, TType.LIST, 'clientIds', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, jobName=None, clientIds=None,):
    self.jobName = jobName
    self.clientIds = clientIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.clientIds = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = iprot.readString().decode('utf-8')
            self.clientIds.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_like_for_schedule_args')
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 1)
      oprot.writeString(self.jobName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.clientIds is not None:
      oprot.writeFieldBegin('clientIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.clientIds))
      for iter64 in self.clientIds:
        oprot.writeString(iter64.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobName)
    value = (value * 31) ^ hash(self.clientIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_like_for_schedule_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = ncJob.ttypes.ncTJob()
            _elem70.read(iprot)
            self.success.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_like_for_schedule_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter71 in self.success:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_for_schedule_by_ids_args(object):
  """
  Attributes:
   - jobIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'jobIds', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, jobIds=None,):
    self.jobIds = jobIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.jobIds = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = iprot.readString().decode('utf-8')
            self.jobIds.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_for_schedule_by_ids_args')
    if self.jobIds is not None:
      oprot.writeFieldBegin('jobIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.jobIds))
      for iter78 in self.jobIds:
        oprot.writeString(iter78.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_for_schedule_by_ids_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = ncJob.ttypes.ncTJob()
            _elem84.read(iprot)
            self.success.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_for_schedule_by_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter85 in self.success:
        iter85.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_job_args(object):
  """
  Attributes:
   - jobId
   - customer
   - backupType
   - desc
   - is_auto_execute
   - nstart_time
   - strategy_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
    (2, TType.STRING, 'customer', None, None, ), # 2
    (3, TType.I32, 'backupType', None, None, ), # 3
    (4, TType.STRING, 'desc', None, None, ), # 4
    (5, TType.BOOL, 'is_auto_execute', None, None, ), # 5
    (6, TType.I64, 'nstart_time', None, None, ), # 6
    (7, TType.STRING, 'strategy_id', None, None, ), # 7
  )

  def __init__(self, jobId=None, customer=None, backupType=None, desc=None, is_auto_execute=None, nstart_time=None, strategy_id=None,):
    self.jobId = jobId
    self.customer = customer
    self.backupType = backupType
    self.desc = desc
    self.is_auto_execute = is_auto_execute
    self.nstart_time = nstart_time
    self.strategy_id = strategy_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.backupType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.desc = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_auto_execute = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.nstart_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.strategy_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_job_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 2)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.backupType is not None:
      oprot.writeFieldBegin('backupType', TType.I32, 3)
      oprot.writeI32(self.backupType)
      oprot.writeFieldEnd()
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 4)
      oprot.writeString(self.desc.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.is_auto_execute is not None:
      oprot.writeFieldBegin('is_auto_execute', TType.BOOL, 5)
      oprot.writeBool(self.is_auto_execute)
      oprot.writeFieldEnd()
    if self.nstart_time is not None:
      oprot.writeFieldBegin('nstart_time', TType.I64, 6)
      oprot.writeI64(self.nstart_time)
      oprot.writeFieldEnd()
    if self.strategy_id is not None:
      oprot.writeFieldBegin('strategy_id', TType.STRING, 7)
      oprot.writeString(self.strategy_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.customer)
    value = (value * 31) ^ hash(self.backupType)
    value = (value * 31) ^ hash(self.desc)
    value = (value * 31) ^ hash(self.is_auto_execute)
    value = (value * 31) ^ hash(self.nstart_time)
    value = (value * 31) ^ hash(self.strategy_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_job_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_job_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_support_backup_type_args(object):
  """
  Attributes:
   - job_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_id', None, None, ), # 1
  )

  def __init__(self, job_id=None,):
    self.job_id = job_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_support_backup_type_args')
    if self.job_id is not None:
      oprot.writeFieldBegin('job_id', TType.STRING, 1)
      oprot.writeString(self.job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_support_backup_type_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = iprot.readI32()
            self.success.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_support_backup_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter92 in self.success:
        oprot.writeI32(iter92)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_instance_name_args(object):
  """
  Attributes:
   - instance_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'instance_name', None, None, ), # 1
  )

  def __init__(self, instance_name=None,):
    self.instance_name = instance_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.instance_name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_instance_name_args')
    if self.instance_name is not None:
      oprot.writeFieldBegin('instance_name', TType.STRING, 1)
      oprot.writeString(self.instance_name.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.instance_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_instance_name_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncDBJobInstance, ncJob.ttypes.ncDBJobInstance.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = ncJob.ttypes.ncDBJobInstance()
            _elem98.read(iprot)
            self.success.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_instance_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter99 in self.success:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class client_exsit_job_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('client_exsit_job_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class client_exsit_job_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('client_exsit_job_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_db_job_instances_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncJob.ttypes.ncDBJobInstanceRequest, ncJob.ttypes.ncDBJobInstanceRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncJob.ttypes.ncDBJobInstanceRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_db_job_instances_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_db_job_instances_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncDBJobInstance, ncJob.ttypes.ncDBJobInstance.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype103, _size100) = iprot.readListBegin()
          for _i104 in xrange(_size100):
            _elem105 = ncJob.ttypes.ncDBJobInstance()
            _elem105.read(iprot)
            self.success.append(_elem105)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_db_job_instances_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter106 in self.success:
        iter106.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_db_job_mappings_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncJob.ttypes.ncDBJobInstanceRequest, ncJob.ttypes.ncDBJobInstanceRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncJob.ttypes.ncDBJobInstanceRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_db_job_mappings_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_db_job_mappings_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncDBJobInstance, ncJob.ttypes.ncDBJobInstance.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype110, _size107) = iprot.readListBegin()
          for _i111 in xrange(_size107):
            _elem112 = ncJob.ttypes.ncDBJobInstance()
            _elem112.read(iprot)
            self.success.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_db_job_mappings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter113 in self.success:
        iter113.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshot_args(object):
  """
  Attributes:
   - lunUuids
   - copiesNum
   - timePoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'copiesNum', None, None, ), # 2
    (3, TType.I64, 'timePoint', None, None, ), # 3
  )

  def __init__(self, lunUuids=None, copiesNum=None, timePoint=None,):
    self.lunUuids = lunUuids
    self.copiesNum = copiesNum
    self.timePoint = timePoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lunUuids = []
          (_etype117, _size114) = iprot.readListBegin()
          for _i118 in xrange(_size114):
            _elem119 = iprot.readString().decode('utf-8')
            self.lunUuids.append(_elem119)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.copiesNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timePoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshot_args')
    if self.lunUuids is not None:
      oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.lunUuids))
      for iter120 in self.lunUuids:
        oprot.writeString(iter120.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.copiesNum is not None:
      oprot.writeFieldBegin('copiesNum', TType.I32, 2)
      oprot.writeI32(self.copiesNum)
      oprot.writeFieldEnd()
    if self.timePoint is not None:
      oprot.writeFieldBegin('timePoint', TType.I64, 3)
      oprot.writeI64(self.timePoint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunUuids)
    value = (value * 31) ^ hash(self.copiesNum)
    value = (value * 31) ^ hash(self.timePoint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshot_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshot_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshotHw_args(object):
  """
  Attributes:
   - lunUuids
   - copiesNum
   - timePoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'copiesNum', None, None, ), # 2
    (3, TType.I64, 'timePoint', None, None, ), # 3
  )

  def __init__(self, lunUuids=None, copiesNum=None, timePoint=None,):
    self.lunUuids = lunUuids
    self.copiesNum = copiesNum
    self.timePoint = timePoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lunUuids = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = iprot.readString().decode('utf-8')
            self.lunUuids.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.copiesNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timePoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshotHw_args')
    if self.lunUuids is not None:
      oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.lunUuids))
      for iter127 in self.lunUuids:
        oprot.writeString(iter127.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.copiesNum is not None:
      oprot.writeFieldBegin('copiesNum', TType.I32, 2)
      oprot.writeI32(self.copiesNum)
      oprot.writeFieldEnd()
    if self.timePoint is not None:
      oprot.writeFieldBegin('timePoint', TType.I64, 3)
      oprot.writeI64(self.timePoint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunUuids)
    value = (value * 31) ^ hash(self.copiesNum)
    value = (value * 31) ^ hash(self.timePoint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshotHw_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshotHw_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_exceeded_snapshot_copies_args(object):
  """
  Attributes:
   - lunUuids
   - copiesNum
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'copiesNum', None, None, ), # 2
  )

  def __init__(self, lunUuids=None, copiesNum=None,):
    self.lunUuids = lunUuids
    self.copiesNum = copiesNum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lunUuids = []
          (_etype131, _size128) = iprot.readListBegin()
          for _i132 in xrange(_size128):
            _elem133 = iprot.readString().decode('utf-8')
            self.lunUuids.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.copiesNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_exceeded_snapshot_copies_args')
    if self.lunUuids is not None:
      oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.lunUuids))
      for iter134 in self.lunUuids:
        oprot.writeString(iter134.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.copiesNum is not None:
      oprot.writeFieldBegin('copiesNum', TType.I32, 2)
      oprot.writeI32(self.copiesNum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunUuids)
    value = (value * 31) ^ hash(self.copiesNum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_exceeded_snapshot_copies_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_exceeded_snapshot_copies_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshot_mount_args(object):
  """
  Attributes:
   - lunUuids
   - backupType
   - jobCid
   - protocol
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'backupType', None, None, ), # 2
    (3, TType.STRING, 'jobCid', None, None, ), # 3
    (4, TType.I32, 'protocol', None, None, ), # 4
  )

  def __init__(self, lunUuids=None, backupType=None, jobCid=None, protocol=None,):
    self.lunUuids = lunUuids
    self.backupType = backupType
    self.jobCid = jobCid
    self.protocol = protocol

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lunUuids = []
          (_etype138, _size135) = iprot.readListBegin()
          for _i139 in xrange(_size135):
            _elem140 = iprot.readString().decode('utf-8')
            self.lunUuids.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.backupType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.jobCid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.protocol = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshot_mount_args')
    if self.lunUuids is not None:
      oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.lunUuids))
      for iter141 in self.lunUuids:
        oprot.writeString(iter141.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.backupType is not None:
      oprot.writeFieldBegin('backupType', TType.I32, 2)
      oprot.writeI32(self.backupType)
      oprot.writeFieldEnd()
    if self.jobCid is not None:
      oprot.writeFieldBegin('jobCid', TType.STRING, 3)
      oprot.writeString(self.jobCid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.protocol is not None:
      oprot.writeFieldBegin('protocol', TType.I32, 4)
      oprot.writeI32(self.protocol)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunUuids)
    value = (value * 31) ^ hash(self.backupType)
    value = (value * 31) ^ hash(self.jobCid)
    value = (value * 31) ^ hash(self.protocol)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExcuteSnapshot_mount_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExcuteSnapshot_mount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateMountPoint_args(object):
  """
  Attributes:
   - clientMac
   - connector
   - snapshotName
   - drivername
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientMac', None, None, ), # 1
    (2, TType.STRING, 'connector', None, None, ), # 2
    (3, TType.STRING, 'snapshotName', None, None, ), # 3
    (4, TType.STRING, 'drivername', None, None, ), # 4
  )

  def __init__(self, clientMac=None, connector=None, snapshotName=None, drivername=None,):
    self.clientMac = clientMac
    self.connector = connector
    self.snapshotName = snapshotName
    self.drivername = drivername

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientMac = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.connector = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.snapshotName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.drivername = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateMountPoint_args')
    if self.clientMac is not None:
      oprot.writeFieldBegin('clientMac', TType.STRING, 1)
      oprot.writeString(self.clientMac.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.connector is not None:
      oprot.writeFieldBegin('connector', TType.STRING, 2)
      oprot.writeString(self.connector.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.snapshotName is not None:
      oprot.writeFieldBegin('snapshotName', TType.STRING, 3)
      oprot.writeString(self.snapshotName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.drivername is not None:
      oprot.writeFieldBegin('drivername', TType.STRING, 4)
      oprot.writeString(self.drivername.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientMac)
    value = (value * 31) ^ hash(self.connector)
    value = (value * 31) ^ hash(self.snapshotName)
    value = (value * 31) ^ hash(self.drivername)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateMountPoint_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateMountPoint_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLunCopyStatus_args(object):
  """
  Attributes:
   - volId
   - lunCopyId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volId', None, None, ), # 1
    (2, TType.STRING, 'lunCopyId', None, None, ), # 2
  )

  def __init__(self, volId=None, lunCopyId=None,):
    self.volId = volId
    self.lunCopyId = lunCopyId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.lunCopyId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLunCopyStatus_args')
    if self.volId is not None:
      oprot.writeFieldBegin('volId', TType.STRING, 1)
      oprot.writeString(self.volId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.lunCopyId is not None:
      oprot.writeFieldBegin('lunCopyId', TType.STRING, 2)
      oprot.writeString(self.lunCopyId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volId)
    value = (value * 31) ^ hash(self.lunCopyId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLunCopyStatus_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLunCopyStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateTimepoint_args(object):
  """
  Attributes:
   - lunUuids
   - timePoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'lunUuids', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'timePoint', None, None, ), # 2
  )

  def __init__(self, lunUuids=None, timePoint=None,):
    self.lunUuids = lunUuids
    self.timePoint = timePoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lunUuids = []
          (_etype145, _size142) = iprot.readListBegin()
          for _i146 in xrange(_size142):
            _elem147 = iprot.readString().decode('utf-8')
            self.lunUuids.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timePoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTimepoint_args')
    if self.lunUuids is not None:
      oprot.writeFieldBegin('lunUuids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.lunUuids))
      for iter148 in self.lunUuids:
        oprot.writeString(iter148.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timePoint is not None:
      oprot.writeFieldBegin('timePoint', TType.I64, 2)
      oprot.writeI64(self.timePoint)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunUuids)
    value = (value * 31) ^ hash(self.timePoint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateTimepoint_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTimepoint_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_client_ids_args(object):
  """
  Attributes:
   - clientIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'clientIds', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, clientIds=None,):
    self.clientIds = clientIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.clientIds = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = iprot.readString().decode('utf-8')
            self.clientIds.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_client_ids_args')
    if self.clientIds is not None:
      oprot.writeFieldBegin('clientIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.clientIds))
      for iter155 in self.clientIds:
        oprot.writeString(iter155.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_client_ids_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCommonType.ttypes.ncTwoStringList, ncCommonType.ttypes.ncTwoStringList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCommonType.ttypes.ncTwoStringList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_client_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_vplatform_ids_args(object):
  """
  Attributes:
   - vplatformIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'vplatformIds', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, vplatformIds=None,):
    self.vplatformIds = vplatformIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.vplatformIds = []
          (_etype159, _size156) = iprot.readListBegin()
          for _i160 in xrange(_size156):
            _elem161 = iprot.readString().decode('utf-8')
            self.vplatformIds.append(_elem161)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_args')
    if self.vplatformIds is not None:
      oprot.writeFieldBegin('vplatformIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.vplatformIds))
      for iter162 in self.vplatformIds:
        oprot.writeString(iter162.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vplatformIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_vplatform_ids_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCommonType.ttypes.ncTwoStringList, ncCommonType.ttypes.ncTwoStringList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCommonType.ttypes.ncTwoStringList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_vplatform_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_backup_jobs_by_pool_args(object):
  """
  Attributes:
   - pool_id
   - pool_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pool_id', None, None, ), # 1
    (2, TType.STRING, 'pool_name', None, None, ), # 2
  )

  def __init__(self, pool_id=None, pool_name=None,):
    self.pool_id = pool_id
    self.pool_name = pool_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pool_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pool_name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_backup_jobs_by_pool_args')
    if self.pool_id is not None:
      oprot.writeFieldBegin('pool_id', TType.STRING, 1)
      oprot.writeString(self.pool_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.pool_name is not None:
      oprot.writeFieldBegin('pool_name', TType.STRING, 2)
      oprot.writeString(self.pool_name.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pool_id)
    value = (value * 31) ^ hash(self.pool_name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_backup_jobs_by_pool_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_backup_jobs_by_pool_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTaskCdmLuns_args(object):
  """
  Attributes:
   - jobid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobid', None, None, ), # 1
  )

  def __init__(self, jobid=None,):
    self.jobid = jobid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTaskCdmLuns_args')
    if self.jobid is not None:
      oprot.writeFieldBegin('jobid', TType.STRING, 1)
      oprot.writeString(self.jobid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTaskCdmLuns_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype166, _size163) = iprot.readListBegin()
          for _i167 in xrange(_size163):
            _elem168 = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
            _elem168.read(iprot)
            self.success.append(_elem168)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTaskCdmLuns_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter169 in self.success:
        iter169.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCdmLun_args(object):
  """
  Attributes:
   - size
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'size', None, None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, size=None, jobId=None,):
    self.size = size
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.size = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCdmLun_args')
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 1)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCdmLun_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCdmLun_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCdmLunInfo_args(object):
  """
  Attributes:
   - cdmLuns
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmLuns', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo, ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, cdmLuns=None, jobId=None,):
    self.cdmLuns = cdmLuns
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmLuns = []
          (_etype173, _size170) = iprot.readListBegin()
          for _i174 in xrange(_size170):
            _elem175 = ncCdmDispatchProto.ttypes.ncThriftCdmLunInfo()
            _elem175.read(iprot)
            self.cdmLuns.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCdmLunInfo_args')
    if self.cdmLuns is not None:
      oprot.writeFieldBegin('cdmLuns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmLuns))
      for iter176 in self.cdmLuns:
        iter176.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmLuns)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCdmLunInfo_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCdmLunInfo_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createVmCdmLunInfo_args(object):
  """
  Attributes:
   - vmVolumes
   - job_id
   - timepoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'vmVolumes', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'job_id', None, None, ), # 2
    (3, TType.STRING, 'timepoint', None, None, ), # 3
  )

  def __init__(self, vmVolumes=None, job_id=None, timepoint=None,):
    self.vmVolumes = vmVolumes
    self.job_id = job_id
    self.timepoint = timepoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.vmVolumes = []
          (_etype180, _size177) = iprot.readListBegin()
          for _i181 in xrange(_size177):
            _elem182 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
            _elem182.read(iprot)
            self.vmVolumes.append(_elem182)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timepoint = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createVmCdmLunInfo_args')
    if self.vmVolumes is not None:
      oprot.writeFieldBegin('vmVolumes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.vmVolumes))
      for iter183 in self.vmVolumes:
        iter183.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.job_id is not None:
      oprot.writeFieldBegin('job_id', TType.STRING, 2)
      oprot.writeString(self.job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timepoint is not None:
      oprot.writeFieldBegin('timepoint', TType.STRING, 3)
      oprot.writeString(self.timepoint.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmVolumes)
    value = (value * 31) ^ hash(self.job_id)
    value = (value * 31) ^ hash(self.timepoint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createVmCdmLunInfo_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createVmCdmLunInfo_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getVmCdmLunInfo_args(object):
  """
  Attributes:
   - job_id
   - vmuuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_id', None, None, ), # 1
    (2, TType.LIST, 'vmuuid', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, job_id=None, vmuuid=None,):
    self.job_id = job_id
    self.vmuuid = vmuuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.vmuuid = []
          (_etype187, _size184) = iprot.readListBegin()
          for _i188 in xrange(_size184):
            _elem189 = iprot.readString().decode('utf-8')
            self.vmuuid.append(_elem189)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getVmCdmLunInfo_args')
    if self.job_id is not None:
      oprot.writeFieldBegin('job_id', TType.STRING, 1)
      oprot.writeString(self.job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.vmuuid is not None:
      oprot.writeFieldBegin('vmuuid', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.vmuuid))
      for iter190 in self.vmuuid:
        oprot.writeString(iter190.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_id)
    value = (value * 31) ^ hash(self.vmuuid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getVmCdmLunInfo_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype194, _size191) = iprot.readListBegin()
          for _i195 in xrange(_size191):
            _elem196 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
            _elem196.read(iprot)
            self.success.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getVmCdmLunInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter197 in self.success:
        iter197.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createVmwareTimePoint_args(object):
  """
  Attributes:
   - vminfos
   - timepoint
   - job_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'vminfos', (TType.STRUCT,(ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo, ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'timepoint', None, None, ), # 2
    (3, TType.STRING, 'job_id', None, None, ), # 3
  )

  def __init__(self, vminfos=None, timepoint=None, job_id=None,):
    self.vminfos = vminfos
    self.timepoint = timepoint
    self.job_id = job_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.vminfos = []
          (_etype201, _size198) = iprot.readListBegin()
          for _i202 in xrange(_size198):
            _elem203 = ncCdmDispatchProto.ttypes.ncThriftVmVolumeInfo()
            _elem203.read(iprot)
            self.vminfos.append(_elem203)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timepoint = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createVmwareTimePoint_args')
    if self.vminfos is not None:
      oprot.writeFieldBegin('vminfos', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.vminfos))
      for iter204 in self.vminfos:
        iter204.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timepoint is not None:
      oprot.writeFieldBegin('timepoint', TType.STRING, 2)
      oprot.writeString(self.timepoint.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.job_id is not None:
      oprot.writeFieldBegin('job_id', TType.STRING, 3)
      oprot.writeString(self.job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vminfos)
    value = (value * 31) ^ hash(self.timepoint)
    value = (value * 31) ^ hash(self.job_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createVmwareTimePoint_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createVmwareTimePoint_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_backup_jobs_historys_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_backup_jobs_historys_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_backup_jobs_historys_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncJobLog, ncAmsJob.ttypes.ncJobLog.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype208, _size205) = iprot.readListBegin()
          for _i209 in xrange(_size205):
            _elem210 = ncAmsJob.ttypes.ncJobLog()
            _elem210.read(iprot)
            self.success.append(_elem210)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_backup_jobs_historys_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter211 in self.success:
        iter211.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_backup_jobs_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_backup_jobs_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_backup_jobs_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncAmsJobType, ncAmsJob.ttypes.ncAmsJobType.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype215, _size212) = iprot.readListBegin()
          for _i216 in xrange(_size212):
            _elem217 = ncAmsJob.ttypes.ncAmsJobType()
            _elem217.read(iprot)
            self.success.append(_elem217)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_backup_jobs_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter218 in self.success:
        iter218.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_job_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_job_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_job_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncAmsJobType, ncAmsJob.ttypes.ncAmsJobType.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype222, _size219) = iprot.readListBegin()
          for _i223 in xrange(_size219):
            _elem224 = ncAmsJob.ttypes.ncAmsJobType()
            _elem224.read(iprot)
            self.success.append(_elem224)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_job_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter225 in self.success:
        iter225.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_jobInstance_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_jobInstance_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_mount_jobInstance_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncJobLog, ncAmsJob.ttypes.ncJobLog.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype229, _size226) = iprot.readListBegin()
          for _i230 in xrange(_size226):
            _elem231 = ncAmsJob.ttypes.ncJobLog()
            _elem231.read(iprot)
            self.success.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_mount_jobInstance_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter232 in self.success:
        iter232.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_args(object):
  """
  Attributes:
   - kwargs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'kwargs', None, None, ), # 1
  )

  def __init__(self, kwargs=None,):
    self.kwargs = kwargs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.kwargs = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_args')
    if self.kwargs is not None:
      oprot.writeFieldBegin('kwargs', TType.STRING, 1)
      oprot.writeString(self.kwargs.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.kwargs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class do_operation_from_ams_args(object):
  """
  Attributes:
   - target
   - method
   - kwargs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'target', None, None, ), # 1
    (2, TType.STRING, 'method', None, None, ), # 2
    (3, TType.STRING, 'kwargs', None, None, ), # 3
  )

  def __init__(self, target=None, method=None, kwargs=None,):
    self.target = target
    self.method = method
    self.kwargs = kwargs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.target = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.method = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.kwargs = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('do_operation_from_ams_args')
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRING, 1)
      oprot.writeString(self.target.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.method is not None:
      oprot.writeFieldBegin('method', TType.STRING, 2)
      oprot.writeString(self.method.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.kwargs is not None:
      oprot.writeFieldBegin('kwargs', TType.STRING, 3)
      oprot.writeString(self.kwargs.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.target)
    value = (value * 31) ^ hash(self.method)
    value = (value * 31) ^ hash(self.kwargs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class do_operation_from_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('do_operation_from_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_running_job_on_client_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_running_job_on_client_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_running_job_on_client_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_running_job_on_client_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_time_points_by_backup_job_id_args(object):
  """
  Attributes:
   - backup_job_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'backup_job_id', None, None, ), # 1
  )

  def __init__(self, backup_job_id=None,):
    self.backup_job_id = backup_job_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.backup_job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_time_points_by_backup_job_id_args')
    if self.backup_job_id is not None:
      oprot.writeFieldBegin('backup_job_id', TType.STRING, 1)
      oprot.writeString(self.backup_job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.backup_job_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_time_points_by_backup_job_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_time_points_by_backup_job_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_base_volumes_by_backup_job_id_args(object):
  """
  Attributes:
   - backup_job_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'backup_job_id', None, None, ), # 1
  )

  def __init__(self, backup_job_id=None,):
    self.backup_job_id = backup_job_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.backup_job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_base_volumes_by_backup_job_id_args')
    if self.backup_job_id is not None:
      oprot.writeFieldBegin('backup_job_id', TType.STRING, 1)
      oprot.writeString(self.backup_job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.backup_job_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_base_volumes_by_backup_job_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_base_volumes_by_backup_job_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_origin_job_by_id_args(object):
  """
  Attributes:
   - originJobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'originJobId', None, None, ), # 1
  )

  def __init__(self, originJobId=None,):
    self.originJobId = originJobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.originJobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_origin_job_by_id_args')
    if self.originJobId is not None:
      oprot.writeFieldBegin('originJobId', TType.STRING, 1)
      oprot.writeString(self.originJobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.originJobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_origin_job_by_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncCanSyncJobResponseData, ncCdmDispatchProto.ttypes.ncCanSyncJobResponseData.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncCanSyncJobResponseData()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_origin_job_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_time_points_by_origin_job_id_args(object):
  """
  Attributes:
   - TimePointReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'TimePointReq', (ncCdmDispatchProto.ttypes.ncTimePointsRequest, ncCdmDispatchProto.ttypes.ncTimePointsRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, TimePointReq=None,):
    self.TimePointReq = TimePointReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.TimePointReq = ncCdmDispatchProto.ttypes.ncTimePointsRequest()
          self.TimePointReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_time_points_by_origin_job_id_args')
    if self.TimePointReq is not None:
      oprot.writeFieldBegin('TimePointReq', TType.STRUCT, 1)
      self.TimePointReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.TimePointReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_time_points_by_origin_job_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncTimePointsResponse, ncCdmDispatchProto.ttypes.ncTimePointsResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncTimePointsResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_time_points_by_origin_job_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_job_args(object):
  """
  Attributes:
   - createSyncJobReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'createSyncJobReq', (ncCdmDispatchProto.ttypes.ncCreateSyncJobRequest, ncCdmDispatchProto.ttypes.ncCreateSyncJobRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, createSyncJobReq=None,):
    self.createSyncJobReq = createSyncJobReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.createSyncJobReq = ncCdmDispatchProto.ttypes.ncCreateSyncJobRequest()
          self.createSyncJobReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_job_args')
    if self.createSyncJobReq is not None:
      oprot.writeFieldBegin('createSyncJobReq', TType.STRUCT, 1)
      self.createSyncJobReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.createSyncJobReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_job_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_job_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_can_sync_jobs_args(object):
  """
  Attributes:
   - canSyncJobReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'canSyncJobReq', (ncCdmDispatchProto.ttypes.ncCanSyncJobRequest, ncCdmDispatchProto.ttypes.ncCanSyncJobRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, canSyncJobReq=None,):
    self.canSyncJobReq = canSyncJobReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.canSyncJobReq = ncCdmDispatchProto.ttypes.ncCanSyncJobRequest()
          self.canSyncJobReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_can_sync_jobs_args')
    if self.canSyncJobReq is not None:
      oprot.writeFieldBegin('canSyncJobReq', TType.STRUCT, 1)
      self.canSyncJobReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.canSyncJobReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_can_sync_jobs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncCanSyncJobResponse, ncCdmDispatchProto.ttypes.ncCanSyncJobResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncCanSyncJobResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_can_sync_jobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_time_point_args(object):
  """
  Attributes:
   - createSyncTimePointReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'createSyncTimePointReq', (ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest, ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, createSyncTimePointReq=None,):
    self.createSyncTimePointReq = createSyncTimePointReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.createSyncTimePointReq = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest()
          self.createSyncTimePointReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_time_point_args')
    if self.createSyncTimePointReq is not None:
      oprot.writeFieldBegin('createSyncTimePointReq', TType.STRUCT, 1)
      self.createSyncTimePointReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.createSyncTimePointReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_time_point_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_time_point_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_origin_job_by_id_args(object):
  """
  Attributes:
   - originJobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'originJobId', None, None, ), # 1
  )

  def __init__(self, originJobId=None,):
    self.originJobId = originJobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.originJobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_origin_job_by_id_args')
    if self.originJobId is not None:
      oprot.writeFieldBegin('originJobId', TType.STRING, 1)
      oprot.writeString(self.originJobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.originJobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_origin_job_by_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_origin_job_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_time_point_on_sync_start_args(object):
  """
  Attributes:
   - createSyncTimePointReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'createSyncTimePointReq', (ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest, ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, createSyncTimePointReq=None,):
    self.createSyncTimePointReq = createSyncTimePointReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.createSyncTimePointReq = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointRequest()
          self.createSyncTimePointReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_time_point_on_sync_start_args')
    if self.createSyncTimePointReq is not None:
      oprot.writeFieldBegin('createSyncTimePointReq', TType.STRUCT, 1)
      self.createSyncTimePointReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.createSyncTimePointReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_sync_time_point_on_sync_start_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncCreateSyncTimePointResponse, ncCdmDispatchProto.ttypes.ncCreateSyncTimePointResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncCreateSyncTimePointResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_sync_time_point_on_sync_start_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_sync_time_point_on_sync_finish_args(object):
  """
  Attributes:
   - updateSyncTimePointReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'updateSyncTimePointReq', (ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointRequest, ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, updateSyncTimePointReq=None,):
    self.updateSyncTimePointReq = updateSyncTimePointReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.updateSyncTimePointReq = ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointRequest()
          self.updateSyncTimePointReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_sync_time_point_on_sync_finish_args')
    if self.updateSyncTimePointReq is not None:
      oprot.writeFieldBegin('updateSyncTimePointReq', TType.STRUCT, 1)
      self.updateSyncTimePointReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateSyncTimePointReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_sync_time_point_on_sync_finish_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_sync_time_point_on_sync_finish_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_sync_time_point_base_map_snap_args(object):
  """
  Attributes:
   - updateSyncTimePointVolumeReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'updateSyncTimePointVolumeReq', (ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointVolumeRequest, ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointVolumeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, updateSyncTimePointVolumeReq=None,):
    self.updateSyncTimePointVolumeReq = updateSyncTimePointVolumeReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.updateSyncTimePointVolumeReq = ncCdmDispatchProto.ttypes.ncUpdateSyncTimePointVolumeRequest()
          self.updateSyncTimePointVolumeReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_sync_time_point_base_map_snap_args')
    if self.updateSyncTimePointVolumeReq is not None:
      oprot.writeFieldBegin('updateSyncTimePointVolumeReq', TType.STRUCT, 1)
      self.updateSyncTimePointVolumeReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.updateSyncTimePointVolumeReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_sync_time_point_base_map_snap_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_sync_time_point_base_map_snap_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_sync_time_point_by_id_args(object):
  """
  Attributes:
   - deleteSyncTimePointIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'deleteSyncTimePointIds', (ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointRequest, ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, deleteSyncTimePointIds=None,):
    self.deleteSyncTimePointIds = deleteSyncTimePointIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.deleteSyncTimePointIds = ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointRequest()
          self.deleteSyncTimePointIds.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_sync_time_point_by_id_args')
    if self.deleteSyncTimePointIds is not None:
      oprot.writeFieldBegin('deleteSyncTimePointIds', TType.STRUCT, 1)
      self.deleteSyncTimePointIds.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.deleteSyncTimePointIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_sync_time_point_by_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointResponse, ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncDeleteSyncTimePointResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_sync_time_point_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_job_status_origin_job_by_id_args(object):
  """
  Attributes:
   - UpdateJobStatusReq
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'UpdateJobStatusReq', (ncCdmDispatchProto.ttypes.ncUpdateJobStatusRequest, ncCdmDispatchProto.ttypes.ncUpdateJobStatusRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, UpdateJobStatusReq=None,):
    self.UpdateJobStatusReq = UpdateJobStatusReq

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.UpdateJobStatusReq = ncCdmDispatchProto.ttypes.ncUpdateJobStatusRequest()
          self.UpdateJobStatusReq.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_job_status_origin_job_by_id_args')
    if self.UpdateJobStatusReq is not None:
      oprot.writeFieldBegin('UpdateJobStatusReq', TType.STRUCT, 1)
      self.UpdateJobStatusReq.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.UpdateJobStatusReq)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_job_status_origin_job_by_id_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_job_status_origin_job_by_id_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_time_point_is_exist_args(object):
  """
  Attributes:
   - timePointId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'timePointId', None, None, ), # 1
  )

  def __init__(self, timePointId=None,):
    self.timePointId = timePointId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.timePointId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_time_point_is_exist_args')
    if self.timePointId is not None:
      oprot.writeFieldBegin('timePointId', TType.STRING, 1)
      oprot.writeString(self.timePointId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timePointId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_time_point_is_exist_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_time_point_is_exist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dict_export_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype234, _vtype235, _size233 ) = iprot.readMapBegin()
          for _i237 in xrange(_size233):
            _key238 = iprot.readString().decode('utf-8')
            _val239 = iprot.readString().decode('utf-8')
            self.body[_key238] = _val239
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dict_export_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter240,viter241 in self.body.items():
        oprot.writeString(kiter240.encode('utf-8'))
        oprot.writeString(viter241.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dict_export_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype243, _vtype244, _size242 ) = iprot.readMapBegin()
          for _i246 in xrange(_size242):
            _key247 = iprot.readString().decode('utf-8')
            _val248 = iprot.readString().decode('utf-8')
            self.success[_key247] = _val248
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dict_export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter249,viter250 in self.success.items():
        oprot.writeString(kiter249.encode('utf-8'))
        oprot.writeString(viter250.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mount_get_dict_export_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype252, _vtype253, _size251 ) = iprot.readMapBegin()
          for _i255 in xrange(_size251):
            _key256 = iprot.readString().decode('utf-8')
            _val257 = iprot.readString().decode('utf-8')
            self.body[_key256] = _val257
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mount_get_dict_export_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter258,viter259 in self.body.items():
        oprot.writeString(kiter258.encode('utf-8'))
        oprot.writeString(viter259.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mount_get_dict_export_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype261, _vtype262, _size260 ) = iprot.readMapBegin()
          for _i264 in xrange(_size260):
            _key265 = iprot.readString().decode('utf-8')
            _val266 = iprot.readString().decode('utf-8')
            self.success[_key265] = _val266
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mount_get_dict_export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter267,viter268 in self.success.items():
        oprot.writeString(kiter267.encode('utf-8'))
        oprot.writeString(viter268.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class backup_get_dict_export_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype270, _vtype271, _size269 ) = iprot.readMapBegin()
          for _i273 in xrange(_size269):
            _key274 = iprot.readString().decode('utf-8')
            _val275 = iprot.readString().decode('utf-8')
            self.body[_key274] = _val275
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('backup_get_dict_export_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter276,viter277 in self.body.items():
        oprot.writeString(kiter276.encode('utf-8'))
        oprot.writeString(viter277.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class backup_get_dict_export_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype279, _vtype280, _size278 ) = iprot.readMapBegin()
          for _i282 in xrange(_size278):
            _key283 = iprot.readString().decode('utf-8')
            _val284 = iprot.readString().decode('utf-8')
            self.success[_key283] = _val284
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('backup_get_dict_export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter285,viter286 in self.success.items():
        oprot.writeString(kiter285.encode('utf-8'))
        oprot.writeString(viter286.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_sourceId_args(object):
  """
  Attributes:
   - sourceType
   - svcType
   - sourceId
   - relation
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sourceType', None, None, ), # 1
    (2, TType.I32, 'svcType', None, None, ), # 2
    (3, TType.STRING, 'sourceId', None, None, ), # 3
    (4, TType.I32, 'relation', None,     1, ), # 4
  )

  def __init__(self, sourceType=None, svcType=None, sourceId=None, relation=thrift_spec[4][4],):
    self.sourceType = sourceType
    self.svcType = svcType
    self.sourceId = sourceId
    self.relation = relation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.svcType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sourceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.relation = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_sourceId_args')
    if self.sourceType is not None:
      oprot.writeFieldBegin('sourceType', TType.I32, 1)
      oprot.writeI32(self.sourceType)
      oprot.writeFieldEnd()
    if self.svcType is not None:
      oprot.writeFieldBegin('svcType', TType.I32, 2)
      oprot.writeI32(self.svcType)
      oprot.writeFieldEnd()
    if self.sourceId is not None:
      oprot.writeFieldBegin('sourceId', TType.STRING, 3)
      oprot.writeString(self.sourceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.relation is not None:
      oprot.writeFieldBegin('relation', TType.I32, 4)
      oprot.writeI32(self.relation)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sourceType)
    value = (value * 31) ^ hash(self.svcType)
    value = (value * 31) ^ hash(self.sourceId)
    value = (value * 31) ^ hash(self.relation)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_sourceId_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype290, _size287) = iprot.readListBegin()
          for _i291 in xrange(_size287):
            _elem292 = ncJob.ttypes.ncTJob()
            _elem292.read(iprot)
            self.success.append(_elem292)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_sourceId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter293 in self.success:
        iter293.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_datasource_args(object):
  """
  Attributes:
   - datasource
   - clientId
   - dbRunUserName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'datasource', None, None, ), # 1
    (2, TType.STRING, 'clientId', None, None, ), # 2
    (3, TType.STRING, 'dbRunUserName', None, None, ), # 3
  )

  def __init__(self, datasource=None, clientId=None, dbRunUserName=None,):
    self.datasource = datasource
    self.clientId = clientId
    self.dbRunUserName = dbRunUserName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.datasource = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbRunUserName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_datasource_args')
    if self.datasource is not None:
      oprot.writeFieldBegin('datasource', TType.STRING, 1)
      oprot.writeString(self.datasource.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 2)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.dbRunUserName is not None:
      oprot.writeFieldBegin('dbRunUserName', TType.STRING, 3)
      oprot.writeString(self.dbRunUserName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.datasource)
    value = (value * 31) ^ hash(self.clientId)
    value = (value * 31) ^ hash(self.dbRunUserName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_datasource_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncBackupJob, ncJob.ttypes.ncBackupJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype297, _size294) = iprot.readListBegin()
          for _i298 in xrange(_size294):
            _elem299 = ncJob.ttypes.ncBackupJob()
            _elem299.read(iprot)
            self.success.append(_elem299)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_datasource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter300 in self.success:
        iter300.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sync_job_origin_job_by_id_args(object):
  """
  Attributes:
   - originJobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'originJobId', None, None, ), # 1
  )

  def __init__(self, originJobId=None,):
    self.originJobId = originJobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.originJobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sync_job_origin_job_by_id_args')
    if self.originJobId is not None:
      oprot.writeFieldBegin('originJobId', TType.STRING, 1)
      oprot.writeString(self.originJobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.originJobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sync_job_origin_job_by_id_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncJobInfo, ncCdmDispatchProto.ttypes.ncJobInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncJobInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sync_job_origin_job_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_user_has_data_args(object):
  """
  Attributes:
   - user_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'user_list', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_list=None,):
    self.user_list = user_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.user_list = []
          (_etype304, _size301) = iprot.readListBegin()
          for _i305 in xrange(_size301):
            _elem306 = iprot.readString().decode('utf-8')
            self.user_list.append(_elem306)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_user_has_data_args')
    if self.user_list is not None:
      oprot.writeFieldBegin('user_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.user_list))
      for iter307 in self.user_list:
        oprot.writeString(iter307.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_user_has_data_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype311, _size308) = iprot.readListBegin()
          for _i312 in xrange(_size308):
            _elem313 = iprot.readString().decode('utf-8')
            self.success.append(_elem313)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_user_has_data_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter314 in self.success:
        oprot.writeString(iter314.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_clean_job_time_points_args(object):
  """
  Attributes:
   - job_id
   - clean_type
   - time_points
   - user
   - clean_job_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_id', None, None, ), # 1
    (2, TType.STRING, 'clean_type', None, None, ), # 2
    (3, TType.LIST, 'time_points', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'user', (ncUser.ttypes.ncUserInfo, ncUser.ttypes.ncUserInfo.thrift_spec), None, ), # 4
    (5, TType.STRING, 'clean_job_id', None, None, ), # 5
  )

  def __init__(self, job_id=None, clean_type=None, time_points=None, user=None, clean_job_id=None,):
    self.job_id = job_id
    self.clean_type = clean_type
    self.time_points = time_points
    self.user = user
    self.clean_job_id = clean_job_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clean_type = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.time_points = []
          (_etype318, _size315) = iprot.readListBegin()
          for _i319 in xrange(_size315):
            _elem320 = iprot.readString().decode('utf-8')
            self.time_points.append(_elem320)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.user = ncUser.ttypes.ncUserInfo()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clean_job_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_clean_job_time_points_args')
    if self.job_id is not None:
      oprot.writeFieldBegin('job_id', TType.STRING, 1)
      oprot.writeString(self.job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.clean_type is not None:
      oprot.writeFieldBegin('clean_type', TType.STRING, 2)
      oprot.writeString(self.clean_type.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.time_points is not None:
      oprot.writeFieldBegin('time_points', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.time_points))
      for iter321 in self.time_points:
        oprot.writeString(iter321.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 4)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.clean_job_id is not None:
      oprot.writeFieldBegin('clean_job_id', TType.STRING, 5)
      oprot.writeString(self.clean_job_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_id)
    value = (value * 31) ^ hash(self.clean_type)
    value = (value * 31) ^ hash(self.time_points)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.clean_job_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_clean_job_time_points_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_clean_job_time_points_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_job_count_info_args(object):
  """
  Attributes:
   - startTime
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'startTime', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
  )

  def __init__(self, startTime=None, userId=None,):
    self.startTime = startTime
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.startTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_job_count_info_args')
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 1)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startTime)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_job_count_info_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmDispatchProto.ttypes.ncJobCountInfo, ncCdmDispatchProto.ttypes.ncJobCountInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmDispatchProto.ttypes.ncJobCountInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_job_count_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class run_backup_job_handler_args(object):
  """
  Attributes:
   - job_instance_id
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_instance_id', None, None, ), # 1
    (2, TType.STRING, 'user_id', None, None, ), # 2
  )

  def __init__(self, job_instance_id=None, user_id=None,):
    self.job_instance_id = job_instance_id
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_instance_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('run_backup_job_handler_args')
    if self.job_instance_id is not None:
      oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
      oprot.writeString(self.job_instance_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 2)
      oprot.writeString(self.user_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_instance_id)
    value = (value * 31) ^ hash(self.user_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class run_backup_job_handler_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('run_backup_job_handler_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class run_mount_job_handler_args(object):
  """
  Attributes:
   - job_instance_id
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_instance_id', None, None, ), # 1
    (2, TType.STRING, 'user_id', None, None, ), # 2
  )

  def __init__(self, job_instance_id=None, user_id=None,):
    self.job_instance_id = job_instance_id
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_instance_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('run_mount_job_handler_args')
    if self.job_instance_id is not None:
      oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
      oprot.writeString(self.job_instance_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 2)
      oprot.writeString(self.user_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_instance_id)
    value = (value * 31) ^ hash(self.user_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class run_mount_job_handler_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('run_mount_job_handler_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_mount_handler_args(object):
  """
  Attributes:
   - job_instance_id
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_instance_id', None, None, ), # 1
    (2, TType.STRING, 'user_id', None, None, ), # 2
  )

  def __init__(self, job_instance_id=None, user_id=None,):
    self.job_instance_id = job_instance_id
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_instance_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_mount_handler_args')
    if self.job_instance_id is not None:
      oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
      oprot.writeString(self.job_instance_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 2)
      oprot.writeString(self.user_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_instance_id)
    value = (value * 31) ^ hash(self.user_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_mount_handler_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_mount_handler_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_unmount_handler_args(object):
  """
  Attributes:
   - job_instance_id
   - user_id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'job_instance_id', None, None, ), # 1
    (2, TType.STRING, 'user_id', None, None, ), # 2
  )

  def __init__(self, job_instance_id=None, user_id=None,):
    self.job_instance_id = job_instance_id
    self.user_id = user_id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.job_instance_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_unmount_handler_args')
    if self.job_instance_id is not None:
      oprot.writeFieldBegin('job_instance_id', TType.STRING, 1)
      oprot.writeString(self.job_instance_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.user_id is not None:
      oprot.writeFieldBegin('user_id', TType.STRING, 2)
      oprot.writeString(self.user_id.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.job_instance_id)
    value = (value * 31) ^ hash(self.user_id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class image_unmount_handler_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('image_unmount_handler_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
