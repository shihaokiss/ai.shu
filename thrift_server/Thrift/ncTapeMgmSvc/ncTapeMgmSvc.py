#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  ESS服务接口
  """
  def CreateTapeSet(self, tapeLibSerialNo, tapeSetName, driveNum, tapes, cycle):
    """
    创建介质集

    @param name 待创建的介质集的名字
    @param driveNum 该介质集可以使用的最大驱动器数目
    @param tapes 分配给该介质集的磁带列表
    @param cycle 该介质集覆盖周期

    @throw ncException 创建失败或者参数不正确时抛异常


    Parameters:
     - tapeLibSerialNo
     - tapeSetName
     - driveNum
     - tapes
     - cycle
    """
    pass

  def DeleteTapeSet(self, tapeSetName, recursive):
    """
    删除介质集，要求该介质集中无磁带

    @param tapeset 待删除的介质集的名字
    @param recursive 是否循环移除该介质集中的磁带, 目前不支持此参数

    @throw ncException 删除失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - recursive
    """
    pass

  def UpdateTapeSet(self, tapeSetName, driveNum, tapes, cycle):
    """
    更新该介质集的信息

    @param tapeSetName 待创建的介质集的名字
    @param driveNum 该介质集可以使用的最大驱动器数目
    @param tapes 分配给该介质集的新的磁带列表
    @param cycle 该介质集新的覆盖周期

    @throw ncException 修改失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - driveNum
     - tapes
     - cycle
    """
    pass

  def ListTapeSet(self, offset, limit, cond):
    """
    获取指定磁带库上所有的介质集信息
    不包括磁带列表，因为磁带列表可能会有很多，数据太大，会出现超时的情况

    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond  过滤条件，支持：name。其定义请参见TapeQueryCond的定义说明。

    @return 获取到的介质集信息

    @throw ncException 获取失败或者参数不正确时抛异常


    Parameters:
     - offset
     - limit
     - cond
    """
    pass

  def ListTapeSetTape(self, tapeSetName, offset, limit, cond):
    """
    获取指定介质集中的磁带信息

    @param tapeset 待查询的介质集的名字
    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond 占位，暂时不支持

    @return 获取到的磁带信息

    @throw ncException 获取失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - offset
     - limit
     - cond
    """
    pass

  def ListTapeLibrary(self, offset, limit, cond):
    """
    查询集群中所有的磁带库概要信息

    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond  过滤条件，支持：name、online。其定义请参见TapeQueryCond的定义说明。

    @return 查询到的磁带库概要信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - offset
     - limit
     - cond
    """
    pass

  def ListTapeLibTape(self, tapeLibSerialNo, offset, limit, cond):
    """
    查询磁带库中磁带信息

    @param tapeLib 磁带库序列号
    @param offset 查询的起始偏移量
    @param limit 一次查询的数量
    @param cond 过滤条件，支持：setName、hasData。其定义请参见TapeQueryCond的定义说明。

    @return 查询到的磁带插槽信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeLibSerialNo
     - offset
     - limit
     - cond
    """
    pass

  def ListTapeDrive(self, tapeLibSerialNo, offset, limit):
    """
    查询指定的磁带库中驱动器信息

    @param tapeLib 磁带库序列号
    @param offset 查询的起始偏移量
    @param limit 一次查询的数量

    @return 查询到的驱动器信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeLibSerialNo
     - offset
     - limit
    """
    pass

  def ScanTapeLib(self):
    """
    扫描磁带库

    @return 磁带库当前的扫描状态

    @throw ncException 扫描失败时抛异常

    """
    pass

  def GetTapeScanStatus(self):
    """
    获取磁带库扫描结果

    @return 磁带库当前的扫描状态

    @throw ncException 扫描失败时抛异常

    """
    pass

  def IsTapeSetNotExisted(self, tapeSetName):
    """
    判断介质集是否存在，创建介质集时候使用
    @param tapeSetName 介质集名称
    @return 介质集是否存在(True,False)
    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeSetName
    """
    pass


class Client(Iface):
  """
  ESS服务接口
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def CreateTapeSet(self, tapeLibSerialNo, tapeSetName, driveNum, tapes, cycle):
    """
    创建介质集

    @param name 待创建的介质集的名字
    @param driveNum 该介质集可以使用的最大驱动器数目
    @param tapes 分配给该介质集的磁带列表
    @param cycle 该介质集覆盖周期

    @throw ncException 创建失败或者参数不正确时抛异常


    Parameters:
     - tapeLibSerialNo
     - tapeSetName
     - driveNum
     - tapes
     - cycle
    """
    self.send_CreateTapeSet(tapeLibSerialNo, tapeSetName, driveNum, tapes, cycle)
    self.recv_CreateTapeSet()

  def send_CreateTapeSet(self, tapeLibSerialNo, tapeSetName, driveNum, tapes, cycle):
    self._oprot.writeMessageBegin('CreateTapeSet', TMessageType.CALL, self._seqid)
    args = CreateTapeSet_args()
    args.tapeLibSerialNo = tapeLibSerialNo
    args.tapeSetName = tapeSetName
    args.driveNum = driveNum
    args.tapes = tapes
    args.cycle = cycle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateTapeSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CreateTapeSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def DeleteTapeSet(self, tapeSetName, recursive):
    """
    删除介质集，要求该介质集中无磁带

    @param tapeset 待删除的介质集的名字
    @param recursive 是否循环移除该介质集中的磁带, 目前不支持此参数

    @throw ncException 删除失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - recursive
    """
    self.send_DeleteTapeSet(tapeSetName, recursive)
    self.recv_DeleteTapeSet()

  def send_DeleteTapeSet(self, tapeSetName, recursive):
    self._oprot.writeMessageBegin('DeleteTapeSet', TMessageType.CALL, self._seqid)
    args = DeleteTapeSet_args()
    args.tapeSetName = tapeSetName
    args.recursive = recursive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DeleteTapeSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = DeleteTapeSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def UpdateTapeSet(self, tapeSetName, driveNum, tapes, cycle):
    """
    更新该介质集的信息

    @param tapeSetName 待创建的介质集的名字
    @param driveNum 该介质集可以使用的最大驱动器数目
    @param tapes 分配给该介质集的新的磁带列表
    @param cycle 该介质集新的覆盖周期

    @throw ncException 修改失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - driveNum
     - tapes
     - cycle
    """
    self.send_UpdateTapeSet(tapeSetName, driveNum, tapes, cycle)
    self.recv_UpdateTapeSet()

  def send_UpdateTapeSet(self, tapeSetName, driveNum, tapes, cycle):
    self._oprot.writeMessageBegin('UpdateTapeSet', TMessageType.CALL, self._seqid)
    args = UpdateTapeSet_args()
    args.tapeSetName = tapeSetName
    args.driveNum = driveNum
    args.tapes = tapes
    args.cycle = cycle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_UpdateTapeSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = UpdateTapeSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def ListTapeSet(self, offset, limit, cond):
    """
    获取指定磁带库上所有的介质集信息
    不包括磁带列表，因为磁带列表可能会有很多，数据太大，会出现超时的情况

    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond  过滤条件，支持：name。其定义请参见TapeQueryCond的定义说明。

    @return 获取到的介质集信息

    @throw ncException 获取失败或者参数不正确时抛异常


    Parameters:
     - offset
     - limit
     - cond
    """
    self.send_ListTapeSet(offset, limit, cond)
    return self.recv_ListTapeSet()

  def send_ListTapeSet(self, offset, limit, cond):
    self._oprot.writeMessageBegin('ListTapeSet', TMessageType.CALL, self._seqid)
    args = ListTapeSet_args()
    args.offset = offset
    args.limit = limit
    args.cond = cond
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ListTapeSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ListTapeSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ListTapeSet failed: unknown result")

  def ListTapeSetTape(self, tapeSetName, offset, limit, cond):
    """
    获取指定介质集中的磁带信息

    @param tapeset 待查询的介质集的名字
    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond 占位，暂时不支持

    @return 获取到的磁带信息

    @throw ncException 获取失败或者参数不正确时抛异常


    Parameters:
     - tapeSetName
     - offset
     - limit
     - cond
    """
    self.send_ListTapeSetTape(tapeSetName, offset, limit, cond)
    return self.recv_ListTapeSetTape()

  def send_ListTapeSetTape(self, tapeSetName, offset, limit, cond):
    self._oprot.writeMessageBegin('ListTapeSetTape', TMessageType.CALL, self._seqid)
    args = ListTapeSetTape_args()
    args.tapeSetName = tapeSetName
    args.offset = offset
    args.limit = limit
    args.cond = cond
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ListTapeSetTape(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ListTapeSetTape_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ListTapeSetTape failed: unknown result")

  def ListTapeLibrary(self, offset, limit, cond):
    """
    查询集群中所有的磁带库概要信息

    @param offset 查询的起始位置
    @param limit 一次返回的最大数目
    @param cond  过滤条件，支持：name、online。其定义请参见TapeQueryCond的定义说明。

    @return 查询到的磁带库概要信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - offset
     - limit
     - cond
    """
    self.send_ListTapeLibrary(offset, limit, cond)
    return self.recv_ListTapeLibrary()

  def send_ListTapeLibrary(self, offset, limit, cond):
    self._oprot.writeMessageBegin('ListTapeLibrary', TMessageType.CALL, self._seqid)
    args = ListTapeLibrary_args()
    args.offset = offset
    args.limit = limit
    args.cond = cond
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ListTapeLibrary(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ListTapeLibrary_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ListTapeLibrary failed: unknown result")

  def ListTapeLibTape(self, tapeLibSerialNo, offset, limit, cond):
    """
    查询磁带库中磁带信息

    @param tapeLib 磁带库序列号
    @param offset 查询的起始偏移量
    @param limit 一次查询的数量
    @param cond 过滤条件，支持：setName、hasData。其定义请参见TapeQueryCond的定义说明。

    @return 查询到的磁带插槽信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeLibSerialNo
     - offset
     - limit
     - cond
    """
    self.send_ListTapeLibTape(tapeLibSerialNo, offset, limit, cond)
    return self.recv_ListTapeLibTape()

  def send_ListTapeLibTape(self, tapeLibSerialNo, offset, limit, cond):
    self._oprot.writeMessageBegin('ListTapeLibTape', TMessageType.CALL, self._seqid)
    args = ListTapeLibTape_args()
    args.tapeLibSerialNo = tapeLibSerialNo
    args.offset = offset
    args.limit = limit
    args.cond = cond
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ListTapeLibTape(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ListTapeLibTape_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ListTapeLibTape failed: unknown result")

  def ListTapeDrive(self, tapeLibSerialNo, offset, limit):
    """
    查询指定的磁带库中驱动器信息

    @param tapeLib 磁带库序列号
    @param offset 查询的起始偏移量
    @param limit 一次查询的数量

    @return 查询到的驱动器信息

    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeLibSerialNo
     - offset
     - limit
    """
    self.send_ListTapeDrive(tapeLibSerialNo, offset, limit)
    return self.recv_ListTapeDrive()

  def send_ListTapeDrive(self, tapeLibSerialNo, offset, limit):
    self._oprot.writeMessageBegin('ListTapeDrive', TMessageType.CALL, self._seqid)
    args = ListTapeDrive_args()
    args.tapeLibSerialNo = tapeLibSerialNo
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ListTapeDrive(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ListTapeDrive_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ListTapeDrive failed: unknown result")

  def ScanTapeLib(self):
    """
    扫描磁带库

    @return 磁带库当前的扫描状态

    @throw ncException 扫描失败时抛异常

    """
    self.send_ScanTapeLib()
    return self.recv_ScanTapeLib()

  def send_ScanTapeLib(self):
    self._oprot.writeMessageBegin('ScanTapeLib', TMessageType.CALL, self._seqid)
    args = ScanTapeLib_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ScanTapeLib(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ScanTapeLib_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ScanTapeLib failed: unknown result")

  def GetTapeScanStatus(self):
    """
    获取磁带库扫描结果

    @return 磁带库当前的扫描状态

    @throw ncException 扫描失败时抛异常

    """
    self.send_GetTapeScanStatus()
    return self.recv_GetTapeScanStatus()

  def send_GetTapeScanStatus(self):
    self._oprot.writeMessageBegin('GetTapeScanStatus', TMessageType.CALL, self._seqid)
    args = GetTapeScanStatus_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetTapeScanStatus(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetTapeScanStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetTapeScanStatus failed: unknown result")

  def IsTapeSetNotExisted(self, tapeSetName):
    """
    判断介质集是否存在，创建介质集时候使用
    @param tapeSetName 介质集名称
    @return 介质集是否存在(True,False)
    @throw ncException 查询失败时抛异常


    Parameters:
     - tapeSetName
    """
    self.send_IsTapeSetNotExisted(tapeSetName)
    return self.recv_IsTapeSetNotExisted()

  def send_IsTapeSetNotExisted(self, tapeSetName):
    self._oprot.writeMessageBegin('IsTapeSetNotExisted', TMessageType.CALL, self._seqid)
    args = IsTapeSetNotExisted_args()
    args.tapeSetName = tapeSetName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_IsTapeSetNotExisted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = IsTapeSetNotExisted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "IsTapeSetNotExisted failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["CreateTapeSet"] = Processor.process_CreateTapeSet
    self._processMap["DeleteTapeSet"] = Processor.process_DeleteTapeSet
    self._processMap["UpdateTapeSet"] = Processor.process_UpdateTapeSet
    self._processMap["ListTapeSet"] = Processor.process_ListTapeSet
    self._processMap["ListTapeSetTape"] = Processor.process_ListTapeSetTape
    self._processMap["ListTapeLibrary"] = Processor.process_ListTapeLibrary
    self._processMap["ListTapeLibTape"] = Processor.process_ListTapeLibTape
    self._processMap["ListTapeDrive"] = Processor.process_ListTapeDrive
    self._processMap["ScanTapeLib"] = Processor.process_ScanTapeLib
    self._processMap["GetTapeScanStatus"] = Processor.process_GetTapeScanStatus
    self._processMap["IsTapeSetNotExisted"] = Processor.process_IsTapeSetNotExisted

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_CreateTapeSet(self, seqid, iprot, oprot):
    args = CreateTapeSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateTapeSet_result()
    try:
      self._handler.CreateTapeSet(args.tapeLibSerialNo, args.tapeSetName, args.driveNum, args.tapes, args.cycle)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CreateTapeSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DeleteTapeSet(self, seqid, iprot, oprot):
    args = DeleteTapeSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DeleteTapeSet_result()
    try:
      self._handler.DeleteTapeSet(args.tapeSetName, args.recursive)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("DeleteTapeSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_UpdateTapeSet(self, seqid, iprot, oprot):
    args = UpdateTapeSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = UpdateTapeSet_result()
    try:
      self._handler.UpdateTapeSet(args.tapeSetName, args.driveNum, args.tapes, args.cycle)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("UpdateTapeSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ListTapeSet(self, seqid, iprot, oprot):
    args = ListTapeSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ListTapeSet_result()
    try:
      result.success = self._handler.ListTapeSet(args.offset, args.limit, args.cond)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ListTapeSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ListTapeSetTape(self, seqid, iprot, oprot):
    args = ListTapeSetTape_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ListTapeSetTape_result()
    try:
      result.success = self._handler.ListTapeSetTape(args.tapeSetName, args.offset, args.limit, args.cond)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ListTapeSetTape", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ListTapeLibrary(self, seqid, iprot, oprot):
    args = ListTapeLibrary_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ListTapeLibrary_result()
    try:
      result.success = self._handler.ListTapeLibrary(args.offset, args.limit, args.cond)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ListTapeLibrary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ListTapeLibTape(self, seqid, iprot, oprot):
    args = ListTapeLibTape_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ListTapeLibTape_result()
    try:
      result.success = self._handler.ListTapeLibTape(args.tapeLibSerialNo, args.offset, args.limit, args.cond)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ListTapeLibTape", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ListTapeDrive(self, seqid, iprot, oprot):
    args = ListTapeDrive_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ListTapeDrive_result()
    try:
      result.success = self._handler.ListTapeDrive(args.tapeLibSerialNo, args.offset, args.limit)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ListTapeDrive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ScanTapeLib(self, seqid, iprot, oprot):
    args = ScanTapeLib_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ScanTapeLib_result()
    try:
      result.success = self._handler.ScanTapeLib()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ScanTapeLib", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetTapeScanStatus(self, seqid, iprot, oprot):
    args = GetTapeScanStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetTapeScanStatus_result()
    try:
      result.success = self._handler.GetTapeScanStatus()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("GetTapeScanStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_IsTapeSetNotExisted(self, seqid, iprot, oprot):
    args = IsTapeSetNotExisted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = IsTapeSetNotExisted_result()
    try:
      result.success = self._handler.IsTapeSetNotExisted(args.tapeSetName)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("IsTapeSetNotExisted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class CreateTapeSet_args(object):
  """
  Attributes:
   - tapeLibSerialNo
   - tapeSetName
   - driveNum
   - tapes
   - cycle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeLibSerialNo', None, None, ), # 1
    (2, TType.STRING, 'tapeSetName', None, None, ), # 2
    (3, TType.I32, 'driveNum', None, None, ), # 3
    (4, TType.LIST, 'tapes', (TType.STRING,None), None, ), # 4
    (5, TType.STRUCT, 'cycle', (ncTapeMgmType.ttypes.TapeSetCycle, ncTapeMgmType.ttypes.TapeSetCycle.thrift_spec), None, ), # 5
  )

  def __init__(self, tapeLibSerialNo=None, tapeSetName=None, driveNum=None, tapes=None, cycle=None,):
    self.tapeLibSerialNo = tapeLibSerialNo
    self.tapeSetName = tapeSetName
    self.driveNum = driveNum
    self.tapes = tapes
    self.cycle = cycle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeLibSerialNo = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tapeSetName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.driveNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.tapes = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString().decode('utf-8')
            self.tapes.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cycle = ncTapeMgmType.ttypes.TapeSetCycle()
          self.cycle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTapeSet_args')
    if self.tapeLibSerialNo is not None:
      oprot.writeFieldBegin('tapeLibSerialNo', TType.STRING, 1)
      oprot.writeString(self.tapeLibSerialNo.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tapeSetName is not None:
      oprot.writeFieldBegin('tapeSetName', TType.STRING, 2)
      oprot.writeString(self.tapeSetName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.driveNum is not None:
      oprot.writeFieldBegin('driveNum', TType.I32, 3)
      oprot.writeI32(self.driveNum)
      oprot.writeFieldEnd()
    if self.tapes is not None:
      oprot.writeFieldBegin('tapes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.tapes))
      for iter6 in self.tapes:
        oprot.writeString(iter6.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cycle is not None:
      oprot.writeFieldBegin('cycle', TType.STRUCT, 5)
      self.cycle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeLibSerialNo)
    value = (value * 31) ^ hash(self.tapeSetName)
    value = (value * 31) ^ hash(self.driveNum)
    value = (value * 31) ^ hash(self.tapes)
    value = (value * 31) ^ hash(self.cycle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateTapeSet_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateTapeSet_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteTapeSet_args(object):
  """
  Attributes:
   - tapeSetName
   - recursive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeSetName', None, None, ), # 1
    (2, TType.BOOL, 'recursive', None, None, ), # 2
  )

  def __init__(self, tapeSetName=None, recursive=None,):
    self.tapeSetName = tapeSetName
    self.recursive = recursive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeSetName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.recursive = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteTapeSet_args')
    if self.tapeSetName is not None:
      oprot.writeFieldBegin('tapeSetName', TType.STRING, 1)
      oprot.writeString(self.tapeSetName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.recursive is not None:
      oprot.writeFieldBegin('recursive', TType.BOOL, 2)
      oprot.writeBool(self.recursive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeSetName)
    value = (value * 31) ^ hash(self.recursive)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteTapeSet_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteTapeSet_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateTapeSet_args(object):
  """
  Attributes:
   - tapeSetName
   - driveNum
   - tapes
   - cycle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeSetName', None, None, ), # 1
    (2, TType.I32, 'driveNum', None, None, ), # 2
    (3, TType.LIST, 'tapes', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'cycle', (ncTapeMgmType.ttypes.TapeSetCycle, ncTapeMgmType.ttypes.TapeSetCycle.thrift_spec), None, ), # 4
  )

  def __init__(self, tapeSetName=None, driveNum=None, tapes=None, cycle=None,):
    self.tapeSetName = tapeSetName
    self.driveNum = driveNum
    self.tapes = tapes
    self.cycle = cycle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeSetName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.driveNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tapes = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.tapes.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cycle = ncTapeMgmType.ttypes.TapeSetCycle()
          self.cycle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateTapeSet_args')
    if self.tapeSetName is not None:
      oprot.writeFieldBegin('tapeSetName', TType.STRING, 1)
      oprot.writeString(self.tapeSetName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.driveNum is not None:
      oprot.writeFieldBegin('driveNum', TType.I32, 2)
      oprot.writeI32(self.driveNum)
      oprot.writeFieldEnd()
    if self.tapes is not None:
      oprot.writeFieldBegin('tapes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.tapes))
      for iter13 in self.tapes:
        oprot.writeString(iter13.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cycle is not None:
      oprot.writeFieldBegin('cycle', TType.STRUCT, 4)
      self.cycle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeSetName)
    value = (value * 31) ^ hash(self.driveNum)
    value = (value * 31) ^ hash(self.tapes)
    value = (value * 31) ^ hash(self.cycle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateTapeSet_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateTapeSet_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeSet_args(object):
  """
  Attributes:
   - offset
   - limit
   - cond
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'offset', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.STRUCT, 'cond', (ncTapeMgmType.ttypes.TapeQueryCond, ncTapeMgmType.ttypes.TapeQueryCond.thrift_spec), None, ), # 3
  )

  def __init__(self, offset=None, limit=None, cond=None,):
    self.offset = offset
    self.limit = limit
    self.cond = cond

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cond = ncTapeMgmType.ttypes.TapeQueryCond()
          self.cond.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeSet_args')
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 1)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.cond is not None:
      oprot.writeFieldBegin('cond', TType.STRUCT, 3)
      self.cond.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.cond)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeSet_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeSetInfoWeb, ncTapeMgmType.ttypes.TapeSetInfoWeb.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeSetInfoWeb()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeSet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeSetTape_args(object):
  """
  Attributes:
   - tapeSetName
   - offset
   - limit
   - cond
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeSetName', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
    (4, TType.STRUCT, 'cond', (ncTapeMgmType.ttypes.TapeQueryCond, ncTapeMgmType.ttypes.TapeQueryCond.thrift_spec), None, ), # 4
  )

  def __init__(self, tapeSetName=None, offset=None, limit=None, cond=None,):
    self.tapeSetName = tapeSetName
    self.offset = offset
    self.limit = limit
    self.cond = cond

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeSetName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cond = ncTapeMgmType.ttypes.TapeQueryCond()
          self.cond.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeSetTape_args')
    if self.tapeSetName is not None:
      oprot.writeFieldBegin('tapeSetName', TType.STRING, 1)
      oprot.writeString(self.tapeSetName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.cond is not None:
      oprot.writeFieldBegin('cond', TType.STRUCT, 4)
      self.cond.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeSetName)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.cond)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeSetTape_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeInfoWeb, ncTapeMgmType.ttypes.TapeInfoWeb.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeInfoWeb()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeSetTape_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeLibrary_args(object):
  """
  Attributes:
   - offset
   - limit
   - cond
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'offset', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.STRUCT, 'cond', (ncTapeMgmType.ttypes.TapeQueryCond, ncTapeMgmType.ttypes.TapeQueryCond.thrift_spec), None, ), # 3
  )

  def __init__(self, offset=None, limit=None, cond=None,):
    self.offset = offset
    self.limit = limit
    self.cond = cond

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cond = ncTapeMgmType.ttypes.TapeQueryCond()
          self.cond.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeLibrary_args')
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 1)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.cond is not None:
      oprot.writeFieldBegin('cond', TType.STRUCT, 3)
      self.cond.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.cond)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeLibrary_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeLibInfoWeb, ncTapeMgmType.ttypes.TapeLibInfoWeb.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeLibInfoWeb()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeLibrary_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeLibTape_args(object):
  """
  Attributes:
   - tapeLibSerialNo
   - offset
   - limit
   - cond
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeLibSerialNo', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
    (4, TType.STRUCT, 'cond', (ncTapeMgmType.ttypes.TapeQueryCond, ncTapeMgmType.ttypes.TapeQueryCond.thrift_spec), None, ), # 4
  )

  def __init__(self, tapeLibSerialNo=None, offset=None, limit=None, cond=None,):
    self.tapeLibSerialNo = tapeLibSerialNo
    self.offset = offset
    self.limit = limit
    self.cond = cond

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeLibSerialNo = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.cond = ncTapeMgmType.ttypes.TapeQueryCond()
          self.cond.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeLibTape_args')
    if self.tapeLibSerialNo is not None:
      oprot.writeFieldBegin('tapeLibSerialNo', TType.STRING, 1)
      oprot.writeString(self.tapeLibSerialNo.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.cond is not None:
      oprot.writeFieldBegin('cond', TType.STRUCT, 4)
      self.cond.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeLibSerialNo)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.cond)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeLibTape_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeInfoWeb, ncTapeMgmType.ttypes.TapeInfoWeb.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeInfoWeb()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeLibTape_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeDrive_args(object):
  """
  Attributes:
   - tapeLibSerialNo
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeLibSerialNo', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
  )

  def __init__(self, tapeLibSerialNo=None, offset=None, limit=None,):
    self.tapeLibSerialNo = tapeLibSerialNo
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeLibSerialNo = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeDrive_args')
    if self.tapeLibSerialNo is not None:
      oprot.writeFieldBegin('tapeLibSerialNo', TType.STRING, 1)
      oprot.writeString(self.tapeLibSerialNo.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeLibSerialNo)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListTapeDrive_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeLibDriveWeb, ncTapeMgmType.ttypes.TapeLibDriveWeb.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeLibDriveWeb()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListTapeDrive_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanTapeLib_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanTapeLib_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanTapeLib_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeScanStatus, ncTapeMgmType.ttypes.TapeScanStatus.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeScanStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanTapeLib_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTapeScanStatus_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTapeScanStatus_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetTapeScanStatus_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncTapeMgmType.ttypes.TapeScanStatus, ncTapeMgmType.ttypes.TapeScanStatus.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncTapeMgmType.ttypes.TapeScanStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetTapeScanStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsTapeSetNotExisted_args(object):
  """
  Attributes:
   - tapeSetName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tapeSetName', None, None, ), # 1
  )

  def __init__(self, tapeSetName=None,):
    self.tapeSetName = tapeSetName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tapeSetName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsTapeSetNotExisted_args')
    if self.tapeSetName is not None:
      oprot.writeFieldBegin('tapeSetName', TType.STRING, 1)
      oprot.writeString(self.tapeSetName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tapeSetName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IsTapeSetNotExisted_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IsTapeSetNotExisted_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
