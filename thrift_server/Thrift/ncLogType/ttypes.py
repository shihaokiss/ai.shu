#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ncCommonType_Var.ttypes
import ncUser.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ncLogLevel(object):
  LOG_INFORMATION = 1
  LOG_WARNING = 2
  LOG_ERROR = 3
  LOG_CRITICAL = 4

  _VALUES_TO_NAMES = {
    1: "LOG_INFORMATION",
    2: "LOG_WARNING",
    3: "LOG_ERROR",
    4: "LOG_CRITICAL",
  }

  _NAMES_TO_VALUES = {
    "LOG_INFORMATION": 1,
    "LOG_WARNING": 2,
    "LOG_ERROR": 3,
    "LOG_CRITICAL": 4,
  }

class ncLogRole(object):
  SYSTEM_ADMIN = 0
  SECURITY_ADMIN = 1
  AUDITS_ADMIN = 2
  OPERATOR = 3
  RIADMIN = 4
  TENANT = 5

  _VALUES_TO_NAMES = {
    0: "SYSTEM_ADMIN",
    1: "SECURITY_ADMIN",
    2: "AUDITS_ADMIN",
    3: "OPERATOR",
    4: "RIADMIN",
    5: "TENANT",
  }

  _NAMES_TO_VALUES = {
    "SYSTEM_ADMIN": 0,
    "SECURITY_ADMIN": 1,
    "AUDITS_ADMIN": 2,
    "OPERATOR": 3,
    "RIADMIN": 4,
    "TENANT": 5,
  }

class ncLogResult(object):
  SUCCESS = 1
  FAILED = 2
  PART_SUCCESS = 3
  DEFAULT = 4
  WARN_SUCCESS = 5

  _VALUES_TO_NAMES = {
    1: "SUCCESS",
    2: "FAILED",
    3: "PART_SUCCESS",
    4: "DEFAULT",
    5: "WARN_SUCCESS",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 1,
    "FAILED": 2,
    "PART_SUCCESS": 3,
    "DEFAULT": 4,
    "WARN_SUCCESS": 5,
  }

class ncLogDetailType(object):
  SYSTEM_TYPE = 1
  USER_TYPE = 2
  SCHEDULE_TYPE = 4

  _VALUES_TO_NAMES = {
    1: "SYSTEM_TYPE",
    2: "USER_TYPE",
    4: "SCHEDULE_TYPE",
  }

  _NAMES_TO_VALUES = {
    "SYSTEM_TYPE": 1,
    "USER_TYPE": 2,
    "SCHEDULE_TYPE": 4,
  }

class ncProtectType(object):
  COPY_DATA_MANAGEMENT = 1
  TIMING_DATA_PROTECTION = 2
  CONTINUOUS_DATA_PROTECTION = 3

  _VALUES_TO_NAMES = {
    1: "COPY_DATA_MANAGEMENT",
    2: "TIMING_DATA_PROTECTION",
    3: "CONTINUOUS_DATA_PROTECTION",
  }

  _NAMES_TO_VALUES = {
    "COPY_DATA_MANAGEMENT": 1,
    "TIMING_DATA_PROTECTION": 2,
    "CONTINUOUS_DATA_PROTECTION": 3,
  }

class ncDataType(object):
  DATA_BACKUP = 1
  DATA_ARCHIVING = 2
  STORAGE_SNAPSHOT = 3
  DATA_RECOVERY = 4
  REMOTE_REPLICATION = 5
  DATA_CLEANING = 6
  DATA_ACCESS = 7
  COPY_MANAGEMENT = 8
  REAL_TIME_REPLICATION = 9
  REAL_TIME_BACKUP = 10
  TAKEOVER_DRILL = 11
  MOUNT_RESTORE = 12
  CDP_RESTORE = 13

  _VALUES_TO_NAMES = {
    1: "DATA_BACKUP",
    2: "DATA_ARCHIVING",
    3: "STORAGE_SNAPSHOT",
    4: "DATA_RECOVERY",
    5: "REMOTE_REPLICATION",
    6: "DATA_CLEANING",
    7: "DATA_ACCESS",
    8: "COPY_MANAGEMENT",
    9: "REAL_TIME_REPLICATION",
    10: "REAL_TIME_BACKUP",
    11: "TAKEOVER_DRILL",
    12: "MOUNT_RESTORE",
    13: "CDP_RESTORE",
  }

  _NAMES_TO_VALUES = {
    "DATA_BACKUP": 1,
    "DATA_ARCHIVING": 2,
    "STORAGE_SNAPSHOT": 3,
    "DATA_RECOVERY": 4,
    "REMOTE_REPLICATION": 5,
    "DATA_CLEANING": 6,
    "DATA_ACCESS": 7,
    "COPY_MANAGEMENT": 8,
    "REAL_TIME_REPLICATION": 9,
    "REAL_TIME_BACKUP": 10,
    "TAKEOVER_DRILL": 11,
    "MOUNT_RESTORE": 12,
    "CDP_RESTORE": 13,
  }

class ncEventType(object):
  SERVICE_MANAGEMENT = 1
  STORAGE_MANAGEMENT = 2
  SYSTEM_MANAGEMENT = 3
  RESOURCE_MANAGEMENT = 4
  ILLEGAL_LOGIN = 5
  DATA_CLEANING = 6
  LOGIN_INFORMATION = 7
  PERSONAL_INFORMATION_MANAGEMENT = 8
  PRIVILEGE_MANAGEMENT = 9
  ALARM_MANAGEMENT = 10
  SECURITY_MANAGEMENT = 11
  LOG_MANAGEMENT = 12
  SCHEDULE_MANAGEMENT = 13
  SCHEDULE_APPLICATION = 14
  SCHEDULE_EXECUTION = 15
  STRATETY_MANAGMENT = 16

  _VALUES_TO_NAMES = {
    1: "SERVICE_MANAGEMENT",
    2: "STORAGE_MANAGEMENT",
    3: "SYSTEM_MANAGEMENT",
    4: "RESOURCE_MANAGEMENT",
    5: "ILLEGAL_LOGIN",
    6: "DATA_CLEANING",
    7: "LOGIN_INFORMATION",
    8: "PERSONAL_INFORMATION_MANAGEMENT",
    9: "PRIVILEGE_MANAGEMENT",
    10: "ALARM_MANAGEMENT",
    11: "SECURITY_MANAGEMENT",
    12: "LOG_MANAGEMENT",
    13: "SCHEDULE_MANAGEMENT",
    14: "SCHEDULE_APPLICATION",
    15: "SCHEDULE_EXECUTION",
    16: "STRATETY_MANAGMENT",
  }

  _NAMES_TO_VALUES = {
    "SERVICE_MANAGEMENT": 1,
    "STORAGE_MANAGEMENT": 2,
    "SYSTEM_MANAGEMENT": 3,
    "RESOURCE_MANAGEMENT": 4,
    "ILLEGAL_LOGIN": 5,
    "DATA_CLEANING": 6,
    "LOGIN_INFORMATION": 7,
    "PERSONAL_INFORMATION_MANAGEMENT": 8,
    "PRIVILEGE_MANAGEMENT": 9,
    "ALARM_MANAGEMENT": 10,
    "SECURITY_MANAGEMENT": 11,
    "LOG_MANAGEMENT": 12,
    "SCHEDULE_MANAGEMENT": 13,
    "SCHEDULE_APPLICATION": 14,
    "SCHEDULE_EXECUTION": 15,
    "STRATETY_MANAGMENT": 16,
  }

class ncLogEvent(object):
  ABNORMAL = 1
  ON_LINE = 2
  OFF_LINE = 3
  EDIT = 4
  OPEN_SSH_SERVICE = 5
  CLOSE_SSH_SERVICE = 6
  ADD = 7
  DELETED = 8
  ACTIVE = 9
  CONFIGURATION_POLICY = 10
  BINDING_DEVICE = 11
  UNTYING_DEVICE = 12
  AGREE_TO_LINK = 13
  CANCEL_TO_LINK = 14
  BEAGREE_TO_LINK = 15
  BECANCEL_TO_LINK = 16
  DISTRIBUTE = 17
  CALL_BACK = 18
  CONFIGURE_DB = 19
  CLEAN_UP = 20
  ILLEGAL_LOGIN = 21
  AUTOMATIC_CLEANING = 22
  LOGIN_IN = 23
  LOCK_OUT = 24
  LOGIN_OUT = 25
  DOWNTIME_OFFLINE = 26
  RESET_PASSWORD = 27
  ENABLE = 28
  FORBIDDEN = 29
  LOCK_UNX = 30
  INITIATE_MANUALLY_TASK = 31
  STOP_MANUALLT_TASK = 32
  AGREE_TO_RECEIVE = 33
  CANCEL_TO_RECEIVE = 34
  BEAGREE_TO_RECEIVE = 35
  BECANCEL_TO_RECEIVE = 36
  INITIATE_AUTOMATIC_TASK = 37
  EXECUTE_TASK = 38
  STOPPED_TASK = 39
  EXECUTE_ACCESS = 40
  CONNECT_TO_OPERATION_PLATFORM = 41
  CONNECTION_WITH_OPERATION_PLATFORM_INTERRUPT = 42
  CONNECTION_WITH_OPERATION_PLATFORM_RESTORE = 43
  INITIATE_MANUALLY_TASK_SWITCH_OVER = 44
  INITIATE_MANUALLY_TASK_FAIL_OVER = 45
  AGREE_PROTOCOL = 46
  CANCEL_AGREE_PROTOCOL = 47
  CHECK_USER_LOG = 48
  EXPORT_USER_LOG = 49
  CLIENT_ADD_ISCSI_IQN = 50
  CLIENT_DELETE_ISCSI_IQN = 51
  CLIENT_CONFIG_ASM = 52
  CLIENT_ADD_FC_WWPN = 53
  CLIENT_DELETE_FC_WWPN = 54
  CLIENT_ADD_FCOE_WWPN = 55
  CLIENT_DELETE_FCOE_WWPN = 56
  CDM_IMAGE_MOUNT = 57
  CDM_IMAGE_UNMOUNT = 58
  CDM_IMAGE_DISCARD = 59
  CDM_IMAGE_DELETE = 60
  CDM_IMAGE_REVERT = 61
  EXPORT_LOG_IN = 62
  EXECUTE_REVERSE_REPLICATION = 63
  EXECUTE_DATA_SYNCHRONIZATION = 64
  CERT_EXPIRED = 65
  CERT_EXPIRE_TIP = 66
  CLIENT_CHECK_INFO = 67
  EXPORT_STRATEGY_OUT = 68
  EXPORT_STRATEGY_IN = 69
  CPU_RESOURCE_WARNING = 71
  MEMORY_RESOURCE_WARNING = 72
  NETWORK_RESOURCE_WARNING = 73
  UNKNOWN = 100

  _VALUES_TO_NAMES = {
    1: "ABNORMAL",
    2: "ON_LINE",
    3: "OFF_LINE",
    4: "EDIT",
    5: "OPEN_SSH_SERVICE",
    6: "CLOSE_SSH_SERVICE",
    7: "ADD",
    8: "DELETED",
    9: "ACTIVE",
    10: "CONFIGURATION_POLICY",
    11: "BINDING_DEVICE",
    12: "UNTYING_DEVICE",
    13: "AGREE_TO_LINK",
    14: "CANCEL_TO_LINK",
    15: "BEAGREE_TO_LINK",
    16: "BECANCEL_TO_LINK",
    17: "DISTRIBUTE",
    18: "CALL_BACK",
    19: "CONFIGURE_DB",
    20: "CLEAN_UP",
    21: "ILLEGAL_LOGIN",
    22: "AUTOMATIC_CLEANING",
    23: "LOGIN_IN",
    24: "LOCK_OUT",
    25: "LOGIN_OUT",
    26: "DOWNTIME_OFFLINE",
    27: "RESET_PASSWORD",
    28: "ENABLE",
    29: "FORBIDDEN",
    30: "LOCK_UNX",
    31: "INITIATE_MANUALLY_TASK",
    32: "STOP_MANUALLT_TASK",
    33: "AGREE_TO_RECEIVE",
    34: "CANCEL_TO_RECEIVE",
    35: "BEAGREE_TO_RECEIVE",
    36: "BECANCEL_TO_RECEIVE",
    37: "INITIATE_AUTOMATIC_TASK",
    38: "EXECUTE_TASK",
    39: "STOPPED_TASK",
    40: "EXECUTE_ACCESS",
    41: "CONNECT_TO_OPERATION_PLATFORM",
    42: "CONNECTION_WITH_OPERATION_PLATFORM_INTERRUPT",
    43: "CONNECTION_WITH_OPERATION_PLATFORM_RESTORE",
    44: "INITIATE_MANUALLY_TASK_SWITCH_OVER",
    45: "INITIATE_MANUALLY_TASK_FAIL_OVER",
    46: "AGREE_PROTOCOL",
    47: "CANCEL_AGREE_PROTOCOL",
    48: "CHECK_USER_LOG",
    49: "EXPORT_USER_LOG",
    50: "CLIENT_ADD_ISCSI_IQN",
    51: "CLIENT_DELETE_ISCSI_IQN",
    52: "CLIENT_CONFIG_ASM",
    53: "CLIENT_ADD_FC_WWPN",
    54: "CLIENT_DELETE_FC_WWPN",
    55: "CLIENT_ADD_FCOE_WWPN",
    56: "CLIENT_DELETE_FCOE_WWPN",
    57: "CDM_IMAGE_MOUNT",
    58: "CDM_IMAGE_UNMOUNT",
    59: "CDM_IMAGE_DISCARD",
    60: "CDM_IMAGE_DELETE",
    61: "CDM_IMAGE_REVERT",
    62: "EXPORT_LOG_IN",
    63: "EXECUTE_REVERSE_REPLICATION",
    64: "EXECUTE_DATA_SYNCHRONIZATION",
    65: "CERT_EXPIRED",
    66: "CERT_EXPIRE_TIP",
    67: "CLIENT_CHECK_INFO",
    68: "EXPORT_STRATEGY_OUT",
    69: "EXPORT_STRATEGY_IN",
    71: "CPU_RESOURCE_WARNING",
    72: "MEMORY_RESOURCE_WARNING",
    73: "NETWORK_RESOURCE_WARNING",
    100: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "ABNORMAL": 1,
    "ON_LINE": 2,
    "OFF_LINE": 3,
    "EDIT": 4,
    "OPEN_SSH_SERVICE": 5,
    "CLOSE_SSH_SERVICE": 6,
    "ADD": 7,
    "DELETED": 8,
    "ACTIVE": 9,
    "CONFIGURATION_POLICY": 10,
    "BINDING_DEVICE": 11,
    "UNTYING_DEVICE": 12,
    "AGREE_TO_LINK": 13,
    "CANCEL_TO_LINK": 14,
    "BEAGREE_TO_LINK": 15,
    "BECANCEL_TO_LINK": 16,
    "DISTRIBUTE": 17,
    "CALL_BACK": 18,
    "CONFIGURE_DB": 19,
    "CLEAN_UP": 20,
    "ILLEGAL_LOGIN": 21,
    "AUTOMATIC_CLEANING": 22,
    "LOGIN_IN": 23,
    "LOCK_OUT": 24,
    "LOGIN_OUT": 25,
    "DOWNTIME_OFFLINE": 26,
    "RESET_PASSWORD": 27,
    "ENABLE": 28,
    "FORBIDDEN": 29,
    "LOCK_UNX": 30,
    "INITIATE_MANUALLY_TASK": 31,
    "STOP_MANUALLT_TASK": 32,
    "AGREE_TO_RECEIVE": 33,
    "CANCEL_TO_RECEIVE": 34,
    "BEAGREE_TO_RECEIVE": 35,
    "BECANCEL_TO_RECEIVE": 36,
    "INITIATE_AUTOMATIC_TASK": 37,
    "EXECUTE_TASK": 38,
    "STOPPED_TASK": 39,
    "EXECUTE_ACCESS": 40,
    "CONNECT_TO_OPERATION_PLATFORM": 41,
    "CONNECTION_WITH_OPERATION_PLATFORM_INTERRUPT": 42,
    "CONNECTION_WITH_OPERATION_PLATFORM_RESTORE": 43,
    "INITIATE_MANUALLY_TASK_SWITCH_OVER": 44,
    "INITIATE_MANUALLY_TASK_FAIL_OVER": 45,
    "AGREE_PROTOCOL": 46,
    "CANCEL_AGREE_PROTOCOL": 47,
    "CHECK_USER_LOG": 48,
    "EXPORT_USER_LOG": 49,
    "CLIENT_ADD_ISCSI_IQN": 50,
    "CLIENT_DELETE_ISCSI_IQN": 51,
    "CLIENT_CONFIG_ASM": 52,
    "CLIENT_ADD_FC_WWPN": 53,
    "CLIENT_DELETE_FC_WWPN": 54,
    "CLIENT_ADD_FCOE_WWPN": 55,
    "CLIENT_DELETE_FCOE_WWPN": 56,
    "CDM_IMAGE_MOUNT": 57,
    "CDM_IMAGE_UNMOUNT": 58,
    "CDM_IMAGE_DISCARD": 59,
    "CDM_IMAGE_DELETE": 60,
    "CDM_IMAGE_REVERT": 61,
    "EXPORT_LOG_IN": 62,
    "EXECUTE_REVERSE_REPLICATION": 63,
    "EXECUTE_DATA_SYNCHRONIZATION": 64,
    "CERT_EXPIRED": 65,
    "CERT_EXPIRE_TIP": 66,
    "CLIENT_CHECK_INFO": 67,
    "EXPORT_STRATEGY_OUT": 68,
    "EXPORT_STRATEGY_IN": 69,
    "CPU_RESOURCE_WARNING": 71,
    "MEMORY_RESOURCE_WARNING": 72,
    "NETWORK_RESOURCE_WARNING": 73,
    "UNKNOWN": 100,
  }

class ncBackupMediaType(object):
  OFS = 1
  MEDIA_SET = 2
  CLOUD_STORAGE = 3
  SNAPSHOT_POOL = 4

  _VALUES_TO_NAMES = {
    1: "OFS",
    2: "MEDIA_SET",
    3: "CLOUD_STORAGE",
    4: "SNAPSHOT_POOL",
  }

  _NAMES_TO_VALUES = {
    "OFS": 1,
    "MEDIA_SET": 2,
    "CLOUD_STORAGE": 3,
    "SNAPSHOT_POOL": 4,
  }

class ncPermsStrategy(object):
  CREATE_USER = 1
  DELETE_USER = 2
  DEFAULT = 7

  _VALUES_TO_NAMES = {
    1: "CREATE_USER",
    2: "DELETE_USER",
    7: "DEFAULT",
  }

  _NAMES_TO_VALUES = {
    "CREATE_USER": 1,
    "DELETE_USER": 2,
    "DEFAULT": 7,
  }

class ncSystemEventType(object):
  AUTOMATIC_TASK = 1
  OPERATOR_INFORMATION = 2
  CLIENT_INFORMATION = 3
  ILLEGAL_LOGIN = 4
  STORE_INFORMATION = 5
  SYSTEM_INFORMATION = 6
  SERVICE_INFORMATION = 7

  _VALUES_TO_NAMES = {
    1: "AUTOMATIC_TASK",
    2: "OPERATOR_INFORMATION",
    3: "CLIENT_INFORMATION",
    4: "ILLEGAL_LOGIN",
    5: "STORE_INFORMATION",
    6: "SYSTEM_INFORMATION",
    7: "SERVICE_INFORMATION",
  }

  _NAMES_TO_VALUES = {
    "AUTOMATIC_TASK": 1,
    "OPERATOR_INFORMATION": 2,
    "CLIENT_INFORMATION": 3,
    "ILLEGAL_LOGIN": 4,
    "STORE_INFORMATION": 5,
    "SYSTEM_INFORMATION": 6,
    "SERVICE_INFORMATION": 7,
  }

class ncUserEventType(object):
  LOGIN_INFORMATION = 1
  PERSONAL_INFORMATION_MANAGEMENT = 2
  AUTHORITY_MANAGEMENT = 3
  STORAGE_MANAGEMENT = 4
  SYSTEM_MANAGEMENT = 5
  ALARM_MANAGEMENT = 6
  RESOURCE_MANAGEMENT = 7
  ALARM_CONFIGURATION = 8
  SECURITY_MANAGEMENT = 9
  LOG_MANAGEMENT = 10
  TASK_MANAGEMENT = 11
  TASK_APPLICATION = 12

  _VALUES_TO_NAMES = {
    1: "LOGIN_INFORMATION",
    2: "PERSONAL_INFORMATION_MANAGEMENT",
    3: "AUTHORITY_MANAGEMENT",
    4: "STORAGE_MANAGEMENT",
    5: "SYSTEM_MANAGEMENT",
    6: "ALARM_MANAGEMENT",
    7: "RESOURCE_MANAGEMENT",
    8: "ALARM_CONFIGURATION",
    9: "SECURITY_MANAGEMENT",
    10: "LOG_MANAGEMENT",
    11: "TASK_MANAGEMENT",
    12: "TASK_APPLICATION",
  }

  _NAMES_TO_VALUES = {
    "LOGIN_INFORMATION": 1,
    "PERSONAL_INFORMATION_MANAGEMENT": 2,
    "AUTHORITY_MANAGEMENT": 3,
    "STORAGE_MANAGEMENT": 4,
    "SYSTEM_MANAGEMENT": 5,
    "ALARM_MANAGEMENT": 6,
    "RESOURCE_MANAGEMENT": 7,
    "ALARM_CONFIGURATION": 8,
    "SECURITY_MANAGEMENT": 9,
    "LOG_MANAGEMENT": 10,
    "TASK_MANAGEMENT": 11,
    "TASK_APPLICATION": 12,
  }

class ncScheduleEventType(object):
  NEW_BACKUP_TASK = 1
  EDIT_BACKUP_TASK = 2
  DELETE_BACKUP_TASK = 3
  MANUALLY_INITIATE_BACKUP_TASK = 4
  PLAN_TO_INITIATE_BACKUP_TASK = 5
  EXECUTE_BACKUP_TASK = 6
  NEW_RECOVERY_TASK = 7
  DELETE_RECOVERY_TASK = 8
  INITIATE_RECOVERY_TASK = 9
  EXECUTE_RECOVERY_TASK = 10
  MANUALLY_STOP_BACKUP_TASK = 11
  BACKUP_TASK_STOPPED = 12
  MANUALLY_STOP_RECOVERY_TASK = 13
  RECOVERY_TASK_STOPPED = 14
  MANUALLY_STOP_REAL_TIME_COPY_TASK = 15
  REAL_TIME_COPY_TASK_STOPPED = 16
  SLA_POLICY_INITIATES_BACKUP_TASK = 17
  NEW_MOUNT_TASK = 18
  DELETE_MOUNT_TASK = 19
  INITIATE_MOUNT_TASK = 20
  EXECUTE_MOUNT_TASK = 21
  NEW_REAL_TIME_REPLICATION_TASK = 22
  DELETE_REAL_TIME_REPLICATION_TASK = 23
  MANUALLY_INITIATE_REAL_TIME_REPLICATION_TASK = 24
  EXECUTE_REAL_TIME_COPY_TASK = 25
  NEW_REMOTE_REPLICATION_TASK = 26
  EDIT_REMOTE_REPLICATION_TASK = 27
  DELETE_REMOTE_REPLICATION_TASK = 28
  INITIATE_DATA_SYNCHRONIZATION = 29
  INITIATE_REVERSE_REPLICATION = 30
  EXECUTE_REVERSE_REPLICATION = 31
  DELETE_HISTORY_RECORD = 32
  AGREE_TO_ACCEPT = 33
  CALL_OFF_ACCEPT = 34
  STOP_DATA_SYNCHRONIZATION = 35
  STOP_REVERSE_REPLICATION = 36
  EXECUTE_DATA_SYNCHRONIZATION = 37
  DATA_SYNCHRONIZATION_STOPPED = 38
  REVERSE_REPLICATION_STOPPED = 39
  NEW_DATA_CLEANSING_TASK = 40
  EXECUTE_DATA_CLEANDING_TASK = 41
  NEW_DATA_ACCESS_TASK = 42
  DELETE_DATA_ACCESS_TASK = 43
  EXECUTE_DATA_ACCESS_TASK = 44
  CONFIGURATION_STRATEGY = 45

  _VALUES_TO_NAMES = {
    1: "NEW_BACKUP_TASK",
    2: "EDIT_BACKUP_TASK",
    3: "DELETE_BACKUP_TASK",
    4: "MANUALLY_INITIATE_BACKUP_TASK",
    5: "PLAN_TO_INITIATE_BACKUP_TASK",
    6: "EXECUTE_BACKUP_TASK",
    7: "NEW_RECOVERY_TASK",
    8: "DELETE_RECOVERY_TASK",
    9: "INITIATE_RECOVERY_TASK",
    10: "EXECUTE_RECOVERY_TASK",
    11: "MANUALLY_STOP_BACKUP_TASK",
    12: "BACKUP_TASK_STOPPED",
    13: "MANUALLY_STOP_RECOVERY_TASK",
    14: "RECOVERY_TASK_STOPPED",
    15: "MANUALLY_STOP_REAL_TIME_COPY_TASK",
    16: "REAL_TIME_COPY_TASK_STOPPED",
    17: "SLA_POLICY_INITIATES_BACKUP_TASK",
    18: "NEW_MOUNT_TASK",
    19: "DELETE_MOUNT_TASK",
    20: "INITIATE_MOUNT_TASK",
    21: "EXECUTE_MOUNT_TASK",
    22: "NEW_REAL_TIME_REPLICATION_TASK",
    23: "DELETE_REAL_TIME_REPLICATION_TASK",
    24: "MANUALLY_INITIATE_REAL_TIME_REPLICATION_TASK",
    25: "EXECUTE_REAL_TIME_COPY_TASK",
    26: "NEW_REMOTE_REPLICATION_TASK",
    27: "EDIT_REMOTE_REPLICATION_TASK",
    28: "DELETE_REMOTE_REPLICATION_TASK",
    29: "INITIATE_DATA_SYNCHRONIZATION",
    30: "INITIATE_REVERSE_REPLICATION",
    31: "EXECUTE_REVERSE_REPLICATION",
    32: "DELETE_HISTORY_RECORD",
    33: "AGREE_TO_ACCEPT",
    34: "CALL_OFF_ACCEPT",
    35: "STOP_DATA_SYNCHRONIZATION",
    36: "STOP_REVERSE_REPLICATION",
    37: "EXECUTE_DATA_SYNCHRONIZATION",
    38: "DATA_SYNCHRONIZATION_STOPPED",
    39: "REVERSE_REPLICATION_STOPPED",
    40: "NEW_DATA_CLEANSING_TASK",
    41: "EXECUTE_DATA_CLEANDING_TASK",
    42: "NEW_DATA_ACCESS_TASK",
    43: "DELETE_DATA_ACCESS_TASK",
    44: "EXECUTE_DATA_ACCESS_TASK",
    45: "CONFIGURATION_STRATEGY",
  }

  _NAMES_TO_VALUES = {
    "NEW_BACKUP_TASK": 1,
    "EDIT_BACKUP_TASK": 2,
    "DELETE_BACKUP_TASK": 3,
    "MANUALLY_INITIATE_BACKUP_TASK": 4,
    "PLAN_TO_INITIATE_BACKUP_TASK": 5,
    "EXECUTE_BACKUP_TASK": 6,
    "NEW_RECOVERY_TASK": 7,
    "DELETE_RECOVERY_TASK": 8,
    "INITIATE_RECOVERY_TASK": 9,
    "EXECUTE_RECOVERY_TASK": 10,
    "MANUALLY_STOP_BACKUP_TASK": 11,
    "BACKUP_TASK_STOPPED": 12,
    "MANUALLY_STOP_RECOVERY_TASK": 13,
    "RECOVERY_TASK_STOPPED": 14,
    "MANUALLY_STOP_REAL_TIME_COPY_TASK": 15,
    "REAL_TIME_COPY_TASK_STOPPED": 16,
    "SLA_POLICY_INITIATES_BACKUP_TASK": 17,
    "NEW_MOUNT_TASK": 18,
    "DELETE_MOUNT_TASK": 19,
    "INITIATE_MOUNT_TASK": 20,
    "EXECUTE_MOUNT_TASK": 21,
    "NEW_REAL_TIME_REPLICATION_TASK": 22,
    "DELETE_REAL_TIME_REPLICATION_TASK": 23,
    "MANUALLY_INITIATE_REAL_TIME_REPLICATION_TASK": 24,
    "EXECUTE_REAL_TIME_COPY_TASK": 25,
    "NEW_REMOTE_REPLICATION_TASK": 26,
    "EDIT_REMOTE_REPLICATION_TASK": 27,
    "DELETE_REMOTE_REPLICATION_TASK": 28,
    "INITIATE_DATA_SYNCHRONIZATION": 29,
    "INITIATE_REVERSE_REPLICATION": 30,
    "EXECUTE_REVERSE_REPLICATION": 31,
    "DELETE_HISTORY_RECORD": 32,
    "AGREE_TO_ACCEPT": 33,
    "CALL_OFF_ACCEPT": 34,
    "STOP_DATA_SYNCHRONIZATION": 35,
    "STOP_REVERSE_REPLICATION": 36,
    "EXECUTE_DATA_SYNCHRONIZATION": 37,
    "DATA_SYNCHRONIZATION_STOPPED": 38,
    "REVERSE_REPLICATION_STOPPED": 39,
    "NEW_DATA_CLEANSING_TASK": 40,
    "EXECUTE_DATA_CLEANDING_TASK": 41,
    "NEW_DATA_ACCESS_TASK": 42,
    "DELETE_DATA_ACCESS_TASK": 43,
    "EXECUTE_DATA_ACCESS_TASK": 44,
    "CONFIGURATION_STRATEGY": 45,
  }


class ncLogSaveTime(object):
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncLogSaveTime')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncCommonLog(object):
  """
  Attributes:
   - sTime
   - executor
   - excObject
   - logEvent
   - result
   - errContent
   - needWarn
   - level
   - eventType
   - logContent
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'sTime', None, None, ), # 1
    (2, TType.STRING, 'executor', None, None, ), # 2
    (3, TType.STRING, 'excObject', None, None, ), # 3
    (4, TType.I32, 'logEvent', None, None, ), # 4
    (5, TType.I32, 'result', None, None, ), # 5
    (6, TType.STRING, 'errContent', None, None, ), # 6
    (7, TType.BOOL, 'needWarn', None, None, ), # 7
    (8, TType.I32, 'level', None, None, ), # 8
    (9, TType.I32, 'eventType', None, None, ), # 9
    (10, TType.STRING, 'logContent', None, None, ), # 10
  )

  def __init__(self, sTime=None, executor=None, excObject=None, logEvent=None, result=None, errContent=None, needWarn=None, level=None, eventType=None, logContent=None,):
    self.sTime = sTime
    self.executor = executor
    self.excObject = excObject
    self.logEvent = logEvent
    self.result = result
    self.errContent = errContent
    self.needWarn = needWarn
    self.level = level
    self.eventType = eventType
    self.logContent = logContent

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.executor = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.excObject = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.logEvent = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.result = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.errContent = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.needWarn = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.logContent = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncCommonLog')
    if self.sTime is not None:
      oprot.writeFieldBegin('sTime', TType.I64, 1)
      oprot.writeI64(self.sTime)
      oprot.writeFieldEnd()
    if self.executor is not None:
      oprot.writeFieldBegin('executor', TType.STRING, 2)
      oprot.writeString(self.executor.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.excObject is not None:
      oprot.writeFieldBegin('excObject', TType.STRING, 3)
      oprot.writeString(self.excObject.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.logEvent is not None:
      oprot.writeFieldBegin('logEvent', TType.I32, 4)
      oprot.writeI32(self.logEvent)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.I32, 5)
      oprot.writeI32(self.result)
      oprot.writeFieldEnd()
    if self.errContent is not None:
      oprot.writeFieldBegin('errContent', TType.STRING, 6)
      oprot.writeString(self.errContent.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.needWarn is not None:
      oprot.writeFieldBegin('needWarn', TType.BOOL, 7)
      oprot.writeBool(self.needWarn)
      oprot.writeFieldEnd()
    if self.level is not None:
      oprot.writeFieldBegin('level', TType.I32, 8)
      oprot.writeI32(self.level)
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 9)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    if self.logContent is not None:
      oprot.writeFieldBegin('logContent', TType.STRING, 10)
      oprot.writeString(self.logContent.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sTime is None:
      raise TProtocol.TProtocolException(message='Required field sTime is unset!')
    if self.executor is None:
      raise TProtocol.TProtocolException(message='Required field executor is unset!')
    if self.excObject is None:
      raise TProtocol.TProtocolException(message='Required field excObject is unset!')
    if self.logEvent is None:
      raise TProtocol.TProtocolException(message='Required field logEvent is unset!')
    if self.result is None:
      raise TProtocol.TProtocolException(message='Required field result is unset!')
    if self.errContent is None:
      raise TProtocol.TProtocolException(message='Required field errContent is unset!')
    if self.needWarn is None:
      raise TProtocol.TProtocolException(message='Required field needWarn is unset!')
    if self.level is None:
      raise TProtocol.TProtocolException(message='Required field level is unset!')
    if self.eventType is None:
      raise TProtocol.TProtocolException(message='Required field eventType is unset!')
    if self.logContent is None:
      raise TProtocol.TProtocolException(message='Required field logContent is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sTime)
    value = (value * 31) ^ hash(self.executor)
    value = (value * 31) ^ hash(self.excObject)
    value = (value * 31) ^ hash(self.logEvent)
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.errContent)
    value = (value * 31) ^ hash(self.needWarn)
    value = (value * 31) ^ hash(self.level)
    value = (value * 31) ^ hash(self.eventType)
    value = (value * 31) ^ hash(self.logContent)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncSystemLog(object):
  """
  Attributes:
   - log
   - logType
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'log', (ncCommonLog, ncCommonLog.thrift_spec), None, ), # 1
    (2, TType.I32, 'logType', None, 1, ), # 2
    (3, TType.STRING, 'customer', None, None, ), # 3
  )

  def __init__(self, log=None, logType=thrift_spec[2][4], customer=None,):
    self.log = log
    self.logType = logType
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.log = ncCommonLog()
          self.log.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.logType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncSystemLog')
    if self.log is not None:
      oprot.writeFieldBegin('log', TType.STRUCT, 1)
      self.log.write(oprot)
      oprot.writeFieldEnd()
    if self.logType is not None:
      oprot.writeFieldBegin('logType', TType.I32, 2)
      oprot.writeI32(self.logType)
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 3)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.log is None:
      raise TProtocol.TProtocolException(message='Required field log is unset!')
    if self.logType is None:
      raise TProtocol.TProtocolException(message='Required field logType is unset!')
    if self.customer is None:
      raise TProtocol.TProtocolException(message='Required field customer is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.log)
    value = (value * 31) ^ hash(self.logType)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncUserLog(object):
  """
  Attributes:
   - log
   - role
   - protectType
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'log', (ncCommonLog, ncCommonLog.thrift_spec), None, ), # 1
    (2, TType.I32, 'role', None, None, ), # 2
    (3, TType.I32, 'protectType', None, None, ), # 3
    (4, TType.STRING, 'customer', None, None, ), # 4
  )

  def __init__(self, log=None, role=None, protectType=None, customer=None,):
    self.log = log
    self.role = role
    self.protectType = protectType
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.log = ncCommonLog()
          self.log.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.protectType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncUserLog')
    if self.log is not None:
      oprot.writeFieldBegin('log', TType.STRUCT, 1)
      self.log.write(oprot)
      oprot.writeFieldEnd()
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.I32, 2)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.protectType is not None:
      oprot.writeFieldBegin('protectType', TType.I32, 3)
      oprot.writeI32(self.protectType)
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 4)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.log is None:
      raise TProtocol.TProtocolException(message='Required field log is unset!')
    if self.role is None:
      raise TProtocol.TProtocolException(message='Required field role is unset!')
    if self.protectType is None:
      raise TProtocol.TProtocolException(message='Required field protectType is unset!')
    if self.customer is None:
      raise TProtocol.TProtocolException(message='Required field customer is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.log)
    value = (value * 31) ^ hash(self.role)
    value = (value * 31) ^ hash(self.protectType)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncScheduleLog(object):
  """
  Attributes:
   - log
   - protectType
   - dataType
   - clientId
   - logType
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'log', (ncCommonLog, ncCommonLog.thrift_spec), None, ), # 1
    (2, TType.I32, 'protectType', None, None, ), # 2
    (3, TType.I32, 'dataType', None, None, ), # 3
    (4, TType.STRING, 'clientId', None, None, ), # 4
    (5, TType.I32, 'logType', None, 4, ), # 5
    (6, TType.STRING, 'customer', None, None, ), # 6
  )

  def __init__(self, log=None, protectType=None, dataType=None, clientId=None, logType=thrift_spec[5][4], customer=None,):
    self.log = log
    self.protectType = protectType
    self.dataType = dataType
    self.clientId = clientId
    self.logType = logType
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.log = ncCommonLog()
          self.log.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.protectType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.dataType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.logType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncScheduleLog')
    if self.log is not None:
      oprot.writeFieldBegin('log', TType.STRUCT, 1)
      self.log.write(oprot)
      oprot.writeFieldEnd()
    if self.protectType is not None:
      oprot.writeFieldBegin('protectType', TType.I32, 2)
      oprot.writeI32(self.protectType)
      oprot.writeFieldEnd()
    if self.dataType is not None:
      oprot.writeFieldBegin('dataType', TType.I32, 3)
      oprot.writeI32(self.dataType)
      oprot.writeFieldEnd()
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 4)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.logType is not None:
      oprot.writeFieldBegin('logType', TType.I32, 5)
      oprot.writeI32(self.logType)
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 6)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.log is None:
      raise TProtocol.TProtocolException(message='Required field log is unset!')
    if self.protectType is None:
      raise TProtocol.TProtocolException(message='Required field protectType is unset!')
    if self.dataType is None:
      raise TProtocol.TProtocolException(message='Required field dataType is unset!')
    if self.clientId is None:
      raise TProtocol.TProtocolException(message='Required field clientId is unset!')
    if self.logType is None:
      raise TProtocol.TProtocolException(message='Required field logType is unset!')
    if self.customer is None:
      raise TProtocol.TProtocolException(message='Required field customer is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.log)
    value = (value * 31) ^ hash(self.protectType)
    value = (value * 31) ^ hash(self.dataType)
    value = (value * 31) ^ hash(self.clientId)
    value = (value * 31) ^ hash(self.logType)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncExportLogReq(object):
  """
  Attributes:
   - fileFormat
   - fileName
   - requestId
   - method
   - filterParams
   - passWord
   - uuidStr
   - userName
   - userRole
   - loginIp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fileFormat', None, None, ), # 1
    (2, TType.STRING, 'fileName', None, None, ), # 2
    (3, TType.STRING, 'requestId', None, None, ), # 3
    (4, TType.I32, 'method', None, None, ), # 4
    (5, TType.MAP, 'filterParams', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'passWord', None, None, ), # 6
    (7, TType.STRING, 'uuidStr', None, None, ), # 7
    (8, TType.STRING, 'userName', None, None, ), # 8
    (9, TType.I32, 'userRole', None, None, ), # 9
    (10, TType.STRING, 'loginIp', None, None, ), # 10
  )

  def __init__(self, fileFormat=None, fileName=None, requestId=None, method=None, filterParams=None, passWord=None, uuidStr=None, userName=None, userRole=None, loginIp=None,):
    self.fileFormat = fileFormat
    self.fileName = fileName
    self.requestId = requestId
    self.method = method
    self.filterParams = filterParams
    self.passWord = passWord
    self.uuidStr = uuidStr
    self.userName = userName
    self.userRole = userRole
    self.loginIp = loginIp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fileFormat = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fileName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.requestId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.method = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.filterParams = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString().decode('utf-8')
            _val6 = iprot.readString().decode('utf-8')
            self.filterParams[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.passWord = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.uuidStr = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.userName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.userRole = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.loginIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncExportLogReq')
    if self.fileFormat is not None:
      oprot.writeFieldBegin('fileFormat', TType.STRING, 1)
      oprot.writeString(self.fileFormat.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 2)
      oprot.writeString(self.fileName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 3)
      oprot.writeString(self.requestId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.method is not None:
      oprot.writeFieldBegin('method', TType.I32, 4)
      oprot.writeI32(self.method)
      oprot.writeFieldEnd()
    if self.filterParams is not None:
      oprot.writeFieldBegin('filterParams', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.filterParams))
      for kiter7,viter8 in self.filterParams.items():
        oprot.writeString(kiter7.encode('utf-8'))
        oprot.writeString(viter8.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.passWord is not None:
      oprot.writeFieldBegin('passWord', TType.STRING, 6)
      oprot.writeString(self.passWord.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.uuidStr is not None:
      oprot.writeFieldBegin('uuidStr', TType.STRING, 7)
      oprot.writeString(self.uuidStr.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 8)
      oprot.writeString(self.userName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userRole is not None:
      oprot.writeFieldBegin('userRole', TType.I32, 9)
      oprot.writeI32(self.userRole)
      oprot.writeFieldEnd()
    if self.loginIp is not None:
      oprot.writeFieldBegin('loginIp', TType.STRING, 10)
      oprot.writeString(self.loginIp.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fileFormat)
    value = (value * 31) ^ hash(self.fileName)
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.method)
    value = (value * 31) ^ hash(self.filterParams)
    value = (value * 31) ^ hash(self.passWord)
    value = (value * 31) ^ hash(self.uuidStr)
    value = (value * 31) ^ hash(self.userName)
    value = (value * 31) ^ hash(self.userRole)
    value = (value * 31) ^ hash(self.loginIp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncExportLogRes(object):
  """
  Attributes:
   - requestId
   - isFinished
   - data
   - fileName
   - isErr
   - errs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requestId', None, None, ), # 1
    (2, TType.BOOL, 'isFinished', None, None, ), # 2
    (3, TType.STRING, 'data', None, None, ), # 3
    (4, TType.STRING, 'fileName', None, None, ), # 4
    (5, TType.BOOL, 'isErr', None, None, ), # 5
    (6, TType.LIST, 'errs', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, requestId=None, isFinished=None, data=None, fileName=None, isErr=None, errs=None,):
    self.requestId = requestId
    self.isFinished = isFinished
    self.data = data
    self.fileName = fileName
    self.isErr = isErr
    self.errs = errs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requestId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isFinished = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fileName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isErr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.errs = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString().decode('utf-8')
            self.errs.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncExportLogRes')
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 1)
      oprot.writeString(self.requestId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.isFinished is not None:
      oprot.writeFieldBegin('isFinished', TType.BOOL, 2)
      oprot.writeBool(self.isFinished)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 4)
      oprot.writeString(self.fileName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.isErr is not None:
      oprot.writeFieldBegin('isErr', TType.BOOL, 5)
      oprot.writeBool(self.isErr)
      oprot.writeFieldEnd()
    if self.errs is not None:
      oprot.writeFieldBegin('errs', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.errs))
      for iter15 in self.errs:
        oprot.writeString(iter15.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.isFinished)
    value = (value * 31) ^ hash(self.data)
    value = (value * 31) ^ hash(self.fileName)
    value = (value * 31) ^ hash(self.isErr)
    value = (value * 31) ^ hash(self.errs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncExportOverviewRequest(object):
  """
  Attributes:
   - requestId
   - fileFormat
   - timeType
   - isExpress
   - isFX18000
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requestId', None, None, ), # 1
    (2, TType.STRING, 'fileFormat', None, None, ), # 2
    (3, TType.I32, 'timeType', None, None, ), # 3
    (4, TType.I32, 'isExpress', None, None, ), # 4
    (5, TType.I32, 'isFX18000', None, None, ), # 5
    (6, TType.STRUCT, 'user', (ncUser.ttypes.ncUserInfo, ncUser.ttypes.ncUserInfo.thrift_spec), None, ), # 6
  )

  def __init__(self, requestId=None, fileFormat=None, timeType=None, isExpress=None, isFX18000=None, user=None,):
    self.requestId = requestId
    self.fileFormat = fileFormat
    self.timeType = timeType
    self.isExpress = isExpress
    self.isFX18000 = isFX18000
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requestId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fileFormat = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isExpress = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.isFX18000 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.user = ncUser.ttypes.ncUserInfo()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncExportOverviewRequest')
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 1)
      oprot.writeString(self.requestId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.fileFormat is not None:
      oprot.writeFieldBegin('fileFormat', TType.STRING, 2)
      oprot.writeString(self.fileFormat.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timeType is not None:
      oprot.writeFieldBegin('timeType', TType.I32, 3)
      oprot.writeI32(self.timeType)
      oprot.writeFieldEnd()
    if self.isExpress is not None:
      oprot.writeFieldBegin('isExpress', TType.I32, 4)
      oprot.writeI32(self.isExpress)
      oprot.writeFieldEnd()
    if self.isFX18000 is not None:
      oprot.writeFieldBegin('isFX18000', TType.I32, 5)
      oprot.writeI32(self.isFX18000)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 6)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.fileFormat)
    value = (value * 31) ^ hash(self.timeType)
    value = (value * 31) ^ hash(self.isExpress)
    value = (value * 31) ^ hash(self.isFX18000)
    value = (value * 31) ^ hash(self.user)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncExportOverviewRes(object):
  """
  Attributes:
   - requestId
   - isFinished
   - filePath
   - isErr
   - err
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'requestId', None, None, ), # 1
    (2, TType.BOOL, 'isFinished', None, None, ), # 2
    (3, TType.STRING, 'filePath', None, None, ), # 3
    (4, TType.BOOL, 'isErr', None, None, ), # 4
    (5, TType.STRING, 'err', None, None, ), # 5
  )

  def __init__(self, requestId=None, isFinished=None, filePath=None, isErr=None, err=None,):
    self.requestId = requestId
    self.isFinished = isFinished
    self.filePath = filePath
    self.isErr = isErr
    self.err = err

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.requestId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isFinished = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filePath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isErr = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.err = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncExportOverviewRes')
    if self.requestId is not None:
      oprot.writeFieldBegin('requestId', TType.STRING, 1)
      oprot.writeString(self.requestId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.isFinished is not None:
      oprot.writeFieldBegin('isFinished', TType.BOOL, 2)
      oprot.writeBool(self.isFinished)
      oprot.writeFieldEnd()
    if self.filePath is not None:
      oprot.writeFieldBegin('filePath', TType.STRING, 3)
      oprot.writeString(self.filePath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.isErr is not None:
      oprot.writeFieldBegin('isErr', TType.BOOL, 4)
      oprot.writeBool(self.isErr)
      oprot.writeFieldEnd()
    if self.err is not None:
      oprot.writeFieldBegin('err', TType.STRING, 5)
      oprot.writeString(self.err.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requestId)
    value = (value * 31) ^ hash(self.isFinished)
    value = (value * 31) ^ hash(self.filePath)
    value = (value * 31) ^ hash(self.isErr)
    value = (value * 31) ^ hash(self.err)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
