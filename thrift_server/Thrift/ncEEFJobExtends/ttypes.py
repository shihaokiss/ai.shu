#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ncEEFJobBase.ttypes
import ncEEFComm_Var.ttypes
import ncCommonType.ttypes
import ncCommonType_Var.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ncCreateTimePointStatus(object):
  NOT_START = 0
  CREATING = 1
  SUCCESS = 2
  FAILURE = 4

  _VALUES_TO_NAMES = {
    0: "NOT_START",
    1: "CREATING",
    2: "SUCCESS",
    4: "FAILURE",
  }

  _NAMES_TO_VALUES = {
    "NOT_START": 0,
    "CREATING": 1,
    "SUCCESS": 2,
    "FAILURE": 4,
  }

class ncCheckLunMappingStatus(object):
  NOT_FINISH = 0
  SUCCESS = 1
  FAILURE = 2

  _VALUES_TO_NAMES = {
    0: "NOT_FINISH",
    1: "SUCCESS",
    2: "FAILURE",
  }

  _NAMES_TO_VALUES = {
    "NOT_FINISH": 0,
    "SUCCESS": 1,
    "FAILURE": 2,
  }


class ncEEFJobParams(object):
  """
  Attributes:
   - baseInfo
   - jobType
   - jobProperty
   - jobOption
   - needStop
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.STRING, 'jobType', None, None, ), # 2
    (3, TType.LIST, 'jobProperty', (TType.STRUCT,(ncCommonType.ttypes.ncKeyValue, ncCommonType.ttypes.ncKeyValue.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'jobOption', (ncCommonType.ttypes.ncOptions, ncCommonType.ttypes.ncOptions.thrift_spec), None, ), # 4
    None, # 5
    (6, TType.BOOL, 'needStop', None, False, ), # 6
  )

  def __init__(self, baseInfo=None, jobType=None, jobProperty=None, jobOption=None, needStop=thrift_spec[6][4],):
    self.baseInfo = baseInfo
    self.jobType = jobType
    self.jobProperty = jobProperty
    self.jobOption = jobOption
    self.needStop = needStop

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.jobProperty = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncCommonType.ttypes.ncKeyValue()
            _elem5.read(iprot)
            self.jobProperty.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.jobOption = ncCommonType.ttypes.ncOptions()
          self.jobOption.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.needStop = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFJobParams')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.jobType is not None:
      oprot.writeFieldBegin('jobType', TType.STRING, 2)
      oprot.writeString(self.jobType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobProperty is not None:
      oprot.writeFieldBegin('jobProperty', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.jobProperty))
      for iter6 in self.jobProperty:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobOption is not None:
      oprot.writeFieldBegin('jobOption', TType.STRUCT, 4)
      self.jobOption.write(oprot)
      oprot.writeFieldEnd()
    if self.needStop is not None:
      oprot.writeFieldBegin('needStop', TType.BOOL, 6)
      oprot.writeBool(self.needStop)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.jobType)
    value = (value * 31) ^ hash(self.jobProperty)
    value = (value * 31) ^ hash(self.jobOption)
    value = (value * 31) ^ hash(self.needStop)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFJobInfo(object):
  """
  Attributes:
   - execId
   - jobType
   - clientType
   - engineType
   - clientMac
   - jobProperty
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'execId', None, None, ), # 1
    (2, TType.STRING, 'jobType', None, None, ), # 2
    (3, TType.I32, 'clientType', None,     1, ), # 3
    (4, TType.I32, 'engineType', None,     1001, ), # 4
    (5, TType.LIST, 'clientMac', (TType.STRING,None), None, ), # 5
    (6, TType.LIST, 'jobProperty', (TType.STRUCT,(ncCommonType.ttypes.ncKeyValue, ncCommonType.ttypes.ncKeyValue.thrift_spec)), None, ), # 6
  )

  def __init__(self, execId=None, jobType=None, clientType=thrift_spec[3][4], engineType=thrift_spec[4][4], clientMac=None, jobProperty=None,):
    self.execId = execId
    self.jobType = jobType
    self.clientType = clientType
    self.engineType = engineType
    self.clientMac = clientMac
    self.jobProperty = jobProperty

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.execId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.clientType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.engineType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.clientMac = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.clientMac.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.jobProperty = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = ncCommonType.ttypes.ncKeyValue()
            _elem18.read(iprot)
            self.jobProperty.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFJobInfo')
    if self.execId is not None:
      oprot.writeFieldBegin('execId', TType.STRING, 1)
      oprot.writeString(self.execId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobType is not None:
      oprot.writeFieldBegin('jobType', TType.STRING, 2)
      oprot.writeString(self.jobType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.clientType is not None:
      oprot.writeFieldBegin('clientType', TType.I32, 3)
      oprot.writeI32(self.clientType)
      oprot.writeFieldEnd()
    if self.engineType is not None:
      oprot.writeFieldBegin('engineType', TType.I32, 4)
      oprot.writeI32(self.engineType)
      oprot.writeFieldEnd()
    if self.clientMac is not None:
      oprot.writeFieldBegin('clientMac', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.clientMac))
      for iter19 in self.clientMac:
        oprot.writeString(iter19.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobProperty is not None:
      oprot.writeFieldBegin('jobProperty', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.jobProperty))
      for iter20 in self.jobProperty:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.execId)
    value = (value * 31) ^ hash(self.jobType)
    value = (value * 31) ^ hash(self.clientType)
    value = (value * 31) ^ hash(self.engineType)
    value = (value * 31) ^ hash(self.clientMac)
    value = (value * 31) ^ hash(self.jobProperty)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncExecBody(object):
  """
  Attributes:
   - execSpeed
   - completedSize
   - execInfo
   - gns
   - remainSize
   - sendSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'execSpeed', None, None, ), # 1
    (2, TType.I64, 'completedSize', None, 0, ), # 2
    (3, TType.STRING, 'execInfo', None, None, ), # 3
    (4, TType.STRING, 'gns', None, "", ), # 4
    (5, TType.I64, 'remainSize', None, 0, ), # 5
    (6, TType.I64, 'sendSize', None, 0, ), # 6
  )

  def __init__(self, execSpeed=None, completedSize=thrift_spec[2][4], execInfo=None, gns=thrift_spec[4][4], remainSize=thrift_spec[5][4], sendSize=thrift_spec[6][4],):
    self.execSpeed = execSpeed
    self.completedSize = completedSize
    self.execInfo = execInfo
    self.gns = gns
    self.remainSize = remainSize
    self.sendSize = sendSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.execSpeed = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.completedSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.execInfo = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.gns = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.remainSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.sendSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncExecBody')
    if self.execSpeed is not None:
      oprot.writeFieldBegin('execSpeed', TType.STRING, 1)
      oprot.writeString(self.execSpeed.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.completedSize is not None:
      oprot.writeFieldBegin('completedSize', TType.I64, 2)
      oprot.writeI64(self.completedSize)
      oprot.writeFieldEnd()
    if self.execInfo is not None:
      oprot.writeFieldBegin('execInfo', TType.STRING, 3)
      oprot.writeString(self.execInfo.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.gns is not None:
      oprot.writeFieldBegin('gns', TType.STRING, 4)
      oprot.writeString(self.gns.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.remainSize is not None:
      oprot.writeFieldBegin('remainSize', TType.I64, 5)
      oprot.writeI64(self.remainSize)
      oprot.writeFieldEnd()
    if self.sendSize is not None:
      oprot.writeFieldBegin('sendSize', TType.I64, 6)
      oprot.writeI64(self.sendSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.execSpeed)
    value = (value * 31) ^ hash(self.completedSize)
    value = (value * 31) ^ hash(self.execInfo)
    value = (value * 31) ^ hash(self.gns)
    value = (value * 31) ^ hash(self.remainSize)
    value = (value * 31) ^ hash(self.sendSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFExecProgress(object):
  """
  Attributes:
   - baseInfo
   - execBodyInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'execBodyInfo', (ncExecBody, ncExecBody.thrift_spec), None, ), # 2
  )

  def __init__(self, baseInfo=None, execBodyInfo=None,):
    self.baseInfo = baseInfo
    self.execBodyInfo = execBodyInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.execBodyInfo = ncExecBody()
          self.execBodyInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFExecProgress')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.execBodyInfo is not None:
      oprot.writeFieldBegin('execBodyInfo', TType.STRUCT, 2)
      self.execBodyInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.execBodyInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFExecReport(object):
  """
  Attributes:
   - baseInfo
   - totalSize
   - sendSize
   - tpGNS
   - actualBakType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.I64, 'totalSize', None, 0, ), # 2
    (3, TType.I64, 'sendSize', None, 0, ), # 3
    (4, TType.STRING, 'tpGNS', None, None, ), # 4
    (5, TType.STRING, 'actualBakType', None, None, ), # 5
  )

  def __init__(self, baseInfo=None, totalSize=thrift_spec[2][4], sendSize=thrift_spec[3][4], tpGNS=None, actualBakType=None,):
    self.baseInfo = baseInfo
    self.totalSize = totalSize
    self.sendSize = sendSize
    self.tpGNS = tpGNS
    self.actualBakType = actualBakType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.totalSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.sendSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tpGNS = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.actualBakType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFExecReport')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.totalSize is not None:
      oprot.writeFieldBegin('totalSize', TType.I64, 2)
      oprot.writeI64(self.totalSize)
      oprot.writeFieldEnd()
    if self.sendSize is not None:
      oprot.writeFieldBegin('sendSize', TType.I64, 3)
      oprot.writeI64(self.sendSize)
      oprot.writeFieldEnd()
    if self.tpGNS is not None:
      oprot.writeFieldBegin('tpGNS', TType.STRING, 4)
      oprot.writeString(self.tpGNS.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.actualBakType is not None:
      oprot.writeFieldBegin('actualBakType', TType.STRING, 5)
      oprot.writeString(self.actualBakType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.totalSize)
    value = (value * 31) ^ hash(self.sendSize)
    value = (value * 31) ^ hash(self.tpGNS)
    value = (value * 31) ^ hash(self.actualBakType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFObjectBaseAtr(object):
  """
  Attributes:
   - baseInfo
   - sourceClusterId
   - sourceAuthUser
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.STRING, 'sourceClusterId', None, None, ), # 2
    (3, TType.STRING, 'sourceAuthUser', None, None, ), # 3
  )

  def __init__(self, baseInfo=None, sourceClusterId=None, sourceAuthUser=None,):
    self.baseInfo = baseInfo
    self.sourceClusterId = sourceClusterId
    self.sourceAuthUser = sourceAuthUser

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sourceClusterId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sourceAuthUser = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFObjectBaseAtr')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.sourceClusterId is not None:
      oprot.writeFieldBegin('sourceClusterId', TType.STRING, 2)
      oprot.writeString(self.sourceClusterId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.sourceAuthUser is not None:
      oprot.writeFieldBegin('sourceAuthUser', TType.STRING, 3)
      oprot.writeString(self.sourceAuthUser.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.sourceClusterId)
    value = (value * 31) ^ hash(self.sourceAuthUser)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFObjectReportsAtr(object):
  """
  Attributes:
   - is_status
   - status
   - is_messgae
   - execLog
   - is_report
   - execBodyInfo
   - actualBakType
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'is_status', None, False, ), # 1
    (2, TType.I32, 'status', None, None, ), # 2
    (3, TType.BOOL, 'is_messgae', None, False, ), # 3
    (4, TType.STRUCT, 'execLog', (ncEEFJobBase.ttypes.ncExecLog, ncEEFJobBase.ttypes.ncExecLog.thrift_spec), None, ), # 4
    (5, TType.BOOL, 'is_report', None, False, ), # 5
    (6, TType.STRUCT, 'execBodyInfo', (ncExecBody, ncExecBody.thrift_spec), None, ), # 6
    (7, TType.STRING, 'actualBakType', None, None, ), # 7
  )

  def __init__(self, is_status=thrift_spec[1][4], status=None, is_messgae=thrift_spec[3][4], execLog=None, is_report=thrift_spec[5][4], execBodyInfo=None, actualBakType=None,):
    self.is_status = is_status
    self.status = status
    self.is_messgae = is_messgae
    self.execLog = execLog
    self.is_report = is_report
    self.execBodyInfo = execBodyInfo
    self.actualBakType = actualBakType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_status = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_messgae = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.execLog = ncEEFJobBase.ttypes.ncExecLog()
          self.execLog.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_report = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.execBodyInfo = ncExecBody()
          self.execBodyInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.actualBakType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFObjectReportsAtr')
    if self.is_status is not None:
      oprot.writeFieldBegin('is_status', TType.BOOL, 1)
      oprot.writeBool(self.is_status)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.is_messgae is not None:
      oprot.writeFieldBegin('is_messgae', TType.BOOL, 3)
      oprot.writeBool(self.is_messgae)
      oprot.writeFieldEnd()
    if self.execLog is not None:
      oprot.writeFieldBegin('execLog', TType.STRUCT, 4)
      self.execLog.write(oprot)
      oprot.writeFieldEnd()
    if self.is_report is not None:
      oprot.writeFieldBegin('is_report', TType.BOOL, 5)
      oprot.writeBool(self.is_report)
      oprot.writeFieldEnd()
    if self.execBodyInfo is not None:
      oprot.writeFieldBegin('execBodyInfo', TType.STRUCT, 6)
      self.execBodyInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.actualBakType is not None:
      oprot.writeFieldBegin('actualBakType', TType.STRING, 7)
      oprot.writeString(self.actualBakType.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.is_status)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.is_messgae)
    value = (value * 31) ^ hash(self.execLog)
    value = (value * 31) ^ hash(self.is_report)
    value = (value * 31) ^ hash(self.execBodyInfo)
    value = (value * 31) ^ hash(self.actualBakType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFJobReports(object):
  """
  Attributes:
   - exBaseInfo
   - jobId
   - jobName
   - jobReport
   - tpReportMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exBaseInfo', (ncEEFObjectBaseAtr, ncEEFObjectBaseAtr.thrift_spec), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
    (3, TType.STRING, 'jobName', None, None, ), # 3
    (4, TType.STRUCT, 'jobReport', (ncEEFObjectReportsAtr, ncEEFObjectReportsAtr.thrift_spec), None, ), # 4
    (5, TType.MAP, 'tpReportMap', (TType.STRING,None,TType.STRUCT,(ncEEFObjectReportsAtr, ncEEFObjectReportsAtr.thrift_spec)), None, ), # 5
  )

  def __init__(self, exBaseInfo=None, jobId=None, jobName=None, jobReport=None, tpReportMap=None,):
    self.exBaseInfo = exBaseInfo
    self.jobId = jobId
    self.jobName = jobName
    self.jobReport = jobReport
    self.tpReportMap = tpReportMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exBaseInfo = ncEEFObjectBaseAtr()
          self.exBaseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.jobName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.jobReport = ncEEFObjectReportsAtr()
          self.jobReport.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.tpReportMap = {}
          (_ktype22, _vtype23, _size21 ) = iprot.readMapBegin()
          for _i25 in xrange(_size21):
            _key26 = iprot.readString().decode('utf-8')
            _val27 = ncEEFObjectReportsAtr()
            _val27.read(iprot)
            self.tpReportMap[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFJobReports')
    if self.exBaseInfo is not None:
      oprot.writeFieldBegin('exBaseInfo', TType.STRUCT, 1)
      self.exBaseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 3)
      oprot.writeString(self.jobName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobReport is not None:
      oprot.writeFieldBegin('jobReport', TType.STRUCT, 4)
      self.jobReport.write(oprot)
      oprot.writeFieldEnd()
    if self.tpReportMap is not None:
      oprot.writeFieldBegin('tpReportMap', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.tpReportMap))
      for kiter28,viter29 in self.tpReportMap.items():
        oprot.writeString(kiter28.encode('utf-8'))
        viter29.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exBaseInfo)
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.jobName)
    value = (value * 31) ^ hash(self.jobReport)
    value = (value * 31) ^ hash(self.tpReportMap)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFExtraMetadata(object):
  """
  Attributes:
   - jobId
   - timepoint
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
    (2, TType.I64, 'timepoint', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, jobId=None, timepoint=None, key=None, value=None,):
    self.jobId = jobId
    self.timepoint = timepoint
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timepoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFExtraMetadata')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timepoint is not None:
      oprot.writeFieldBegin('timepoint', TType.I64, 2)
      oprot.writeI64(self.timepoint)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.timepoint)
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmLunInfo(object):
  """
  基本卷信息

  Attributes:
   - lunId
   - totalSize
   - usedSize
   - fullPath
   - lunConfig
   - wwn
   - volumeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'lunId', None, None, ), # 1
    (2, TType.I64, 'totalSize', None, None, ), # 2
    (3, TType.I64, 'usedSize', None, None, ), # 3
    (4, TType.STRING, 'fullPath', None, None, ), # 4
    (5, TType.STRING, 'lunConfig', None, None, ), # 5
    (6, TType.STRING, 'wwn', None, None, ), # 6
    (7, TType.STRING, 'volumeId', None, None, ), # 7
  )

  def __init__(self, lunId=None, totalSize=None, usedSize=None, fullPath=None, lunConfig=None, wwn=None, volumeId=None,):
    self.lunId = lunId
    self.totalSize = totalSize
    self.usedSize = usedSize
    self.fullPath = fullPath
    self.lunConfig = lunConfig
    self.wwn = wwn
    self.volumeId = volumeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.lunId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.totalSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.usedSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fullPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.lunConfig = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.wwn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.volumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmLunInfo')
    if self.lunId is not None:
      oprot.writeFieldBegin('lunId', TType.STRING, 1)
      oprot.writeString(self.lunId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.totalSize is not None:
      oprot.writeFieldBegin('totalSize', TType.I64, 2)
      oprot.writeI64(self.totalSize)
      oprot.writeFieldEnd()
    if self.usedSize is not None:
      oprot.writeFieldBegin('usedSize', TType.I64, 3)
      oprot.writeI64(self.usedSize)
      oprot.writeFieldEnd()
    if self.fullPath is not None:
      oprot.writeFieldBegin('fullPath', TType.STRING, 4)
      oprot.writeString(self.fullPath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.lunConfig is not None:
      oprot.writeFieldBegin('lunConfig', TType.STRING, 5)
      oprot.writeString(self.lunConfig.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.wwn is not None:
      oprot.writeFieldBegin('wwn', TType.STRING, 6)
      oprot.writeString(self.wwn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.volumeId is not None:
      oprot.writeFieldBegin('volumeId', TType.STRING, 7)
      oprot.writeString(self.volumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunId)
    value = (value * 31) ^ hash(self.totalSize)
    value = (value * 31) ^ hash(self.usedSize)
    value = (value * 31) ^ hash(self.fullPath)
    value = (value * 31) ^ hash(self.lunConfig)
    value = (value * 31) ^ hash(self.wwn)
    value = (value * 31) ^ hash(self.volumeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmLunInfoLists(object):
  """
  基本卷列表

  Attributes:
   - cdmLunInfoLists
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmLunInfoLists', (TType.STRUCT,(ncEEFCdmLunInfo, ncEEFCdmLunInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, cdmLunInfoLists=None, jobId=None,):
    self.cdmLunInfoLists = cdmLunInfoLists
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmLunInfoLists = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = ncEEFCdmLunInfo()
            _elem35.read(iprot)
            self.cdmLunInfoLists.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmLunInfoLists')
    if self.cdmLunInfoLists is not None:
      oprot.writeFieldBegin('cdmLunInfoLists', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmLunInfoLists))
      for iter36 in self.cdmLunInfoLists:
        iter36.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmLunInfoLists)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmUpdateLunInfo(object):
  """
  更新基本卷信息

  Attributes:
   - lunId
   - usedSize
   - fullPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'lunId', None, None, ), # 1
    (2, TType.I64, 'usedSize', None, None, ), # 2
    (3, TType.STRING, 'fullPath', None, None, ), # 3
  )

  def __init__(self, lunId=None, usedSize=None, fullPath=None,):
    self.lunId = lunId
    self.usedSize = usedSize
    self.fullPath = fullPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.lunId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.usedSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.fullPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmUpdateLunInfo')
    if self.lunId is not None:
      oprot.writeFieldBegin('lunId', TType.STRING, 1)
      oprot.writeString(self.lunId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.usedSize is not None:
      oprot.writeFieldBegin('usedSize', TType.I64, 2)
      oprot.writeI64(self.usedSize)
      oprot.writeFieldEnd()
    if self.fullPath is not None:
      oprot.writeFieldBegin('fullPath', TType.STRING, 3)
      oprot.writeString(self.fullPath.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.lunId)
    value = (value * 31) ^ hash(self.usedSize)
    value = (value * 31) ^ hash(self.fullPath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmUpdateLunInfoLists(object):
  """
  更新卷信息返回体

  Attributes:
   - cdmUpdateLunInfoLists
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmUpdateLunInfoLists', (TType.STRUCT,(ncEEFCdmUpdateLunInfo, ncEEFCdmUpdateLunInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, cdmUpdateLunInfoLists=None, jobId=None,):
    self.cdmUpdateLunInfoLists = cdmUpdateLunInfoLists
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmUpdateLunInfoLists = []
          (_etype40, _size37) = iprot.readListBegin()
          for _i41 in xrange(_size37):
            _elem42 = ncEEFCdmUpdateLunInfo()
            _elem42.read(iprot)
            self.cdmUpdateLunInfoLists.append(_elem42)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmUpdateLunInfoLists')
    if self.cdmUpdateLunInfoLists is not None:
      oprot.writeFieldBegin('cdmUpdateLunInfoLists', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmUpdateLunInfoLists))
      for iter43 in self.cdmUpdateLunInfoLists:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmUpdateLunInfoLists)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCreateLun(object):
  """
  Attributes:
   - jobId
   - size
   - volumeAppType
   - mountPoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
    (2, TType.I64, 'size', None, None, ), # 2
    (3, TType.I64, 'volumeAppType', None, None, ), # 3
    (4, TType.STRING, 'mountPoint', None, None, ), # 4
  )

  def __init__(self, jobId=None, size=None, volumeAppType=None, mountPoint=None,):
    self.jobId = jobId
    self.size = size
    self.volumeAppType = volumeAppType
    self.mountPoint = mountPoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.size = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.volumeAppType = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mountPoint = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCreateLun')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 2)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.volumeAppType is not None:
      oprot.writeFieldBegin('volumeAppType', TType.I64, 3)
      oprot.writeI64(self.volumeAppType)
      oprot.writeFieldEnd()
    if self.mountPoint is not None:
      oprot.writeFieldBegin('mountPoint', TType.STRING, 4)
      oprot.writeString(self.mountPoint.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.volumeAppType)
    value = (value * 31) ^ hash(self.mountPoint)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFOpenStackAction(object):
  """
  OpenStack Action Reqeust

  Attributes:
   - clientMac
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientMac', None, None, ), # 1
    (2, TType.STRING, 'request', None, None, ), # 2
  )

  def __init__(self, clientMac=None, request=None,):
    self.clientMac = clientMac
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientMac = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.request = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFOpenStackAction')
    if self.clientMac is not None:
      oprot.writeFieldBegin('clientMac', TType.STRING, 1)
      oprot.writeString(self.clientMac.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRING, 2)
      oprot.writeString(self.request.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientMac)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFOpenStackActionResult(object):
  """
  Attributes:
   - result
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'result', None, None, ), # 1
  )

  def __init__(self, result=None,):
    self.result = result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.result = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFOpenStackActionResult')
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRING, 1)
      oprot.writeString(self.result.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.result)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmRestoreVmIds(object):
  """
  Attributes:
   - vmIds
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmIds', None, None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, vmIds=None, jobId=None,):
    self.vmIds = vmIds
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmIds = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmRestoreVmIds')
    if self.vmIds is not None:
      oprot.writeFieldBegin('vmIds', TType.STRING, 1)
      oprot.writeString(self.vmIds.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmIds)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCdmImageCustomer(object):
  """
  Attributes:
   - imageId
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'imageId', None, None, ), # 1
    (2, TType.STRING, 'customer', None, None, ), # 2
  )

  def __init__(self, imageId=None, customer=None,):
    self.imageId = imageId
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.imageId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCdmImageCustomer')
    if self.imageId is not None:
      oprot.writeFieldBegin('imageId', TType.STRING, 1)
      oprot.writeString(self.imageId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 2)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.imageId)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFTimePoints(object):
  """
  Attributes:
   - baseInfo
   - timepoint
   - isDataFinished
   - status
   - totalSize
   - sendSize
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.I64, 'timepoint', None, None, ), # 2
    (3, TType.BOOL, 'isDataFinished', None, False, ), # 3
    (4, TType.I32, 'status', None, None, ), # 4
    (5, TType.I64, 'totalSize', None, 0, ), # 5
    (6, TType.I64, 'sendSize', None, 0, ), # 6
    (7, TType.STRING, 'customer', None, None, ), # 7
  )

  def __init__(self, baseInfo=None, timepoint=None, isDataFinished=thrift_spec[3][4], status=None, totalSize=thrift_spec[5][4], sendSize=thrift_spec[6][4], customer=None,):
    self.baseInfo = baseInfo
    self.timepoint = timepoint
    self.isDataFinished = isDataFinished
    self.status = status
    self.totalSize = totalSize
    self.sendSize = sendSize
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timepoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isDataFinished = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.totalSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.sendSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFTimePoints')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.timepoint is not None:
      oprot.writeFieldBegin('timepoint', TType.I64, 2)
      oprot.writeI64(self.timepoint)
      oprot.writeFieldEnd()
    if self.isDataFinished is not None:
      oprot.writeFieldBegin('isDataFinished', TType.BOOL, 3)
      oprot.writeBool(self.isDataFinished)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.totalSize is not None:
      oprot.writeFieldBegin('totalSize', TType.I64, 5)
      oprot.writeI64(self.totalSize)
      oprot.writeFieldEnd()
    if self.sendSize is not None:
      oprot.writeFieldBegin('sendSize', TType.I64, 6)
      oprot.writeI64(self.sendSize)
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 7)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.timepoint)
    value = (value * 31) ^ hash(self.isDataFinished)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.totalSize)
    value = (value * 31) ^ hash(self.sendSize)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFHanaRedundancy(object):
  """
  Attributes:
   - baseInfo
   - redundancy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'baseInfo', (ncEEFJobBase.ttypes.ncEEFBase, ncEEFJobBase.ttypes.ncEEFBase.thrift_spec), None, ), # 1
    (2, TType.STRING, 'redundancy', None, None, ), # 2
  )

  def __init__(self, baseInfo=None, redundancy=None,):
    self.baseInfo = baseInfo
    self.redundancy = redundancy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.baseInfo = ncEEFJobBase.ttypes.ncEEFBase()
          self.baseInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.redundancy = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFHanaRedundancy')
    if self.baseInfo is not None:
      oprot.writeFieldBegin('baseInfo', TType.STRUCT, 1)
      self.baseInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.redundancy is not None:
      oprot.writeFieldBegin('redundancy', TType.STRING, 2)
      oprot.writeString(self.redundancy.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseInfo)
    value = (value * 31) ^ hash(self.redundancy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFDeleteLun(object):
  """
  Attributes:
   - isSuccess
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'isSuccess', None, None, ), # 1
  )

  def __init__(self, isSuccess=None,):
    self.isSuccess = isSuccess

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isSuccess = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFDeleteLun')
    if self.isSuccess is not None:
      oprot.writeFieldBegin('isSuccess', TType.BOOL, 1)
      oprot.writeBool(self.isSuccess)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isSuccess)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncMongodbBack(object):
  """
  Attributes:
   - execId
   - stopBlancer
   - configBackup
   - shardBackup
   - timePoint
   - clientNum
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'execId', None, None, ), # 1
    (2, TType.BOOL, 'stopBlancer', None, None, ), # 2
    (3, TType.BOOL, 'configBackup', None, None, ), # 3
    (4, TType.I32, 'shardBackup', None, None, ), # 4
    (5, TType.I64, 'timePoint', None, None, ), # 5
    (6, TType.I32, 'clientNum', None, None, ), # 6
    (7, TType.BOOL, 'status', None, None, ), # 7
  )

  def __init__(self, execId=None, stopBlancer=None, configBackup=None, shardBackup=None, timePoint=None, clientNum=None, status=None,):
    self.execId = execId
    self.stopBlancer = stopBlancer
    self.configBackup = configBackup
    self.shardBackup = shardBackup
    self.timePoint = timePoint
    self.clientNum = clientNum
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.execId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.stopBlancer = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.configBackup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.shardBackup = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timePoint = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.clientNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.status = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncMongodbBack')
    if self.execId is not None:
      oprot.writeFieldBegin('execId', TType.STRING, 1)
      oprot.writeString(self.execId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.stopBlancer is not None:
      oprot.writeFieldBegin('stopBlancer', TType.BOOL, 2)
      oprot.writeBool(self.stopBlancer)
      oprot.writeFieldEnd()
    if self.configBackup is not None:
      oprot.writeFieldBegin('configBackup', TType.BOOL, 3)
      oprot.writeBool(self.configBackup)
      oprot.writeFieldEnd()
    if self.shardBackup is not None:
      oprot.writeFieldBegin('shardBackup', TType.I32, 4)
      oprot.writeI32(self.shardBackup)
      oprot.writeFieldEnd()
    if self.timePoint is not None:
      oprot.writeFieldBegin('timePoint', TType.I64, 5)
      oprot.writeI64(self.timePoint)
      oprot.writeFieldEnd()
    if self.clientNum is not None:
      oprot.writeFieldBegin('clientNum', TType.I32, 6)
      oprot.writeI32(self.clientNum)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.BOOL, 7)
      oprot.writeBool(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.execId)
    value = (value * 31) ^ hash(self.stopBlancer)
    value = (value * 31) ^ hash(self.configBackup)
    value = (value * 31) ^ hash(self.shardBackup)
    value = (value * 31) ^ hash(self.timePoint)
    value = (value * 31) ^ hash(self.clientNum)
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCreateTimePoint(object):
  """
  Attributes:
   - timePointStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'timePointStatus', None,     0, ), # 1
  )

  def __init__(self, timePointStatus=thrift_spec[1][4],):
    self.timePointStatus = timePointStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.timePointStatus = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCreateTimePoint')
    if self.timePointStatus is not None:
      oprot.writeFieldBegin('timePointStatus', TType.I32, 1)
      oprot.writeI32(self.timePointStatus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timePointStatus)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFBaseLunInfo(object):
  """
  Attributes:
   - id
   - uuid
   - poolType
   - wwn
   - poolId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'uuid', None, None, ), # 2
    (3, TType.I32, 'poolType', None, None, ), # 3
    (4, TType.STRING, 'wwn', None, None, ), # 4
    (5, TType.STRING, 'poolId', None, None, ), # 5
  )

  def __init__(self, id=None, uuid=None, poolType=None, wwn=None, poolId=None,):
    self.id = id
    self.uuid = uuid
    self.poolType = poolType
    self.wwn = wwn
    self.poolId = poolId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.wwn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFBaseLunInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 2)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 3)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    if self.wwn is not None:
      oprot.writeFieldBegin('wwn', TType.STRING, 4)
      oprot.writeString(self.wwn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 5)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.poolType)
    value = (value * 31) ^ hash(self.wwn)
    value = (value * 31) ^ hash(self.poolId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFBaseLunInfoLists(object):
  """
  Attributes:
   - cdmBaseLunInfoLists
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmBaseLunInfoLists', (TType.STRUCT,(ncEEFBaseLunInfo, ncEEFBaseLunInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, cdmBaseLunInfoLists=None,):
    self.cdmBaseLunInfoLists = cdmBaseLunInfoLists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmBaseLunInfoLists = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = ncEEFBaseLunInfo()
            _elem49.read(iprot)
            self.cdmBaseLunInfoLists.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFBaseLunInfoLists')
    if self.cdmBaseLunInfoLists is not None:
      oprot.writeFieldBegin('cdmBaseLunInfoLists', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmBaseLunInfoLists))
      for iter50 in self.cdmBaseLunInfoLists:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmBaseLunInfoLists)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCreateLunMapping(object):
  """
  Attributes:
   - cdmBaseLunInfoLists
   - jobId
   - size
   - execId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmBaseLunInfoLists', (TType.STRUCT,(ncEEFBaseLunInfo, ncEEFBaseLunInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
    (3, TType.I64, 'size', None, None, ), # 3
    (4, TType.STRING, 'execId', None, None, ), # 4
  )

  def __init__(self, cdmBaseLunInfoLists=None, jobId=None, size=None, execId=None,):
    self.cdmBaseLunInfoLists = cdmBaseLunInfoLists
    self.jobId = jobId
    self.size = size
    self.execId = execId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmBaseLunInfoLists = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = ncEEFBaseLunInfo()
            _elem56.read(iprot)
            self.cdmBaseLunInfoLists.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.size = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.execId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCreateLunMapping')
    if self.cdmBaseLunInfoLists is not None:
      oprot.writeFieldBegin('cdmBaseLunInfoLists', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmBaseLunInfoLists))
      for iter57 in self.cdmBaseLunInfoLists:
        iter57.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 3)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.execId is not None:
      oprot.writeFieldBegin('execId', TType.STRING, 4)
      oprot.writeString(self.execId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmBaseLunInfoLists)
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.execId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFDeleteBaseLunInfo(object):
  """
  Attributes:
   - volumeId
   - volumeType
   - errorMgm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volumeId', None, None, ), # 1
    (2, TType.I32, 'volumeType', None, None, ), # 2
    (3, TType.STRING, 'errorMgm', None, None, ), # 3
  )

  def __init__(self, volumeId=None, volumeType=None, errorMgm=None,):
    self.volumeId = volumeId
    self.volumeType = volumeType
    self.errorMgm = errorMgm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volumeType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.errorMgm = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFDeleteBaseLunInfo')
    if self.volumeId is not None:
      oprot.writeFieldBegin('volumeId', TType.STRING, 1)
      oprot.writeString(self.volumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.volumeType is not None:
      oprot.writeFieldBegin('volumeType', TType.I32, 2)
      oprot.writeI32(self.volumeType)
      oprot.writeFieldEnd()
    if self.errorMgm is not None:
      oprot.writeFieldBegin('errorMgm', TType.STRING, 3)
      oprot.writeString(self.errorMgm.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volumeId)
    value = (value * 31) ^ hash(self.volumeType)
    value = (value * 31) ^ hash(self.errorMgm)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFDeleteLunMapping(object):
  """
  Attributes:
   - cdmDeleteLunInfoLists
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cdmDeleteLunInfoLists', (TType.STRUCT,(ncEEFDeleteBaseLunInfo, ncEEFDeleteBaseLunInfo.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, cdmDeleteLunInfoLists=None, jobId=None,):
    self.cdmDeleteLunInfoLists = cdmDeleteLunInfoLists
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cdmDeleteLunInfoLists = []
          (_etype61, _size58) = iprot.readListBegin()
          for _i62 in xrange(_size58):
            _elem63 = ncEEFDeleteBaseLunInfo()
            _elem63.read(iprot)
            self.cdmDeleteLunInfoLists.append(_elem63)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFDeleteLunMapping')
    if self.cdmDeleteLunInfoLists is not None:
      oprot.writeFieldBegin('cdmDeleteLunInfoLists', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmDeleteLunInfoLists))
      for iter64 in self.cdmDeleteLunInfoLists:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cdmDeleteLunInfoLists)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCheckLunMapping(object):
  """
  Attributes:
   - jobId
   - execId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
    (2, TType.STRING, 'execId', None, None, ), # 2
  )

  def __init__(self, jobId=None, execId=None,):
    self.jobId = jobId
    self.execId = execId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.execId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCheckLunMapping')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.execId is not None:
      oprot.writeFieldBegin('execId', TType.STRING, 2)
      oprot.writeString(self.execId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.execId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCheckLunMappingResponse(object):
  """
  Attributes:
   - finished
   - cdmLunMapInfos
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'finished', None, None, ), # 1
    (2, TType.LIST, 'cdmLunMapInfos', (TType.STRUCT,(ncEEFCdmLunInfo, ncEEFCdmLunInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, finished=None, cdmLunMapInfos=None,):
    self.finished = finished
    self.cdmLunMapInfos = cdmLunMapInfos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.finished = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.cdmLunMapInfos = []
          (_etype68, _size65) = iprot.readListBegin()
          for _i69 in xrange(_size65):
            _elem70 = ncEEFCdmLunInfo()
            _elem70.read(iprot)
            self.cdmLunMapInfos.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCheckLunMappingResponse')
    if self.finished is not None:
      oprot.writeFieldBegin('finished', TType.I32, 1)
      oprot.writeI32(self.finished)
      oprot.writeFieldEnd()
    if self.cdmLunMapInfos is not None:
      oprot.writeFieldBegin('cdmLunMapInfos', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmLunMapInfos))
      for iter71 in self.cdmLunMapInfos:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.finished)
    value = (value * 31) ^ hash(self.cdmLunMapInfos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCheckDeleteLunMappingResponse(object):
  """
  Attributes:
   - finished
   - cdmDeleteLunInfoLists
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'finished', None, None, ), # 1
    (2, TType.LIST, 'cdmDeleteLunInfoLists', (TType.STRUCT,(ncEEFDeleteBaseLunInfo, ncEEFDeleteBaseLunInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, finished=None, cdmDeleteLunInfoLists=None,):
    self.finished = finished
    self.cdmDeleteLunInfoLists = cdmDeleteLunInfoLists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.finished = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.cdmDeleteLunInfoLists = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = ncEEFDeleteBaseLunInfo()
            _elem77.read(iprot)
            self.cdmDeleteLunInfoLists.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCheckDeleteLunMappingResponse')
    if self.finished is not None:
      oprot.writeFieldBegin('finished', TType.I32, 1)
      oprot.writeI32(self.finished)
      oprot.writeFieldEnd()
    if self.cdmDeleteLunInfoLists is not None:
      oprot.writeFieldBegin('cdmDeleteLunInfoLists', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.cdmDeleteLunInfoLists))
      for iter78 in self.cdmDeleteLunInfoLists:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.finished)
    value = (value * 31) ^ hash(self.cdmDeleteLunInfoLists)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncUpdateJobDatasource(object):
  """
  Attributes:
   - jobId
   - oldFullpath
   - newFullpath
   - reply
   - disPath
   - uuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
    (2, TType.STRING, 'oldFullpath', None, None, ), # 2
    (3, TType.STRING, 'newFullpath', None, None, ), # 3
    (4, TType.STRING, 'reply', None, None, ), # 4
    (5, TType.STRING, 'disPath', None, None, ), # 5
    (6, TType.STRING, 'uuid', None, None, ), # 6
  )

  def __init__(self, jobId=None, oldFullpath=None, newFullpath=None, reply=None, disPath=None, uuid=None,):
    self.jobId = jobId
    self.oldFullpath = oldFullpath
    self.newFullpath = newFullpath
    self.reply = reply
    self.disPath = disPath
    self.uuid = uuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.oldFullpath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newFullpath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.reply = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.disPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncUpdateJobDatasource')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.oldFullpath is not None:
      oprot.writeFieldBegin('oldFullpath', TType.STRING, 2)
      oprot.writeString(self.oldFullpath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.newFullpath is not None:
      oprot.writeFieldBegin('newFullpath', TType.STRING, 3)
      oprot.writeString(self.newFullpath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.reply is not None:
      oprot.writeFieldBegin('reply', TType.STRING, 4)
      oprot.writeString(self.reply.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.disPath is not None:
      oprot.writeFieldBegin('disPath', TType.STRING, 5)
      oprot.writeString(self.disPath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 6)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    value = (value * 31) ^ hash(self.oldFullpath)
    value = (value * 31) ^ hash(self.newFullpath)
    value = (value * 31) ^ hash(self.reply)
    value = (value * 31) ^ hash(self.disPath)
    value = (value * 31) ^ hash(self.uuid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
