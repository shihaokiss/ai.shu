#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def microprobe(self):
    """
    服务探针，测试服务可用性
    @ throw ncException
    """
    pass

  def get_all_jobs(self):
    """
    获取所有任务

    @return 任务对象列表
    """
    pass

  def remove_all_jobs_by_client_ids(self, clientIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - clientIds
    """
    pass

  def get_all_cdp_job_for_ams(self):
    """
    获取当前所有的实时复制任务，推送给AMS

    @return 任务对象列表
    """
    pass

  def get_all_cdp_jobInstance_for_ams(self):
    """
    获取当前所有的实时复制任务的执行记录，推送给AMS

    @return 任务对象列表
    """
    pass

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    pass

  def has_running_job_on_client(self, clientId):
    """
    *  客户端上时候有正则运行的任务
       @ return True:有正在运行的任务, False： 没有正在运行的任务
    *

    Parameters:
     - clientId
    """
    pass

  def is_exists_running_job_on_client(self, clientId):
    """
    *  客户端上是否存在正则运行的任务
       @ return True:存在正在运行的任务, False： 不存在正在运行的任务
    *

    Parameters:
     - clientId
    """
    pass

  def cdp_backup_init_volumes(self, request_json):
    """
    初始化基础卷并创建日志卷，服务端调用


    Parameters:
     - request_json
    """
    pass

  def cdp_backup_on_log_volume_formatted(self, jobId):
    """
    *  C++调用，客户端格式化日志卷后，回调用此函数通知服务端此任务日志卷已格式化
       @ return True:成功, False：失败,客户端抛出异常，结束任务流程
    *

    Parameters:
     - jobId
    """
    pass

  def cdp_backup_mount_log_volume(self, jobId):
    """
    *  挂载日志卷，需在存储池节点IP上调用，服务端调用
       @ return dev: 日志卷设备名
    *

    Parameters:
     - jobId
    """
    pass

  def cdp_backup_clean_base_volumes(self, jobId):
    """
    *  删除任务基础卷，删除任务时使用
       @ return : 0: 成功
    *

    Parameters:
     - jobId
    """
    pass

  def cdp_backup_on_reboot_recheck(self, jobId):
    """
    *  重启服务器时基础卷映射丢失，日志卷挂载丢失
       所以在服务启动时调用此接口检测并重新挂载
       @ return : 0: 成功
    *

    Parameters:
     - jobId
    """
    pass

  def cdp_backup_update_devs(self, jobId):
    """
    *  更新设备名，需在存储池节点IP上调用，服务端调用
       @ return : 0: 成功  1:设备未就绪
    *

    Parameters:
     - jobId
    """
    pass

  def cdp_backup_create_snapshot(self, timeStamp, jobId):
    """
    打快照, C++调用


    Parameters:
     - timeStamp
     - jobId
    """
    pass

  def create_new_vm(self, vmConfig):
    """
        创建新的虚拟机
    *

    Parameters:
     - vmConfig
    """
    pass

  def vm_power_control(self, vmName, vmControlStatus):
    """
        虚拟机电源管理
    *

    Parameters:
     - vmName
     - vmControlStatus
    """
    pass

  def get_vm_console_url(self, vmName):
    """
        获取虚拟机的远程控制台链接
    *

    Parameters:
     - vmName
    """
    pass

  def delete_vm(self, vmName):
    """
        删除虚拟机
    *

    Parameters:
     - vmName
    """
    pass

  def get_vm_config(self, vmName):
    """
        获取虚拟机的配置
    *

    Parameters:
     - vmName
    """
    pass

  def get_vm_status(self, vmName):
    """
        获取虚拟机的状态
    *

    Parameters:
     - vmName
    """
    pass

  def edit_vm_hardware(self, vmName, slots, cores, mem_size):
    """
        修改虚拟机的CPU和内存
    *

    Parameters:
     - vmName
     - slots
     - cores
     - mem_size
    """
    pass

  def create_vm_disk(self, poolId, diskSize):
    """
        创建新的CDM卷，并返回相关信息
    *

    Parameters:
     - poolId
     - diskSize
    """
    pass

  def get_disk_dev_by_cfgstr(self, cfgstring):
    """
        根据磁盘的cfgstring来获取映射出的设备名
    *

    Parameters:
     - cfgstring
    """
    pass

  def add_vm_disk(self, vmName, new_cdm_disk):
    """
        添加新的cdm卷作为磁盘，并返回虚拟机磁盘信息
    *

    Parameters:
     - vmName
     - new_cdm_disk
    """
    pass

  def delete_vm_disk(self, vmName, disk_solt):
    """
        删除虚拟机磁盘
    *

    Parameters:
     - vmName
     - disk_solt
    """
    pass

  def add_vm_new_net(self, vmName, net_config):
    """
        虚拟机添加新网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    pass

  def edit_vm_net(self, vmName, net_config):
    """
        编辑虚拟机网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    pass

  def delete_vm_net(self, vmName, net_config):
    """
        删除虚拟机网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    pass

  def add_vm_new_iso(self, vmName, iso_config):
    """
        虚拟机添加镜像
    *

    Parameters:
     - vmName
     - iso_config
    """
    pass

  def delete_vm_iso(self, vmName, iso_config):
    """
        删除虚拟机镜像
    *

    Parameters:
     - vmName
     - iso_config
    """
    pass

  def get_dev_name(self, cfgstring):
    """
        根据磁盘的cfgstring来获取映射出的设备名
    *

    Parameters:
     - cfgstring
    """
    pass

  def get_dev_name_by_scan(self, request_json):
    """
        扫描磁盘并获取映射出的设备名
    *

    Parameters:
     - request_json
    """
    pass

  def get_node_iscsi_iqn(self):
    """
        获取当前节点iscsi的iqn
    *
    """
    pass

  def get_filter_jobs(self, get_req):
    """
       * 根据条件查询
       * @return 任务对象列表
    *

    Parameters:
     - get_req
    """
    pass

  def backup_export_log(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def drill_job_logs_export(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def mount_job_logs_export(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    pass

  def check_cdp_volume_driver_used(self, clientId):
    """
    *  判断当前客户段上是否有使用CDP卷驱动任务存在，如果存在则不能建立新的CDP卷驱动任务
        @ return     False：不存在使用CDP卷驱动任务  抛错：卷被占用，这里统一抛错出去
    *

    Parameters:
     - clientId
    """
    pass

  def check_client_protected(self, clientId):
    """
        获取当前客户端是否被保护
    *

    Parameters:
     - clientId
    """
    pass

  def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    """
    生产资源类型 sourceType
    服务类型     svcType
    生产资源标识 sourceId
    @ return


    Parameters:
     - sourceType
     - svcType
     - sourceId
     - relation
    """
    pass

  def add_disk_to_repair_vm(self, disk_list, os_type):
    """
          给修复虚拟机加载待修复的磁盘
    @ return     False：加载磁盘失败  True：加载磁盘成功
      *

    Parameters:
     - disk_list
     - os_type
    """
    pass

  def delete_disk_from_repair_vm(self, disk_list, os_type):
    """
          给修复虚拟机卸载
    @ return     False：卸载磁盘失败  True：卸载磁盘成功
      *

    Parameters:
     - disk_list
     - os_type
    """
    pass

  def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    """
    数据源       datasource
    客户端ID     clientId
    数据源的用户名(适用于多用户场景)   dbRunUserName
    @ return


    Parameters:
     - datasource
     - clientId
     - dbRunUserName
    """
    pass

  def check_user_has_data(self, user_list):
    """
    检查的用户列表       user_list
    @ return		返回有数据的用户列表


    Parameters:
     - user_list
    """
    pass

  def get_jobs_count_info(self, startTime, isBackup, userId):
    """
    获取实时备份/复制任务状态数据
    @ return


    Parameters:
     - startTime
     - isBackup
     - userId
    """
    pass

  def has_realtimejob_run_users(self, user_ids, job_type):
    """
    检索指定用户列表中还有实时复制、实时备份任务运行的用户
    user_ids 被检索的用户列表
    job_type #0实时复制，1实时备份，2实时复制+实时备份
    @ return   实时复制、实时备份任务运行的用户列表


    Parameters:
     - user_ids
     - job_type
    """
    pass

  def client_exsit_job(self, clientId):
    """
    Parameters:
     - clientId
    """
    pass

  def delete_extra_resource_by_username(self, user_names):
    """
    通过用户名称删除其附属的历史纪录、恢复纪录、清理纪录等等一系列的资源
    @ return


    Parameters:
     - user_names
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def microprobe(self):
    """
    服务探针，测试服务可用性
    @ throw ncException
    """
    self.send_microprobe()
    self.recv_microprobe()

  def send_microprobe(self):
    self._oprot.writeMessageBegin('microprobe', TMessageType.CALL, self._seqid)
    args = microprobe_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_microprobe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = microprobe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_all_jobs(self):
    """
    获取所有任务

    @return 任务对象列表
    """
    self.send_get_all_jobs()
    return self.recv_get_all_jobs()

  def send_get_all_jobs(self):
    self._oprot.writeMessageBegin('get_all_jobs', TMessageType.CALL, self._seqid)
    args = get_all_jobs_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_jobs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_jobs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_jobs failed: unknown result")

  def remove_all_jobs_by_client_ids(self, clientIds):
    """
    批量删除任务 根据权限用户


    Parameters:
     - clientIds
    """
    self.send_remove_all_jobs_by_client_ids(clientIds)
    return self.recv_remove_all_jobs_by_client_ids()

  def send_remove_all_jobs_by_client_ids(self, clientIds):
    self._oprot.writeMessageBegin('remove_all_jobs_by_client_ids', TMessageType.CALL, self._seqid)
    args = remove_all_jobs_by_client_ids_args()
    args.clientIds = clientIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove_all_jobs_by_client_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = remove_all_jobs_by_client_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remove_all_jobs_by_client_ids failed: unknown result")

  def get_all_cdp_job_for_ams(self):
    """
    获取当前所有的实时复制任务，推送给AMS

    @return 任务对象列表
    """
    self.send_get_all_cdp_job_for_ams()
    return self.recv_get_all_cdp_job_for_ams()

  def send_get_all_cdp_job_for_ams(self):
    self._oprot.writeMessageBegin('get_all_cdp_job_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_cdp_job_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_cdp_job_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_cdp_job_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_cdp_job_for_ams failed: unknown result")

  def get_all_cdp_jobInstance_for_ams(self):
    """
    获取当前所有的实时复制任务的执行记录，推送给AMS

    @return 任务对象列表
    """
    self.send_get_all_cdp_jobInstance_for_ams()
    return self.recv_get_all_cdp_jobInstance_for_ams()

  def send_get_all_cdp_jobInstance_for_ams(self):
    self._oprot.writeMessageBegin('get_all_cdp_jobInstance_for_ams', TMessageType.CALL, self._seqid)
    args = get_all_cdp_jobInstance_for_ams_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_cdp_jobInstance_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_cdp_jobInstance_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_cdp_jobInstance_for_ams failed: unknown result")

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    self.send_get_data_for_ams(kwargs)
    return self.recv_get_data_for_ams()

  def send_get_data_for_ams(self, kwargs):
    self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
    args = get_data_for_ams_args()
    args.kwargs = kwargs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_data_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_data_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

  def has_running_job_on_client(self, clientId):
    """
    *  客户端上时候有正则运行的任务
       @ return True:有正在运行的任务, False： 没有正在运行的任务
    *

    Parameters:
     - clientId
    """
    self.send_has_running_job_on_client(clientId)
    return self.recv_has_running_job_on_client()

  def send_has_running_job_on_client(self, clientId):
    self._oprot.writeMessageBegin('has_running_job_on_client', TMessageType.CALL, self._seqid)
    args = has_running_job_on_client_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_has_running_job_on_client(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = has_running_job_on_client_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "has_running_job_on_client failed: unknown result")

  def is_exists_running_job_on_client(self, clientId):
    """
    *  客户端上是否存在正则运行的任务
       @ return True:存在正在运行的任务, False： 不存在正在运行的任务
    *

    Parameters:
     - clientId
    """
    self.send_is_exists_running_job_on_client(clientId)
    return self.recv_is_exists_running_job_on_client()

  def send_is_exists_running_job_on_client(self, clientId):
    self._oprot.writeMessageBegin('is_exists_running_job_on_client', TMessageType.CALL, self._seqid)
    args = is_exists_running_job_on_client_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_exists_running_job_on_client(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = is_exists_running_job_on_client_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_exists_running_job_on_client failed: unknown result")

  def cdp_backup_init_volumes(self, request_json):
    """
    初始化基础卷并创建日志卷，服务端调用


    Parameters:
     - request_json
    """
    self.send_cdp_backup_init_volumes(request_json)
    return self.recv_cdp_backup_init_volumes()

  def send_cdp_backup_init_volumes(self, request_json):
    self._oprot.writeMessageBegin('cdp_backup_init_volumes', TMessageType.CALL, self._seqid)
    args = cdp_backup_init_volumes_args()
    args.request_json = request_json
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_init_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_init_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_init_volumes failed: unknown result")

  def cdp_backup_on_log_volume_formatted(self, jobId):
    """
    *  C++调用，客户端格式化日志卷后，回调用此函数通知服务端此任务日志卷已格式化
       @ return True:成功, False：失败,客户端抛出异常，结束任务流程
    *

    Parameters:
     - jobId
    """
    self.send_cdp_backup_on_log_volume_formatted(jobId)
    return self.recv_cdp_backup_on_log_volume_formatted()

  def send_cdp_backup_on_log_volume_formatted(self, jobId):
    self._oprot.writeMessageBegin('cdp_backup_on_log_volume_formatted', TMessageType.CALL, self._seqid)
    args = cdp_backup_on_log_volume_formatted_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_on_log_volume_formatted(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_on_log_volume_formatted_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_on_log_volume_formatted failed: unknown result")

  def cdp_backup_mount_log_volume(self, jobId):
    """
    *  挂载日志卷，需在存储池节点IP上调用，服务端调用
       @ return dev: 日志卷设备名
    *

    Parameters:
     - jobId
    """
    self.send_cdp_backup_mount_log_volume(jobId)
    return self.recv_cdp_backup_mount_log_volume()

  def send_cdp_backup_mount_log_volume(self, jobId):
    self._oprot.writeMessageBegin('cdp_backup_mount_log_volume', TMessageType.CALL, self._seqid)
    args = cdp_backup_mount_log_volume_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_mount_log_volume(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_mount_log_volume_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_mount_log_volume failed: unknown result")

  def cdp_backup_clean_base_volumes(self, jobId):
    """
    *  删除任务基础卷，删除任务时使用
       @ return : 0: 成功
    *

    Parameters:
     - jobId
    """
    self.send_cdp_backup_clean_base_volumes(jobId)
    return self.recv_cdp_backup_clean_base_volumes()

  def send_cdp_backup_clean_base_volumes(self, jobId):
    self._oprot.writeMessageBegin('cdp_backup_clean_base_volumes', TMessageType.CALL, self._seqid)
    args = cdp_backup_clean_base_volumes_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_clean_base_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_clean_base_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_clean_base_volumes failed: unknown result")

  def cdp_backup_on_reboot_recheck(self, jobId):
    """
    *  重启服务器时基础卷映射丢失，日志卷挂载丢失
       所以在服务启动时调用此接口检测并重新挂载
       @ return : 0: 成功
    *

    Parameters:
     - jobId
    """
    self.send_cdp_backup_on_reboot_recheck(jobId)
    return self.recv_cdp_backup_on_reboot_recheck()

  def send_cdp_backup_on_reboot_recheck(self, jobId):
    self._oprot.writeMessageBegin('cdp_backup_on_reboot_recheck', TMessageType.CALL, self._seqid)
    args = cdp_backup_on_reboot_recheck_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_on_reboot_recheck(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_on_reboot_recheck_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_on_reboot_recheck failed: unknown result")

  def cdp_backup_update_devs(self, jobId):
    """
    *  更新设备名，需在存储池节点IP上调用，服务端调用
       @ return : 0: 成功  1:设备未就绪
    *

    Parameters:
     - jobId
    """
    self.send_cdp_backup_update_devs(jobId)
    return self.recv_cdp_backup_update_devs()

  def send_cdp_backup_update_devs(self, jobId):
    self._oprot.writeMessageBegin('cdp_backup_update_devs', TMessageType.CALL, self._seqid)
    args = cdp_backup_update_devs_args()
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_update_devs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_update_devs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_update_devs failed: unknown result")

  def cdp_backup_create_snapshot(self, timeStamp, jobId):
    """
    打快照, C++调用


    Parameters:
     - timeStamp
     - jobId
    """
    self.send_cdp_backup_create_snapshot(timeStamp, jobId)
    return self.recv_cdp_backup_create_snapshot()

  def send_cdp_backup_create_snapshot(self, timeStamp, jobId):
    self._oprot.writeMessageBegin('cdp_backup_create_snapshot', TMessageType.CALL, self._seqid)
    args = cdp_backup_create_snapshot_args()
    args.timeStamp = timeStamp
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cdp_backup_create_snapshot(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = cdp_backup_create_snapshot_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "cdp_backup_create_snapshot failed: unknown result")

  def create_new_vm(self, vmConfig):
    """
        创建新的虚拟机
    *

    Parameters:
     - vmConfig
    """
    self.send_create_new_vm(vmConfig)
    self.recv_create_new_vm()

  def send_create_new_vm(self, vmConfig):
    self._oprot.writeMessageBegin('create_new_vm', TMessageType.CALL, self._seqid)
    args = create_new_vm_args()
    args.vmConfig = vmConfig
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_new_vm(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_new_vm_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def vm_power_control(self, vmName, vmControlStatus):
    """
        虚拟机电源管理
    *

    Parameters:
     - vmName
     - vmControlStatus
    """
    self.send_vm_power_control(vmName, vmControlStatus)
    self.recv_vm_power_control()

  def send_vm_power_control(self, vmName, vmControlStatus):
    self._oprot.writeMessageBegin('vm_power_control', TMessageType.CALL, self._seqid)
    args = vm_power_control_args()
    args.vmName = vmName
    args.vmControlStatus = vmControlStatus
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_vm_power_control(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = vm_power_control_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_vm_console_url(self, vmName):
    """
        获取虚拟机的远程控制台链接
    *

    Parameters:
     - vmName
    """
    self.send_get_vm_console_url(vmName)
    return self.recv_get_vm_console_url()

  def send_get_vm_console_url(self, vmName):
    self._oprot.writeMessageBegin('get_vm_console_url', TMessageType.CALL, self._seqid)
    args = get_vm_console_url_args()
    args.vmName = vmName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_vm_console_url(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_vm_console_url_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vm_console_url failed: unknown result")

  def delete_vm(self, vmName):
    """
        删除虚拟机
    *

    Parameters:
     - vmName
    """
    self.send_delete_vm(vmName)
    self.recv_delete_vm()

  def send_delete_vm(self, vmName):
    self._oprot.writeMessageBegin('delete_vm', TMessageType.CALL, self._seqid)
    args = delete_vm_args()
    args.vmName = vmName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_vm(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_vm_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_vm_config(self, vmName):
    """
        获取虚拟机的配置
    *

    Parameters:
     - vmName
    """
    self.send_get_vm_config(vmName)
    return self.recv_get_vm_config()

  def send_get_vm_config(self, vmName):
    self._oprot.writeMessageBegin('get_vm_config', TMessageType.CALL, self._seqid)
    args = get_vm_config_args()
    args.vmName = vmName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_vm_config(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_vm_config_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vm_config failed: unknown result")

  def get_vm_status(self, vmName):
    """
        获取虚拟机的状态
    *

    Parameters:
     - vmName
    """
    self.send_get_vm_status(vmName)
    return self.recv_get_vm_status()

  def send_get_vm_status(self, vmName):
    self._oprot.writeMessageBegin('get_vm_status', TMessageType.CALL, self._seqid)
    args = get_vm_status_args()
    args.vmName = vmName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_vm_status(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_vm_status_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vm_status failed: unknown result")

  def edit_vm_hardware(self, vmName, slots, cores, mem_size):
    """
        修改虚拟机的CPU和内存
    *

    Parameters:
     - vmName
     - slots
     - cores
     - mem_size
    """
    self.send_edit_vm_hardware(vmName, slots, cores, mem_size)
    self.recv_edit_vm_hardware()

  def send_edit_vm_hardware(self, vmName, slots, cores, mem_size):
    self._oprot.writeMessageBegin('edit_vm_hardware', TMessageType.CALL, self._seqid)
    args = edit_vm_hardware_args()
    args.vmName = vmName
    args.slots = slots
    args.cores = cores
    args.mem_size = mem_size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_edit_vm_hardware(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = edit_vm_hardware_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def create_vm_disk(self, poolId, diskSize):
    """
        创建新的CDM卷，并返回相关信息
    *

    Parameters:
     - poolId
     - diskSize
    """
    self.send_create_vm_disk(poolId, diskSize)
    return self.recv_create_vm_disk()

  def send_create_vm_disk(self, poolId, diskSize):
    self._oprot.writeMessageBegin('create_vm_disk', TMessageType.CALL, self._seqid)
    args = create_vm_disk_args()
    args.poolId = poolId
    args.diskSize = diskSize
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_vm_disk(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_vm_disk_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_vm_disk failed: unknown result")

  def get_disk_dev_by_cfgstr(self, cfgstring):
    """
        根据磁盘的cfgstring来获取映射出的设备名
    *

    Parameters:
     - cfgstring
    """
    self.send_get_disk_dev_by_cfgstr(cfgstring)
    return self.recv_get_disk_dev_by_cfgstr()

  def send_get_disk_dev_by_cfgstr(self, cfgstring):
    self._oprot.writeMessageBegin('get_disk_dev_by_cfgstr', TMessageType.CALL, self._seqid)
    args = get_disk_dev_by_cfgstr_args()
    args.cfgstring = cfgstring
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_disk_dev_by_cfgstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_disk_dev_by_cfgstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_disk_dev_by_cfgstr failed: unknown result")

  def add_vm_disk(self, vmName, new_cdm_disk):
    """
        添加新的cdm卷作为磁盘，并返回虚拟机磁盘信息
    *

    Parameters:
     - vmName
     - new_cdm_disk
    """
    self.send_add_vm_disk(vmName, new_cdm_disk)
    return self.recv_add_vm_disk()

  def send_add_vm_disk(self, vmName, new_cdm_disk):
    self._oprot.writeMessageBegin('add_vm_disk', TMessageType.CALL, self._seqid)
    args = add_vm_disk_args()
    args.vmName = vmName
    args.new_cdm_disk = new_cdm_disk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_vm_disk(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_vm_disk_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_vm_disk failed: unknown result")

  def delete_vm_disk(self, vmName, disk_solt):
    """
        删除虚拟机磁盘
    *

    Parameters:
     - vmName
     - disk_solt
    """
    self.send_delete_vm_disk(vmName, disk_solt)
    self.recv_delete_vm_disk()

  def send_delete_vm_disk(self, vmName, disk_solt):
    self._oprot.writeMessageBegin('delete_vm_disk', TMessageType.CALL, self._seqid)
    args = delete_vm_disk_args()
    args.vmName = vmName
    args.disk_solt = disk_solt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_vm_disk(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_vm_disk_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def add_vm_new_net(self, vmName, net_config):
    """
        虚拟机添加新网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    self.send_add_vm_new_net(vmName, net_config)
    self.recv_add_vm_new_net()

  def send_add_vm_new_net(self, vmName, net_config):
    self._oprot.writeMessageBegin('add_vm_new_net', TMessageType.CALL, self._seqid)
    args = add_vm_new_net_args()
    args.vmName = vmName
    args.net_config = net_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_vm_new_net(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_vm_new_net_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def edit_vm_net(self, vmName, net_config):
    """
        编辑虚拟机网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    self.send_edit_vm_net(vmName, net_config)
    self.recv_edit_vm_net()

  def send_edit_vm_net(self, vmName, net_config):
    self._oprot.writeMessageBegin('edit_vm_net', TMessageType.CALL, self._seqid)
    args = edit_vm_net_args()
    args.vmName = vmName
    args.net_config = net_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_edit_vm_net(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = edit_vm_net_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def delete_vm_net(self, vmName, net_config):
    """
        删除虚拟机网卡
    *

    Parameters:
     - vmName
     - net_config
    """
    self.send_delete_vm_net(vmName, net_config)
    self.recv_delete_vm_net()

  def send_delete_vm_net(self, vmName, net_config):
    self._oprot.writeMessageBegin('delete_vm_net', TMessageType.CALL, self._seqid)
    args = delete_vm_net_args()
    args.vmName = vmName
    args.net_config = net_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_vm_net(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_vm_net_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def add_vm_new_iso(self, vmName, iso_config):
    """
        虚拟机添加镜像
    *

    Parameters:
     - vmName
     - iso_config
    """
    self.send_add_vm_new_iso(vmName, iso_config)
    self.recv_add_vm_new_iso()

  def send_add_vm_new_iso(self, vmName, iso_config):
    self._oprot.writeMessageBegin('add_vm_new_iso', TMessageType.CALL, self._seqid)
    args = add_vm_new_iso_args()
    args.vmName = vmName
    args.iso_config = iso_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_vm_new_iso(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_vm_new_iso_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def delete_vm_iso(self, vmName, iso_config):
    """
        删除虚拟机镜像
    *

    Parameters:
     - vmName
     - iso_config
    """
    self.send_delete_vm_iso(vmName, iso_config)
    self.recv_delete_vm_iso()

  def send_delete_vm_iso(self, vmName, iso_config):
    self._oprot.writeMessageBegin('delete_vm_iso', TMessageType.CALL, self._seqid)
    args = delete_vm_iso_args()
    args.vmName = vmName
    args.iso_config = iso_config
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_vm_iso(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_vm_iso_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return

  def get_dev_name(self, cfgstring):
    """
        根据磁盘的cfgstring来获取映射出的设备名
    *

    Parameters:
     - cfgstring
    """
    self.send_get_dev_name(cfgstring)
    return self.recv_get_dev_name()

  def send_get_dev_name(self, cfgstring):
    self._oprot.writeMessageBegin('get_dev_name', TMessageType.CALL, self._seqid)
    args = get_dev_name_args()
    args.cfgstring = cfgstring
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_dev_name(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_dev_name_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dev_name failed: unknown result")

  def get_dev_name_by_scan(self, request_json):
    """
        扫描磁盘并获取映射出的设备名
    *

    Parameters:
     - request_json
    """
    self.send_get_dev_name_by_scan(request_json)
    return self.recv_get_dev_name_by_scan()

  def send_get_dev_name_by_scan(self, request_json):
    self._oprot.writeMessageBegin('get_dev_name_by_scan', TMessageType.CALL, self._seqid)
    args = get_dev_name_by_scan_args()
    args.request_json = request_json
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_dev_name_by_scan(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_dev_name_by_scan_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dev_name_by_scan failed: unknown result")

  def get_node_iscsi_iqn(self):
    """
        获取当前节点iscsi的iqn
    *
    """
    self.send_get_node_iscsi_iqn()
    return self.recv_get_node_iscsi_iqn()

  def send_get_node_iscsi_iqn(self):
    self._oprot.writeMessageBegin('get_node_iscsi_iqn', TMessageType.CALL, self._seqid)
    args = get_node_iscsi_iqn_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_node_iscsi_iqn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_node_iscsi_iqn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_iscsi_iqn failed: unknown result")

  def get_filter_jobs(self, get_req):
    """
       * 根据条件查询
       * @return 任务对象列表
    *

    Parameters:
     - get_req
    """
    self.send_get_filter_jobs(get_req)
    return self.recv_get_filter_jobs()

  def send_get_filter_jobs(self, get_req):
    self._oprot.writeMessageBegin('get_filter_jobs', TMessageType.CALL, self._seqid)
    args = get_filter_jobs_args()
    args.get_req = get_req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_filter_jobs(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_filter_jobs_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_filter_jobs failed: unknown result")

  def backup_export_log(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_backup_export_log(body, jobInstanceId, userId)
    return self.recv_backup_export_log()

  def send_backup_export_log(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('backup_export_log', TMessageType.CALL, self._seqid)
    args = backup_export_log_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_backup_export_log(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = backup_export_log_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "backup_export_log failed: unknown result")

  def drill_job_logs_export(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_drill_job_logs_export(body, jobInstanceId, userId)
    return self.recv_drill_job_logs_export()

  def send_drill_job_logs_export(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('drill_job_logs_export', TMessageType.CALL, self._seqid)
    args = drill_job_logs_export_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drill_job_logs_export(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = drill_job_logs_export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drill_job_logs_export failed: unknown result")

  def mount_job_logs_export(self, body, jobInstanceId, userId):
    """
    Parameters:
     - body
     - jobInstanceId
     - userId
    """
    self.send_mount_job_logs_export(body, jobInstanceId, userId)
    return self.recv_mount_job_logs_export()

  def send_mount_job_logs_export(self, body, jobInstanceId, userId):
    self._oprot.writeMessageBegin('mount_job_logs_export', TMessageType.CALL, self._seqid)
    args = mount_job_logs_export_args()
    args.body = body
    args.jobInstanceId = jobInstanceId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mount_job_logs_export(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = mount_job_logs_export_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mount_job_logs_export failed: unknown result")

  def check_cdp_volume_driver_used(self, clientId):
    """
    *  判断当前客户段上是否有使用CDP卷驱动任务存在，如果存在则不能建立新的CDP卷驱动任务
        @ return     False：不存在使用CDP卷驱动任务  抛错：卷被占用，这里统一抛错出去
    *

    Parameters:
     - clientId
    """
    self.send_check_cdp_volume_driver_used(clientId)
    return self.recv_check_cdp_volume_driver_used()

  def send_check_cdp_volume_driver_used(self, clientId):
    self._oprot.writeMessageBegin('check_cdp_volume_driver_used', TMessageType.CALL, self._seqid)
    args = check_cdp_volume_driver_used_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_cdp_volume_driver_used(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_cdp_volume_driver_used_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_cdp_volume_driver_used failed: unknown result")

  def check_client_protected(self, clientId):
    """
        获取当前客户端是否被保护
    *

    Parameters:
     - clientId
    """
    self.send_check_client_protected(clientId)
    return self.recv_check_client_protected()

  def send_check_client_protected(self, clientId):
    self._oprot.writeMessageBegin('check_client_protected', TMessageType.CALL, self._seqid)
    args = check_client_protected_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_client_protected(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_client_protected_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_client_protected failed: unknown result")

  def get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    """
    生产资源类型 sourceType
    服务类型     svcType
    生产资源标识 sourceId
    @ return


    Parameters:
     - sourceType
     - svcType
     - sourceId
     - relation
    """
    self.send_get_jobs_by_sourceId(sourceType, svcType, sourceId, relation)
    return self.recv_get_jobs_by_sourceId()

  def send_get_jobs_by_sourceId(self, sourceType, svcType, sourceId, relation):
    self._oprot.writeMessageBegin('get_jobs_by_sourceId', TMessageType.CALL, self._seqid)
    args = get_jobs_by_sourceId_args()
    args.sourceType = sourceType
    args.svcType = svcType
    args.sourceId = sourceId
    args.relation = relation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_by_sourceId(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_by_sourceId_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_sourceId failed: unknown result")

  def add_disk_to_repair_vm(self, disk_list, os_type):
    """
          给修复虚拟机加载待修复的磁盘
    @ return     False：加载磁盘失败  True：加载磁盘成功
      *

    Parameters:
     - disk_list
     - os_type
    """
    self.send_add_disk_to_repair_vm(disk_list, os_type)
    return self.recv_add_disk_to_repair_vm()

  def send_add_disk_to_repair_vm(self, disk_list, os_type):
    self._oprot.writeMessageBegin('add_disk_to_repair_vm', TMessageType.CALL, self._seqid)
    args = add_disk_to_repair_vm_args()
    args.disk_list = disk_list
    args.os_type = os_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_disk_to_repair_vm(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = add_disk_to_repair_vm_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_disk_to_repair_vm failed: unknown result")

  def delete_disk_from_repair_vm(self, disk_list, os_type):
    """
          给修复虚拟机卸载
    @ return     False：卸载磁盘失败  True：卸载磁盘成功
      *

    Parameters:
     - disk_list
     - os_type
    """
    self.send_delete_disk_from_repair_vm(disk_list, os_type)
    return self.recv_delete_disk_from_repair_vm()

  def send_delete_disk_from_repair_vm(self, disk_list, os_type):
    self._oprot.writeMessageBegin('delete_disk_from_repair_vm', TMessageType.CALL, self._seqid)
    args = delete_disk_from_repair_vm_args()
    args.disk_list = disk_list
    args.os_type = os_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_disk_from_repair_vm(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_disk_from_repair_vm_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_disk_from_repair_vm failed: unknown result")

  def get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    """
    数据源       datasource
    客户端ID     clientId
    数据源的用户名(适用于多用户场景)   dbRunUserName
    @ return


    Parameters:
     - datasource
     - clientId
     - dbRunUserName
    """
    self.send_get_jobs_by_datasource(datasource, clientId, dbRunUserName)
    return self.recv_get_jobs_by_datasource()

  def send_get_jobs_by_datasource(self, datasource, clientId, dbRunUserName):
    self._oprot.writeMessageBegin('get_jobs_by_datasource', TMessageType.CALL, self._seqid)
    args = get_jobs_by_datasource_args()
    args.datasource = datasource
    args.clientId = clientId
    args.dbRunUserName = dbRunUserName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_by_datasource(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_by_datasource_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_by_datasource failed: unknown result")

  def check_user_has_data(self, user_list):
    """
    检查的用户列表       user_list
    @ return		返回有数据的用户列表


    Parameters:
     - user_list
    """
    self.send_check_user_has_data(user_list)
    return self.recv_check_user_has_data()

  def send_check_user_has_data(self, user_list):
    self._oprot.writeMessageBegin('check_user_has_data', TMessageType.CALL, self._seqid)
    args = check_user_has_data_args()
    args.user_list = user_list
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_check_user_has_data(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = check_user_has_data_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "check_user_has_data failed: unknown result")

  def get_jobs_count_info(self, startTime, isBackup, userId):
    """
    获取实时备份/复制任务状态数据
    @ return


    Parameters:
     - startTime
     - isBackup
     - userId
    """
    self.send_get_jobs_count_info(startTime, isBackup, userId)
    return self.recv_get_jobs_count_info()

  def send_get_jobs_count_info(self, startTime, isBackup, userId):
    self._oprot.writeMessageBegin('get_jobs_count_info', TMessageType.CALL, self._seqid)
    args = get_jobs_count_info_args()
    args.startTime = startTime
    args.isBackup = isBackup
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_jobs_count_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_jobs_count_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_jobs_count_info failed: unknown result")

  def has_realtimejob_run_users(self, user_ids, job_type):
    """
    检索指定用户列表中还有实时复制、实时备份任务运行的用户
    user_ids 被检索的用户列表
    job_type #0实时复制，1实时备份，2实时复制+实时备份
    @ return   实时复制、实时备份任务运行的用户列表


    Parameters:
     - user_ids
     - job_type
    """
    self.send_has_realtimejob_run_users(user_ids, job_type)
    return self.recv_has_realtimejob_run_users()

  def send_has_realtimejob_run_users(self, user_ids, job_type):
    self._oprot.writeMessageBegin('has_realtimejob_run_users', TMessageType.CALL, self._seqid)
    args = has_realtimejob_run_users_args()
    args.user_ids = user_ids
    args.job_type = job_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_has_realtimejob_run_users(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = has_realtimejob_run_users_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "has_realtimejob_run_users failed: unknown result")

  def client_exsit_job(self, clientId):
    """
    Parameters:
     - clientId
    """
    self.send_client_exsit_job(clientId)
    return self.recv_client_exsit_job()

  def send_client_exsit_job(self, clientId):
    self._oprot.writeMessageBegin('client_exsit_job', TMessageType.CALL, self._seqid)
    args = client_exsit_job_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_client_exsit_job(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = client_exsit_job_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "client_exsit_job failed: unknown result")

  def delete_extra_resource_by_username(self, user_names):
    """
    通过用户名称删除其附属的历史纪录、恢复纪录、清理纪录等等一系列的资源
    @ return


    Parameters:
     - user_names
    """
    self.send_delete_extra_resource_by_username(user_names)
    self.recv_delete_extra_resource_by_username()

  def send_delete_extra_resource_by_username(self, user_names):
    self._oprot.writeMessageBegin('delete_extra_resource_by_username', TMessageType.CALL, self._seqid)
    args = delete_extra_resource_by_username_args()
    args.user_names = user_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_extra_resource_by_username(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_extra_resource_by_username_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.error is not None:
      raise result.error
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["microprobe"] = Processor.process_microprobe
    self._processMap["get_all_jobs"] = Processor.process_get_all_jobs
    self._processMap["remove_all_jobs_by_client_ids"] = Processor.process_remove_all_jobs_by_client_ids
    self._processMap["get_all_cdp_job_for_ams"] = Processor.process_get_all_cdp_job_for_ams
    self._processMap["get_all_cdp_jobInstance_for_ams"] = Processor.process_get_all_cdp_jobInstance_for_ams
    self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
    self._processMap["has_running_job_on_client"] = Processor.process_has_running_job_on_client
    self._processMap["is_exists_running_job_on_client"] = Processor.process_is_exists_running_job_on_client
    self._processMap["cdp_backup_init_volumes"] = Processor.process_cdp_backup_init_volumes
    self._processMap["cdp_backup_on_log_volume_formatted"] = Processor.process_cdp_backup_on_log_volume_formatted
    self._processMap["cdp_backup_mount_log_volume"] = Processor.process_cdp_backup_mount_log_volume
    self._processMap["cdp_backup_clean_base_volumes"] = Processor.process_cdp_backup_clean_base_volumes
    self._processMap["cdp_backup_on_reboot_recheck"] = Processor.process_cdp_backup_on_reboot_recheck
    self._processMap["cdp_backup_update_devs"] = Processor.process_cdp_backup_update_devs
    self._processMap["cdp_backup_create_snapshot"] = Processor.process_cdp_backup_create_snapshot
    self._processMap["create_new_vm"] = Processor.process_create_new_vm
    self._processMap["vm_power_control"] = Processor.process_vm_power_control
    self._processMap["get_vm_console_url"] = Processor.process_get_vm_console_url
    self._processMap["delete_vm"] = Processor.process_delete_vm
    self._processMap["get_vm_config"] = Processor.process_get_vm_config
    self._processMap["get_vm_status"] = Processor.process_get_vm_status
    self._processMap["edit_vm_hardware"] = Processor.process_edit_vm_hardware
    self._processMap["create_vm_disk"] = Processor.process_create_vm_disk
    self._processMap["get_disk_dev_by_cfgstr"] = Processor.process_get_disk_dev_by_cfgstr
    self._processMap["add_vm_disk"] = Processor.process_add_vm_disk
    self._processMap["delete_vm_disk"] = Processor.process_delete_vm_disk
    self._processMap["add_vm_new_net"] = Processor.process_add_vm_new_net
    self._processMap["edit_vm_net"] = Processor.process_edit_vm_net
    self._processMap["delete_vm_net"] = Processor.process_delete_vm_net
    self._processMap["add_vm_new_iso"] = Processor.process_add_vm_new_iso
    self._processMap["delete_vm_iso"] = Processor.process_delete_vm_iso
    self._processMap["get_dev_name"] = Processor.process_get_dev_name
    self._processMap["get_dev_name_by_scan"] = Processor.process_get_dev_name_by_scan
    self._processMap["get_node_iscsi_iqn"] = Processor.process_get_node_iscsi_iqn
    self._processMap["get_filter_jobs"] = Processor.process_get_filter_jobs
    self._processMap["backup_export_log"] = Processor.process_backup_export_log
    self._processMap["drill_job_logs_export"] = Processor.process_drill_job_logs_export
    self._processMap["mount_job_logs_export"] = Processor.process_mount_job_logs_export
    self._processMap["check_cdp_volume_driver_used"] = Processor.process_check_cdp_volume_driver_used
    self._processMap["check_client_protected"] = Processor.process_check_client_protected
    self._processMap["get_jobs_by_sourceId"] = Processor.process_get_jobs_by_sourceId
    self._processMap["add_disk_to_repair_vm"] = Processor.process_add_disk_to_repair_vm
    self._processMap["delete_disk_from_repair_vm"] = Processor.process_delete_disk_from_repair_vm
    self._processMap["get_jobs_by_datasource"] = Processor.process_get_jobs_by_datasource
    self._processMap["check_user_has_data"] = Processor.process_check_user_has_data
    self._processMap["get_jobs_count_info"] = Processor.process_get_jobs_count_info
    self._processMap["has_realtimejob_run_users"] = Processor.process_has_realtimejob_run_users
    self._processMap["client_exsit_job"] = Processor.process_client_exsit_job
    self._processMap["delete_extra_resource_by_username"] = Processor.process_delete_extra_resource_by_username

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_microprobe(self, seqid, iprot, oprot):
    args = microprobe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = microprobe_result()
    try:
      self._handler.microprobe()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("microprobe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_jobs(self, seqid, iprot, oprot):
    args = get_all_jobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_jobs_result()
    try:
      result.success = self._handler.get_all_jobs()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_jobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove_all_jobs_by_client_ids(self, seqid, iprot, oprot):
    args = remove_all_jobs_by_client_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_all_jobs_by_client_ids_result()
    try:
      result.success = self._handler.remove_all_jobs_by_client_ids(args.clientIds)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("remove_all_jobs_by_client_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_cdp_job_for_ams(self, seqid, iprot, oprot):
    args = get_all_cdp_job_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_cdp_job_for_ams_result()
    try:
      result.success = self._handler.get_all_cdp_job_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_cdp_job_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_cdp_jobInstance_for_ams(self, seqid, iprot, oprot):
    args = get_all_cdp_jobInstance_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_cdp_jobInstance_for_ams_result()
    try:
      result.success = self._handler.get_all_cdp_jobInstance_for_ams()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_all_cdp_jobInstance_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_data_for_ams(self, seqid, iprot, oprot):
    args = get_data_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_data_for_ams_result()
    try:
      result.success = self._handler.get_data_for_ams(args.kwargs)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_data_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_has_running_job_on_client(self, seqid, iprot, oprot):
    args = has_running_job_on_client_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = has_running_job_on_client_result()
    try:
      result.success = self._handler.has_running_job_on_client(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("has_running_job_on_client", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_exists_running_job_on_client(self, seqid, iprot, oprot):
    args = is_exists_running_job_on_client_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_exists_running_job_on_client_result()
    try:
      result.success = self._handler.is_exists_running_job_on_client(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("is_exists_running_job_on_client", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_init_volumes(self, seqid, iprot, oprot):
    args = cdp_backup_init_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_init_volumes_result()
    try:
      result.success = self._handler.cdp_backup_init_volumes(args.request_json)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_init_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_on_log_volume_formatted(self, seqid, iprot, oprot):
    args = cdp_backup_on_log_volume_formatted_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_on_log_volume_formatted_result()
    try:
      result.success = self._handler.cdp_backup_on_log_volume_formatted(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_on_log_volume_formatted", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_mount_log_volume(self, seqid, iprot, oprot):
    args = cdp_backup_mount_log_volume_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_mount_log_volume_result()
    try:
      result.success = self._handler.cdp_backup_mount_log_volume(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_mount_log_volume", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_clean_base_volumes(self, seqid, iprot, oprot):
    args = cdp_backup_clean_base_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_clean_base_volumes_result()
    try:
      result.success = self._handler.cdp_backup_clean_base_volumes(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_clean_base_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_on_reboot_recheck(self, seqid, iprot, oprot):
    args = cdp_backup_on_reboot_recheck_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_on_reboot_recheck_result()
    try:
      result.success = self._handler.cdp_backup_on_reboot_recheck(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_on_reboot_recheck", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_update_devs(self, seqid, iprot, oprot):
    args = cdp_backup_update_devs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_update_devs_result()
    try:
      result.success = self._handler.cdp_backup_update_devs(args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_update_devs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cdp_backup_create_snapshot(self, seqid, iprot, oprot):
    args = cdp_backup_create_snapshot_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cdp_backup_create_snapshot_result()
    try:
      result.success = self._handler.cdp_backup_create_snapshot(args.timeStamp, args.jobId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("cdp_backup_create_snapshot", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_new_vm(self, seqid, iprot, oprot):
    args = create_new_vm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_new_vm_result()
    try:
      self._handler.create_new_vm(args.vmConfig)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("create_new_vm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_vm_power_control(self, seqid, iprot, oprot):
    args = vm_power_control_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = vm_power_control_result()
    try:
      self._handler.vm_power_control(args.vmName, args.vmControlStatus)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("vm_power_control", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_vm_console_url(self, seqid, iprot, oprot):
    args = get_vm_console_url_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_vm_console_url_result()
    try:
      result.success = self._handler.get_vm_console_url(args.vmName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_vm_console_url", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_vm(self, seqid, iprot, oprot):
    args = delete_vm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_vm_result()
    try:
      self._handler.delete_vm(args.vmName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_vm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_vm_config(self, seqid, iprot, oprot):
    args = get_vm_config_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_vm_config_result()
    try:
      result.success = self._handler.get_vm_config(args.vmName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_vm_config", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_vm_status(self, seqid, iprot, oprot):
    args = get_vm_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_vm_status_result()
    try:
      result.success = self._handler.get_vm_status(args.vmName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_vm_status", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_edit_vm_hardware(self, seqid, iprot, oprot):
    args = edit_vm_hardware_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = edit_vm_hardware_result()
    try:
      self._handler.edit_vm_hardware(args.vmName, args.slots, args.cores, args.mem_size)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("edit_vm_hardware", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_vm_disk(self, seqid, iprot, oprot):
    args = create_vm_disk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_vm_disk_result()
    try:
      result.success = self._handler.create_vm_disk(args.poolId, args.diskSize)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("create_vm_disk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_disk_dev_by_cfgstr(self, seqid, iprot, oprot):
    args = get_disk_dev_by_cfgstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_disk_dev_by_cfgstr_result()
    try:
      result.success = self._handler.get_disk_dev_by_cfgstr(args.cfgstring)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_disk_dev_by_cfgstr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_vm_disk(self, seqid, iprot, oprot):
    args = add_vm_disk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_vm_disk_result()
    try:
      result.success = self._handler.add_vm_disk(args.vmName, args.new_cdm_disk)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("add_vm_disk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_vm_disk(self, seqid, iprot, oprot):
    args = delete_vm_disk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_vm_disk_result()
    try:
      self._handler.delete_vm_disk(args.vmName, args.disk_solt)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_vm_disk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_vm_new_net(self, seqid, iprot, oprot):
    args = add_vm_new_net_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_vm_new_net_result()
    try:
      self._handler.add_vm_new_net(args.vmName, args.net_config)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("add_vm_new_net", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_edit_vm_net(self, seqid, iprot, oprot):
    args = edit_vm_net_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = edit_vm_net_result()
    try:
      self._handler.edit_vm_net(args.vmName, args.net_config)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("edit_vm_net", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_vm_net(self, seqid, iprot, oprot):
    args = delete_vm_net_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_vm_net_result()
    try:
      self._handler.delete_vm_net(args.vmName, args.net_config)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_vm_net", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_vm_new_iso(self, seqid, iprot, oprot):
    args = add_vm_new_iso_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_vm_new_iso_result()
    try:
      self._handler.add_vm_new_iso(args.vmName, args.iso_config)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("add_vm_new_iso", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_vm_iso(self, seqid, iprot, oprot):
    args = delete_vm_iso_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_vm_iso_result()
    try:
      self._handler.delete_vm_iso(args.vmName, args.iso_config)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_vm_iso", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_dev_name(self, seqid, iprot, oprot):
    args = get_dev_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_dev_name_result()
    try:
      result.success = self._handler.get_dev_name(args.cfgstring)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_dev_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_dev_name_by_scan(self, seqid, iprot, oprot):
    args = get_dev_name_by_scan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_dev_name_by_scan_result()
    try:
      result.success = self._handler.get_dev_name_by_scan(args.request_json)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_dev_name_by_scan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_node_iscsi_iqn(self, seqid, iprot, oprot):
    args = get_node_iscsi_iqn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_node_iscsi_iqn_result()
    try:
      result.success = self._handler.get_node_iscsi_iqn()
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_node_iscsi_iqn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_filter_jobs(self, seqid, iprot, oprot):
    args = get_filter_jobs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_filter_jobs_result()
    try:
      result.success = self._handler.get_filter_jobs(args.get_req)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_filter_jobs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_backup_export_log(self, seqid, iprot, oprot):
    args = backup_export_log_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = backup_export_log_result()
    try:
      result.success = self._handler.backup_export_log(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("backup_export_log", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drill_job_logs_export(self, seqid, iprot, oprot):
    args = drill_job_logs_export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drill_job_logs_export_result()
    try:
      result.success = self._handler.drill_job_logs_export(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("drill_job_logs_export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mount_job_logs_export(self, seqid, iprot, oprot):
    args = mount_job_logs_export_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mount_job_logs_export_result()
    try:
      result.success = self._handler.mount_job_logs_export(args.body, args.jobInstanceId, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("mount_job_logs_export", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_cdp_volume_driver_used(self, seqid, iprot, oprot):
    args = check_cdp_volume_driver_used_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_cdp_volume_driver_used_result()
    try:
      result.success = self._handler.check_cdp_volume_driver_used(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("check_cdp_volume_driver_used", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_client_protected(self, seqid, iprot, oprot):
    args = check_client_protected_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_client_protected_result()
    try:
      result.success = self._handler.check_client_protected(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("check_client_protected", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_by_sourceId(self, seqid, iprot, oprot):
    args = get_jobs_by_sourceId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_by_sourceId_result()
    try:
      result.success = self._handler.get_jobs_by_sourceId(args.sourceType, args.svcType, args.sourceId, args.relation)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_by_sourceId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_disk_to_repair_vm(self, seqid, iprot, oprot):
    args = add_disk_to_repair_vm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_disk_to_repair_vm_result()
    try:
      result.success = self._handler.add_disk_to_repair_vm(args.disk_list, args.os_type)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("add_disk_to_repair_vm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_disk_from_repair_vm(self, seqid, iprot, oprot):
    args = delete_disk_from_repair_vm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_disk_from_repair_vm_result()
    try:
      result.success = self._handler.delete_disk_from_repair_vm(args.disk_list, args.os_type)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_disk_from_repair_vm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_by_datasource(self, seqid, iprot, oprot):
    args = get_jobs_by_datasource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_by_datasource_result()
    try:
      result.success = self._handler.get_jobs_by_datasource(args.datasource, args.clientId, args.dbRunUserName)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_by_datasource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_check_user_has_data(self, seqid, iprot, oprot):
    args = check_user_has_data_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = check_user_has_data_result()
    try:
      result.success = self._handler.check_user_has_data(args.user_list)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("check_user_has_data", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_jobs_count_info(self, seqid, iprot, oprot):
    args = get_jobs_count_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_jobs_count_info_result()
    try:
      result.success = self._handler.get_jobs_count_info(args.startTime, args.isBackup, args.userId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_jobs_count_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_has_realtimejob_run_users(self, seqid, iprot, oprot):
    args = has_realtimejob_run_users_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = has_realtimejob_run_users_result()
    try:
      result.success = self._handler.has_realtimejob_run_users(args.user_ids, args.job_type)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("has_realtimejob_run_users", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_client_exsit_job(self, seqid, iprot, oprot):
    args = client_exsit_job_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = client_exsit_job_result()
    try:
      result.success = self._handler.client_exsit_job(args.clientId)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("client_exsit_job", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_extra_resource_by_username(self, seqid, iprot, oprot):
    args = delete_extra_resource_by_username_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_extra_resource_by_username_result()
    try:
      self._handler.delete_extra_resource_by_username(args.user_names)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("delete_extra_resource_by_username", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class microprobe_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('microprobe_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class microprobe_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('microprobe_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_jobs_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_jobs_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_jobs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncJob.ttypes.ncTJob()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_jobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_client_ids_args(object):
  """
  Attributes:
   - clientIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'clientIds', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, clientIds=None,):
    self.clientIds = clientIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.clientIds = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.clientIds.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_client_ids_args')
    if self.clientIds is not None:
      oprot.writeFieldBegin('clientIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.clientIds))
      for iter13 in self.clientIds:
        oprot.writeString(iter13.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_all_jobs_by_client_ids_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCommonType.ttypes.ncTwoStringList, ncCommonType.ttypes.ncTwoStringList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCommonType.ttypes.ncTwoStringList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_all_jobs_by_client_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_cdp_job_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_cdp_job_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_cdp_job_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncAmsJobType, ncAmsJob.ttypes.ncAmsJobType.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = ncAmsJob.ttypes.ncAmsJobType()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_cdp_job_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_cdp_jobInstance_for_ams_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_cdp_jobInstance_for_ams_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_cdp_jobInstance_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncAmsJob.ttypes.ncJobLog, ncAmsJob.ttypes.ncJobLog.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = ncAmsJob.ttypes.ncJobLog()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_cdp_jobInstance_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_args(object):
  """
  Attributes:
   - kwargs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'kwargs', None, None, ), # 1
  )

  def __init__(self, kwargs=None,):
    self.kwargs = kwargs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.kwargs = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_args')
    if self.kwargs is not None:
      oprot.writeFieldBegin('kwargs', TType.STRING, 1)
      oprot.writeString(self.kwargs.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.kwargs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class has_running_job_on_client_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('has_running_job_on_client_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class has_running_job_on_client_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('has_running_job_on_client_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_running_job_on_client_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_running_job_on_client_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_exists_running_job_on_client_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_exists_running_job_on_client_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_init_volumes_args(object):
  """
  Attributes:
   - request_json
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'request_json', None, None, ), # 1
  )

  def __init__(self, request_json=None,):
    self.request_json = request_json

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.request_json = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_init_volumes_args')
    if self.request_json is not None:
      oprot.writeFieldBegin('request_json', TType.STRING, 1)
      oprot.writeString(self.request_json.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request_json)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_init_volumes_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_init_volumes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_on_log_volume_formatted_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_on_log_volume_formatted_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_on_log_volume_formatted_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_on_log_volume_formatted_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_mount_log_volume_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_mount_log_volume_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_mount_log_volume_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_mount_log_volume_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_clean_base_volumes_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_clean_base_volumes_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_clean_base_volumes_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_clean_base_volumes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_on_reboot_recheck_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_on_reboot_recheck_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_on_reboot_recheck_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_on_reboot_recheck_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_update_devs_args(object):
  """
  Attributes:
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobId', None, None, ), # 1
  )

  def __init__(self, jobId=None,):
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_update_devs_args')
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 1)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_update_devs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_update_devs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_create_snapshot_args(object):
  """
  Attributes:
   - timeStamp
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timeStamp', None, None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, timeStamp=None, jobId=None,):
    self.timeStamp = timeStamp
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timeStamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_create_snapshot_args')
    if self.timeStamp is not None:
      oprot.writeFieldBegin('timeStamp', TType.I64, 1)
      oprot.writeI64(self.timeStamp)
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.timeStamp)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cdp_backup_create_snapshot_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cdp_backup_create_snapshot_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_new_vm_args(object):
  """
  Attributes:
   - vmConfig
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'vmConfig', (ncVirtualMachine.ttypes.ncVMConfig, ncVirtualMachine.ttypes.ncVMConfig.thrift_spec), None, ), # 1
  )

  def __init__(self, vmConfig=None,):
    self.vmConfig = vmConfig

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.vmConfig = ncVirtualMachine.ttypes.ncVMConfig()
          self.vmConfig.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_new_vm_args')
    if self.vmConfig is not None:
      oprot.writeFieldBegin('vmConfig', TType.STRUCT, 1)
      self.vmConfig.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmConfig)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_new_vm_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_new_vm_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class vm_power_control_args(object):
  """
  Attributes:
   - vmName
   - vmControlStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.I32, 'vmControlStatus', None, None, ), # 2
  )

  def __init__(self, vmName=None, vmControlStatus=None,):
    self.vmName = vmName
    self.vmControlStatus = vmControlStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.vmControlStatus = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('vm_power_control_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.vmControlStatus is not None:
      oprot.writeFieldBegin('vmControlStatus', TType.I32, 2)
      oprot.writeI32(self.vmControlStatus)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.vmControlStatus)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class vm_power_control_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('vm_power_control_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_console_url_args(object):
  """
  Attributes:
   - vmName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
  )

  def __init__(self, vmName=None,):
    self.vmName = vmName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_console_url_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_console_url_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_console_url_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_args(object):
  """
  Attributes:
   - vmName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
  )

  def __init__(self, vmName=None,):
    self.vmName = vmName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_config_args(object):
  """
  Attributes:
   - vmName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
  )

  def __init__(self, vmName=None,):
    self.vmName = vmName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_config_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_config_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncVirtualMachine.ttypes.ncVMConfig, ncVirtualMachine.ttypes.ncVMConfig.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncVirtualMachine.ttypes.ncVMConfig()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_config_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_status_args(object):
  """
  Attributes:
   - vmName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
  )

  def __init__(self, vmName=None,):
    self.vmName = vmName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_status_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_vm_status_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_vm_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class edit_vm_hardware_args(object):
  """
  Attributes:
   - vmName
   - slots
   - cores
   - mem_size
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.I32, 'slots', None, None, ), # 2
    (3, TType.I32, 'cores', None, None, ), # 3
    (4, TType.I64, 'mem_size', None, None, ), # 4
  )

  def __init__(self, vmName=None, slots=None, cores=None, mem_size=None,):
    self.vmName = vmName
    self.slots = slots
    self.cores = cores
    self.mem_size = mem_size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.slots = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cores = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.mem_size = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('edit_vm_hardware_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.slots is not None:
      oprot.writeFieldBegin('slots', TType.I32, 2)
      oprot.writeI32(self.slots)
      oprot.writeFieldEnd()
    if self.cores is not None:
      oprot.writeFieldBegin('cores', TType.I32, 3)
      oprot.writeI32(self.cores)
      oprot.writeFieldEnd()
    if self.mem_size is not None:
      oprot.writeFieldBegin('mem_size', TType.I64, 4)
      oprot.writeI64(self.mem_size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.slots)
    value = (value * 31) ^ hash(self.cores)
    value = (value * 31) ^ hash(self.mem_size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class edit_vm_hardware_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('edit_vm_hardware_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_vm_disk_args(object):
  """
  Attributes:
   - poolId
   - diskSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'poolId', None, None, ), # 1
    (2, TType.I64, 'diskSize', None, None, ), # 2
  )

  def __init__(self, poolId=None, diskSize=None,):
    self.poolId = poolId
    self.diskSize = diskSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.diskSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_vm_disk_args')
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 1)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.diskSize is not None:
      oprot.writeFieldBegin('diskSize', TType.I64, 2)
      oprot.writeI64(self.diskSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolId)
    value = (value * 31) ^ hash(self.diskSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_vm_disk_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncVirtualMachine.ttypes.ncCDMVolume, ncVirtualMachine.ttypes.ncCDMVolume.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncVirtualMachine.ttypes.ncCDMVolume()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_vm_disk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_disk_dev_by_cfgstr_args(object):
  """
  Attributes:
   - cfgstring
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cfgstring', None, None, ), # 1
  )

  def __init__(self, cfgstring=None,):
    self.cfgstring = cfgstring

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cfgstring = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_disk_dev_by_cfgstr_args')
    if self.cfgstring is not None:
      oprot.writeFieldBegin('cfgstring', TType.STRING, 1)
      oprot.writeString(self.cfgstring.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cfgstring)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_disk_dev_by_cfgstr_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_disk_dev_by_cfgstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_disk_args(object):
  """
  Attributes:
   - vmName
   - new_cdm_disk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'new_cdm_disk', (ncVirtualMachine.ttypes.ncCDMVolume, ncVirtualMachine.ttypes.ncCDMVolume.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, new_cdm_disk=None,):
    self.vmName = vmName
    self.new_cdm_disk = new_cdm_disk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.new_cdm_disk = ncVirtualMachine.ttypes.ncCDMVolume()
          self.new_cdm_disk.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_disk_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.new_cdm_disk is not None:
      oprot.writeFieldBegin('new_cdm_disk', TType.STRUCT, 2)
      self.new_cdm_disk.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.new_cdm_disk)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_disk_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncVirtualMachine.ttypes.ncVMDisk, ncVirtualMachine.ttypes.ncVMDisk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncVirtualMachine.ttypes.ncVMDisk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_disk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_disk_args(object):
  """
  Attributes:
   - vmName
   - disk_solt
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.I32, 'disk_solt', None, None, ), # 2
  )

  def __init__(self, vmName=None, disk_solt=None,):
    self.vmName = vmName
    self.disk_solt = disk_solt

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.disk_solt = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_disk_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.disk_solt is not None:
      oprot.writeFieldBegin('disk_solt', TType.I32, 2)
      oprot.writeI32(self.disk_solt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.disk_solt)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_disk_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_disk_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_new_net_args(object):
  """
  Attributes:
   - vmName
   - net_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'net_config', (ncVirtualMachine.ttypes.ncVMNetWork, ncVirtualMachine.ttypes.ncVMNetWork.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, net_config=None,):
    self.vmName = vmName
    self.net_config = net_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.net_config = ncVirtualMachine.ttypes.ncVMNetWork()
          self.net_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_new_net_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.net_config is not None:
      oprot.writeFieldBegin('net_config', TType.STRUCT, 2)
      self.net_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.net_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_new_net_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_new_net_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class edit_vm_net_args(object):
  """
  Attributes:
   - vmName
   - net_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'net_config', (ncVirtualMachine.ttypes.ncVMNetWork, ncVirtualMachine.ttypes.ncVMNetWork.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, net_config=None,):
    self.vmName = vmName
    self.net_config = net_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.net_config = ncVirtualMachine.ttypes.ncVMNetWork()
          self.net_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('edit_vm_net_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.net_config is not None:
      oprot.writeFieldBegin('net_config', TType.STRUCT, 2)
      self.net_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.net_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class edit_vm_net_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('edit_vm_net_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_net_args(object):
  """
  Attributes:
   - vmName
   - net_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'net_config', (ncVirtualMachine.ttypes.ncVMNetWork, ncVirtualMachine.ttypes.ncVMNetWork.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, net_config=None,):
    self.vmName = vmName
    self.net_config = net_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.net_config = ncVirtualMachine.ttypes.ncVMNetWork()
          self.net_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_net_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.net_config is not None:
      oprot.writeFieldBegin('net_config', TType.STRUCT, 2)
      self.net_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.net_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_net_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_net_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_new_iso_args(object):
  """
  Attributes:
   - vmName
   - iso_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'iso_config', (ncVirtualMachine.ttypes.ncVMISO, ncVirtualMachine.ttypes.ncVMISO.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, iso_config=None,):
    self.vmName = vmName
    self.iso_config = iso_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.iso_config = ncVirtualMachine.ttypes.ncVMISO()
          self.iso_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_new_iso_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.iso_config is not None:
      oprot.writeFieldBegin('iso_config', TType.STRUCT, 2)
      self.iso_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.iso_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_vm_new_iso_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_vm_new_iso_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_iso_args(object):
  """
  Attributes:
   - vmName
   - iso_config
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRUCT, 'iso_config', (ncVirtualMachine.ttypes.ncVMISO, ncVirtualMachine.ttypes.ncVMISO.thrift_spec), None, ), # 2
  )

  def __init__(self, vmName=None, iso_config=None,):
    self.vmName = vmName
    self.iso_config = iso_config

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.iso_config = ncVirtualMachine.ttypes.ncVMISO()
          self.iso_config.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_iso_args')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.iso_config is not None:
      oprot.writeFieldBegin('iso_config', TType.STRUCT, 2)
      self.iso_config.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.iso_config)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_vm_iso_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_vm_iso_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dev_name_args(object):
  """
  Attributes:
   - cfgstring
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cfgstring', None, None, ), # 1
  )

  def __init__(self, cfgstring=None,):
    self.cfgstring = cfgstring

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cfgstring = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dev_name_args')
    if self.cfgstring is not None:
      oprot.writeFieldBegin('cfgstring', TType.STRING, 1)
      oprot.writeString(self.cfgstring.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cfgstring)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dev_name_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dev_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dev_name_by_scan_args(object):
  """
  Attributes:
   - request_json
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'request_json', None, None, ), # 1
  )

  def __init__(self, request_json=None,):
    self.request_json = request_json

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.request_json = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dev_name_by_scan_args')
    if self.request_json is not None:
      oprot.writeFieldBegin('request_json', TType.STRING, 1)
      oprot.writeString(self.request_json.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request_json)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_dev_name_by_scan_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_dev_name_by_scan_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_iscsi_iqn_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_iscsi_iqn_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_iscsi_iqn_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_iscsi_iqn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_filter_jobs_args(object):
  """
  Attributes:
   - get_req
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'get_req', (ncCommonType.ttypes.ncGetJobsReq, ncCommonType.ttypes.ncGetJobsReq.thrift_spec), None, ), # 1
  )

  def __init__(self, get_req=None,):
    self.get_req = get_req

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.get_req = ncCommonType.ttypes.ncGetJobsReq()
          self.get_req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_filter_jobs_args')
    if self.get_req is not None:
      oprot.writeFieldBegin('get_req', TType.STRUCT, 1)
      self.get_req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.get_req)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_filter_jobs_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = ncJob.ttypes.ncTJob()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_filter_jobs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class backup_export_log_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype36, _vtype37, _size35 ) = iprot.readMapBegin()
          for _i39 in xrange(_size35):
            _key40 = iprot.readString().decode('utf-8')
            _val41 = iprot.readString().decode('utf-8')
            self.body[_key40] = _val41
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('backup_export_log_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter42,viter43 in self.body.items():
        oprot.writeString(kiter42.encode('utf-8'))
        oprot.writeString(viter43.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class backup_export_log_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype45, _vtype46, _size44 ) = iprot.readMapBegin()
          for _i48 in xrange(_size44):
            _key49 = iprot.readString().decode('utf-8')
            _val50 = iprot.readString().decode('utf-8')
            self.success[_key49] = _val50
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('backup_export_log_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter51,viter52 in self.success.items():
        oprot.writeString(kiter51.encode('utf-8'))
        oprot.writeString(viter52.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drill_job_logs_export_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype54, _vtype55, _size53 ) = iprot.readMapBegin()
          for _i57 in xrange(_size53):
            _key58 = iprot.readString().decode('utf-8')
            _val59 = iprot.readString().decode('utf-8')
            self.body[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drill_job_logs_export_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter60,viter61 in self.body.items():
        oprot.writeString(kiter60.encode('utf-8'))
        oprot.writeString(viter61.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drill_job_logs_export_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype63, _vtype64, _size62 ) = iprot.readMapBegin()
          for _i66 in xrange(_size62):
            _key67 = iprot.readString().decode('utf-8')
            _val68 = iprot.readString().decode('utf-8')
            self.success[_key67] = _val68
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drill_job_logs_export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter69,viter70 in self.success.items():
        oprot.writeString(kiter69.encode('utf-8'))
        oprot.writeString(viter70.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mount_job_logs_export_args(object):
  """
  Attributes:
   - body
   - jobInstanceId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'body', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'jobInstanceId', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, body=None, jobInstanceId=None, userId=None,):
    self.body = body
    self.jobInstanceId = jobInstanceId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.body = {}
          (_ktype72, _vtype73, _size71 ) = iprot.readMapBegin()
          for _i75 in xrange(_size71):
            _key76 = iprot.readString().decode('utf-8')
            _val77 = iprot.readString().decode('utf-8')
            self.body[_key76] = _val77
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobInstanceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mount_job_logs_export_args')
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.body))
      for kiter78,viter79 in self.body.items():
        oprot.writeString(kiter78.encode('utf-8'))
        oprot.writeString(viter79.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobInstanceId is not None:
      oprot.writeFieldBegin('jobInstanceId', TType.STRING, 2)
      oprot.writeString(self.jobInstanceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.body)
    value = (value * 31) ^ hash(self.jobInstanceId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mount_job_logs_export_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype81, _vtype82, _size80 ) = iprot.readMapBegin()
          for _i84 in xrange(_size80):
            _key85 = iprot.readString().decode('utf-8')
            _val86 = iprot.readString().decode('utf-8')
            self.success[_key85] = _val86
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mount_job_logs_export_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter87,viter88 in self.success.items():
        oprot.writeString(kiter87.encode('utf-8'))
        oprot.writeString(viter88.encode('utf-8'))
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_cdp_volume_driver_used_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_cdp_volume_driver_used_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_cdp_volume_driver_used_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_cdp_volume_driver_used_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_client_protected_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_client_protected_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_client_protected_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_client_protected_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_sourceId_args(object):
  """
  Attributes:
   - sourceType
   - svcType
   - sourceId
   - relation
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sourceType', None, None, ), # 1
    (2, TType.I32, 'svcType', None, None, ), # 2
    (3, TType.STRING, 'sourceId', None, None, ), # 3
    (4, TType.I32, 'relation', None,     1, ), # 4
  )

  def __init__(self, sourceType=None, svcType=None, sourceId=None, relation=thrift_spec[4][4],):
    self.sourceType = sourceType
    self.svcType = svcType
    self.sourceId = sourceId
    self.relation = relation

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sourceType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.svcType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.sourceId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.relation = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_sourceId_args')
    if self.sourceType is not None:
      oprot.writeFieldBegin('sourceType', TType.I32, 1)
      oprot.writeI32(self.sourceType)
      oprot.writeFieldEnd()
    if self.svcType is not None:
      oprot.writeFieldBegin('svcType', TType.I32, 2)
      oprot.writeI32(self.svcType)
      oprot.writeFieldEnd()
    if self.sourceId is not None:
      oprot.writeFieldBegin('sourceId', TType.STRING, 3)
      oprot.writeString(self.sourceId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.relation is not None:
      oprot.writeFieldBegin('relation', TType.I32, 4)
      oprot.writeI32(self.relation)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sourceType)
    value = (value * 31) ^ hash(self.svcType)
    value = (value * 31) ^ hash(self.sourceId)
    value = (value * 31) ^ hash(self.relation)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_sourceId_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncTJob, ncJob.ttypes.ncTJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype92, _size89) = iprot.readListBegin()
          for _i93 in xrange(_size89):
            _elem94 = ncJob.ttypes.ncTJob()
            _elem94.read(iprot)
            self.success.append(_elem94)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_sourceId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter95 in self.success:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_disk_to_repair_vm_args(object):
  """
  Attributes:
   - disk_list
   - os_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'disk_list', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'os_type', None, None, ), # 2
  )

  def __init__(self, disk_list=None, os_type=None,):
    self.disk_list = disk_list
    self.os_type = os_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.disk_list = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = iprot.readString().decode('utf-8')
            self.disk_list.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.os_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_disk_to_repair_vm_args')
    if self.disk_list is not None:
      oprot.writeFieldBegin('disk_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.disk_list))
      for iter102 in self.disk_list:
        oprot.writeString(iter102.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.os_type is not None:
      oprot.writeFieldBegin('os_type', TType.I32, 2)
      oprot.writeI32(self.os_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.disk_list)
    value = (value * 31) ^ hash(self.os_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_disk_to_repair_vm_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_disk_to_repair_vm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_disk_from_repair_vm_args(object):
  """
  Attributes:
   - disk_list
   - os_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'disk_list', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'os_type', None, None, ), # 2
  )

  def __init__(self, disk_list=None, os_type=None,):
    self.disk_list = disk_list
    self.os_type = os_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.disk_list = []
          (_etype106, _size103) = iprot.readListBegin()
          for _i107 in xrange(_size103):
            _elem108 = iprot.readString().decode('utf-8')
            self.disk_list.append(_elem108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.os_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_disk_from_repair_vm_args')
    if self.disk_list is not None:
      oprot.writeFieldBegin('disk_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.disk_list))
      for iter109 in self.disk_list:
        oprot.writeString(iter109.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.os_type is not None:
      oprot.writeFieldBegin('os_type', TType.I32, 2)
      oprot.writeI32(self.os_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.disk_list)
    value = (value * 31) ^ hash(self.os_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_disk_from_repair_vm_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_disk_from_repair_vm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_datasource_args(object):
  """
  Attributes:
   - datasource
   - clientId
   - dbRunUserName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'datasource', None, None, ), # 1
    (2, TType.STRING, 'clientId', None, None, ), # 2
    (3, TType.STRING, 'dbRunUserName', None, None, ), # 3
  )

  def __init__(self, datasource=None, clientId=None, dbRunUserName=None,):
    self.datasource = datasource
    self.clientId = clientId
    self.dbRunUserName = dbRunUserName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.datasource = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dbRunUserName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_datasource_args')
    if self.datasource is not None:
      oprot.writeFieldBegin('datasource', TType.STRING, 1)
      oprot.writeString(self.datasource.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 2)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.dbRunUserName is not None:
      oprot.writeFieldBegin('dbRunUserName', TType.STRING, 3)
      oprot.writeString(self.dbRunUserName.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.datasource)
    value = (value * 31) ^ hash(self.clientId)
    value = (value * 31) ^ hash(self.dbRunUserName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_by_datasource_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncJob.ttypes.ncBackupJob, ncJob.ttypes.ncBackupJob.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = ncJob.ttypes.ncBackupJob()
            _elem115.read(iprot)
            self.success.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_by_datasource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter116 in self.success:
        iter116.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_user_has_data_args(object):
  """
  Attributes:
   - user_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'user_list', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_list=None,):
    self.user_list = user_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.user_list = []
          (_etype120, _size117) = iprot.readListBegin()
          for _i121 in xrange(_size117):
            _elem122 = iprot.readString().decode('utf-8')
            self.user_list.append(_elem122)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_user_has_data_args')
    if self.user_list is not None:
      oprot.writeFieldBegin('user_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.user_list))
      for iter123 in self.user_list:
        oprot.writeString(iter123.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class check_user_has_data_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readString().decode('utf-8')
            self.success.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('check_user_has_data_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter130 in self.success:
        oprot.writeString(iter130.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_count_info_args(object):
  """
  Attributes:
   - startTime
   - isBackup
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'startTime', None, None, ), # 1
    (2, TType.I32, 'isBackup', None, None, ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
  )

  def __init__(self, startTime=None, isBackup=None, userId=None,):
    self.startTime = startTime
    self.isBackup = isBackup
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.startTime = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isBackup = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_count_info_args')
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.I64, 1)
      oprot.writeI64(self.startTime)
      oprot.writeFieldEnd()
    if self.isBackup is not None:
      oprot.writeFieldBegin('isBackup', TType.I32, 2)
      oprot.writeI32(self.isBackup)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startTime)
    value = (value * 31) ^ hash(self.isBackup)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_jobs_count_info_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdpProcess.ttypes.ncCDPJobCountInfo, ncCdpProcess.ttypes.ncCDPJobCountInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdpProcess.ttypes.ncCDPJobCountInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_jobs_count_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class has_realtimejob_run_users_args(object):
  """
  Attributes:
   - user_ids
   - job_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'user_ids', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'job_type', None, None, ), # 2
  )

  def __init__(self, user_ids=None, job_type=None,):
    self.user_ids = user_ids
    self.job_type = job_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.user_ids = []
          (_etype134, _size131) = iprot.readListBegin()
          for _i135 in xrange(_size131):
            _elem136 = iprot.readString().decode('utf-8')
            self.user_ids.append(_elem136)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('has_realtimejob_run_users_args')
    if self.user_ids is not None:
      oprot.writeFieldBegin('user_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.user_ids))
      for iter137 in self.user_ids:
        oprot.writeString(iter137.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.job_type is not None:
      oprot.writeFieldBegin('job_type', TType.I32, 2)
      oprot.writeI32(self.job_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_ids)
    value = (value * 31) ^ hash(self.job_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class has_realtimejob_run_users_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdpProcess.ttypes.ncCDPJobRunningUserInfo, ncCdpProcess.ttypes.ncCDPJobRunningUserInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdpProcess.ttypes.ncCDPJobRunningUserInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('has_realtimejob_run_users_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class client_exsit_job_args(object):
  """
  Attributes:
   - clientId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientId', None, None, ), # 1
  )

  def __init__(self, clientId=None,):
    self.clientId = clientId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('client_exsit_job_args')
    if self.clientId is not None:
      oprot.writeFieldBegin('clientId', TType.STRING, 1)
      oprot.writeString(self.clientId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.clientId is None:
      raise TProtocol.TProtocolException(message='Required field clientId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class client_exsit_job_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('client_exsit_job_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_extra_resource_by_username_args(object):
  """
  Attributes:
   - user_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'user_names', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, user_names=None,):
    self.user_names = user_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.user_names = []
          (_etype141, _size138) = iprot.readListBegin()
          for _i142 in xrange(_size138):
            _elem143 = iprot.readString().decode('utf-8')
            self.user_names.append(_elem143)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_extra_resource_by_username_args')
    if self.user_names is not None:
      oprot.writeFieldBegin('user_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.user_names))
      for iter144 in self.user_names:
        oprot.writeString(iter144.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user_names)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_extra_resource_by_username_result(object):
  """
  Attributes:
   - error
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, error=None,):
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_extra_resource_by_username_result')
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
