#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ncTfFusionObjType(object):
  NC_TF_TYPE_UNDEFINE = 0
  NC_TF_TYPE_ROOT_OBJ = 1
  NC_TF_TYPE_SITE_OBJ = 2
  NC_TF_TYPE_CLUSTFOLDER_OBJ = 3
  NC_TF_TYPE_CLUSTER_OBJ = 4
  NC_TF_TYPE_HOST_OBJ = 5
  NC_TF_TYPE_VM_OBJ = 6

  _VALUES_TO_NAMES = {
    0: "NC_TF_TYPE_UNDEFINE",
    1: "NC_TF_TYPE_ROOT_OBJ",
    2: "NC_TF_TYPE_SITE_OBJ",
    3: "NC_TF_TYPE_CLUSTFOLDER_OBJ",
    4: "NC_TF_TYPE_CLUSTER_OBJ",
    5: "NC_TF_TYPE_HOST_OBJ",
    6: "NC_TF_TYPE_VM_OBJ",
  }

  _NAMES_TO_VALUES = {
    "NC_TF_TYPE_UNDEFINE": 0,
    "NC_TF_TYPE_ROOT_OBJ": 1,
    "NC_TF_TYPE_SITE_OBJ": 2,
    "NC_TF_TYPE_CLUSTFOLDER_OBJ": 3,
    "NC_TF_TYPE_CLUSTER_OBJ": 4,
    "NC_TF_TYPE_HOST_OBJ": 5,
    "NC_TF_TYPE_VM_OBJ": 6,
  }


class ncTfFusionObjInfo(object):
  """
  Attributes:
   - urn
   - name
   - uuid
   - tfType
   - leaf
   - checkable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'uuid', None, None, ), # 3
    (4, TType.I32, 'tfType', None, None, ), # 4
    (5, TType.BOOL, 'leaf', None, None, ), # 5
    (6, TType.BOOL, 'checkable', None, None, ), # 6
  )

  def __init__(self, urn=None, name=None, uuid=None, tfType=None, leaf=None, checkable=None,):
    self.urn = urn
    self.name = name
    self.uuid = uuid
    self.tfType = tfType
    self.leaf = leaf
    self.checkable = checkable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.tfType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.leaf = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.checkable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionObjInfo')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 3)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tfType is not None:
      oprot.writeFieldBegin('tfType', TType.I32, 4)
      oprot.writeI32(self.tfType)
      oprot.writeFieldEnd()
    if self.leaf is not None:
      oprot.writeFieldBegin('leaf', TType.BOOL, 5)
      oprot.writeBool(self.leaf)
      oprot.writeFieldEnd()
    if self.checkable is not None:
      oprot.writeFieldBegin('checkable', TType.BOOL, 6)
      oprot.writeBool(self.checkable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.tfType)
    value = (value * 31) ^ hash(self.leaf)
    value = (value * 31) ^ hash(self.checkable)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionQueryObjInfo(object):
  """
  Attributes:
   - urn
   - tfType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.I32, 'tfType', None, None, ), # 2
  )

  def __init__(self, urn=None, tfType=None,):
    self.urn = urn
    self.tfType = tfType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.tfType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionQueryObjInfo')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tfType is not None:
      oprot.writeFieldBegin('tfType', TType.I32, 2)
      oprot.writeI32(self.tfType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.tfType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionObjInfoLSet(object):
  """
  Attributes:
   - objInfos
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'objInfos', (TType.STRUCT,(ncTfFusionObjInfo, ncTfFusionObjInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, objInfos=None,):
    self.objInfos = objInfos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.objInfos = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncTfFusionObjInfo()
            _elem5.read(iprot)
            self.objInfos.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionObjInfoLSet')
    if self.objInfos is not None:
      oprot.writeFieldBegin('objInfos', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.objInfos))
      for iter6 in self.objInfos:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.objInfos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionDataStoreInfo(object):
  """
  Attributes:
   - urn
   - name
   - storageType
   - storageSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'storageType', None, None, ), # 3
    (4, TType.I32, 'storageSize', None, None, ), # 4
  )

  def __init__(self, urn=None, name=None, storageType=None, storageSize=None,):
    self.urn = urn
    self.name = name
    self.storageType = storageType
    self.storageSize = storageSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.storageType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.storageSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionDataStoreInfo')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.storageType is not None:
      oprot.writeFieldBegin('storageType', TType.STRING, 3)
      oprot.writeString(self.storageType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.storageSize is not None:
      oprot.writeFieldBegin('storageSize', TType.I32, 4)
      oprot.writeI32(self.storageSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.storageType)
    value = (value * 31) ^ hash(self.storageSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionDataStoreInfoSet(object):
  """
  Attributes:
   - datastores
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'datastores', (TType.STRUCT,(ncTfFusionDataStoreInfo, ncTfFusionDataStoreInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, datastores=None,):
    self.datastores = datastores

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.datastores = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = ncTfFusionDataStoreInfo()
            _elem12.read(iprot)
            self.datastores.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionDataStoreInfoSet')
    if self.datastores is not None:
      oprot.writeFieldBegin('datastores', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.datastores))
      for iter13 in self.datastores:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.datastores)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionPortGroupInfo(object):
  """
  Attributes:
   - urn
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, urn=None, name=None,):
    self.urn = urn
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionPortGroupInfo')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionDvswitchInfo(object):
  """
  Attributes:
   - urn
   - name
   - portGroups
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.LIST, 'portGroups', (TType.STRUCT,(ncTfFusionPortGroupInfo, ncTfFusionPortGroupInfo.thrift_spec)), None, ), # 3
  )

  def __init__(self, urn=None, name=None, portGroups=None,):
    self.urn = urn
    self.name = name
    self.portGroups = portGroups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.portGroups = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = ncTfFusionPortGroupInfo()
            _elem19.read(iprot)
            self.portGroups.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionDvswitchInfo')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.portGroups is not None:
      oprot.writeFieldBegin('portGroups', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.portGroups))
      for iter20 in self.portGroups:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.portGroups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionDvswitchInfoSet(object):
  """
  Attributes:
   - dvswitchInfos
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'dvswitchInfos', (TType.STRUCT,(ncTfFusionDvswitchInfo, ncTfFusionDvswitchInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, dvswitchInfos=None,):
    self.dvswitchInfos = dvswitchInfos

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.dvswitchInfos = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = ncTfFusionDvswitchInfo()
            _elem26.read(iprot)
            self.dvswitchInfos.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionDvswitchInfoSet')
    if self.dvswitchInfos is not None:
      oprot.writeFieldBegin('dvswitchInfos', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.dvswitchInfos))
      for iter27 in self.dvswitchInfos:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dvswitchInfos)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionPortGroupInfoSet(object):
  """
  Attributes:
   - portGroups
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'portGroups', (TType.STRUCT,(ncTfFusionPortGroupInfo, ncTfFusionPortGroupInfo.thrift_spec)), None, ), # 1
  )

  def __init__(self, portGroups=None,):
    self.portGroups = portGroups

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.portGroups = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = ncTfFusionPortGroupInfo()
            _elem33.read(iprot)
            self.portGroups.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionPortGroupInfoSet')
    if self.portGroups is not None:
      oprot.writeFieldBegin('portGroups', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.portGroups))
      for iter34 in self.portGroups:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.portGroups)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionLoginInfo(object):
  """
  Attributes:
   - svrIp
   - port
   - userName
   - password
   - customer
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'svrIp', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.STRING, 'userName', None, None, ), # 3
    (4, TType.STRING, 'password', None, None, ), # 4
    (5, TType.STRING, 'customer', None, None, ), # 5
  )

  def __init__(self, svrIp=None, port=None, userName=None, password=None, customer=None,):
    self.svrIp = svrIp
    self.port = port
    self.userName = userName
    self.password = password
    self.customer = customer

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.svrIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.password = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.customer = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionLoginInfo')
    if self.svrIp is not None:
      oprot.writeFieldBegin('svrIp', TType.STRING, 1)
      oprot.writeString(self.svrIp.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 3)
      oprot.writeString(self.userName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 4)
      oprot.writeString(self.password.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.customer is not None:
      oprot.writeFieldBegin('customer', TType.STRING, 5)
      oprot.writeString(self.customer.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.svrIp)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.userName)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.customer)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionObjectRequest(object):
  """
  Attributes:
   - loginInfo
   - objInfo
   - serverId
   - vplatformId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'loginInfo', (ncTfFusionLoginInfo, ncTfFusionLoginInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'objInfo', (ncTfFusionQueryObjInfo, ncTfFusionQueryObjInfo.thrift_spec), None, ), # 2
    (3, TType.STRING, 'serverId', None, None, ), # 3
    (4, TType.STRING, 'vplatformId', None, None, ), # 4
  )

  def __init__(self, loginInfo=None, objInfo=None, serverId=None, vplatformId=None,):
    self.loginInfo = loginInfo
    self.objInfo = objInfo
    self.serverId = serverId
    self.vplatformId = vplatformId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.loginInfo = ncTfFusionLoginInfo()
          self.loginInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.objInfo = ncTfFusionQueryObjInfo()
          self.objInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.serverId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.vplatformId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionObjectRequest')
    if self.loginInfo is not None:
      oprot.writeFieldBegin('loginInfo', TType.STRUCT, 1)
      self.loginInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.objInfo is not None:
      oprot.writeFieldBegin('objInfo', TType.STRUCT, 2)
      self.objInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.serverId is not None:
      oprot.writeFieldBegin('serverId', TType.STRING, 3)
      oprot.writeString(self.serverId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.vplatformId is not None:
      oprot.writeFieldBegin('vplatformId', TType.STRING, 4)
      oprot.writeString(self.vplatformId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.loginInfo)
    value = (value * 31) ^ hash(self.objInfo)
    value = (value * 31) ^ hash(self.serverId)
    value = (value * 31) ^ hash(self.vplatformId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionDiskInfo(object):
  """
  Attributes:
   - sequenceNum
   - quantityGB
   - volumeUrn
   - storageType
   - diskName
   - datastoreName
   - datastoreUrn
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sequenceNum', None, None, ), # 1
    (2, TType.I32, 'quantityGB', None, None, ), # 2
    (3, TType.STRING, 'volumeUrn', None, None, ), # 3
    (4, TType.STRING, 'storageType', None, None, ), # 4
    (5, TType.STRING, 'diskName', None, None, ), # 5
    (6, TType.STRING, 'datastoreName', None, None, ), # 6
    (7, TType.STRING, 'datastoreUrn', None, None, ), # 7
  )

  def __init__(self, sequenceNum=None, quantityGB=None, volumeUrn=None, storageType=None, diskName=None, datastoreName=None, datastoreUrn=None,):
    self.sequenceNum = sequenceNum
    self.quantityGB = quantityGB
    self.volumeUrn = volumeUrn
    self.storageType = storageType
    self.diskName = diskName
    self.datastoreName = datastoreName
    self.datastoreUrn = datastoreUrn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sequenceNum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.quantityGB = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.volumeUrn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.storageType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.diskName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.datastoreName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.datastoreUrn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionDiskInfo')
    if self.sequenceNum is not None:
      oprot.writeFieldBegin('sequenceNum', TType.I32, 1)
      oprot.writeI32(self.sequenceNum)
      oprot.writeFieldEnd()
    if self.quantityGB is not None:
      oprot.writeFieldBegin('quantityGB', TType.I32, 2)
      oprot.writeI32(self.quantityGB)
      oprot.writeFieldEnd()
    if self.volumeUrn is not None:
      oprot.writeFieldBegin('volumeUrn', TType.STRING, 3)
      oprot.writeString(self.volumeUrn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.storageType is not None:
      oprot.writeFieldBegin('storageType', TType.STRING, 4)
      oprot.writeString(self.storageType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.diskName is not None:
      oprot.writeFieldBegin('diskName', TType.STRING, 5)
      oprot.writeString(self.diskName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.datastoreName is not None:
      oprot.writeFieldBegin('datastoreName', TType.STRING, 6)
      oprot.writeString(self.datastoreName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.datastoreUrn is not None:
      oprot.writeFieldBegin('datastoreUrn', TType.STRING, 7)
      oprot.writeString(self.datastoreUrn.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sequenceNum)
    value = (value * 31) ^ hash(self.quantityGB)
    value = (value * 31) ^ hash(self.volumeUrn)
    value = (value * 31) ^ hash(self.storageType)
    value = (value * 31) ^ hash(self.diskName)
    value = (value * 31) ^ hash(self.datastoreName)
    value = (value * 31) ^ hash(self.datastoreUrn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionNicInfo(object):
  """
  Attributes:
   - name
   - urn
   - portGroupUrn
   - portGroupName
   - dvSwitchName
   - dvSwitchUrn
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'urn', None, None, ), # 2
    (3, TType.STRING, 'portGroupUrn', None, None, ), # 3
    (4, TType.STRING, 'portGroupName', None, None, ), # 4
    (5, TType.STRING, 'dvSwitchName', None, None, ), # 5
    (6, TType.STRING, 'dvSwitchUrn', None, None, ), # 6
  )

  def __init__(self, name=None, urn=None, portGroupUrn=None, portGroupName=None, dvSwitchName=None, dvSwitchUrn=None,):
    self.name = name
    self.urn = urn
    self.portGroupUrn = portGroupUrn
    self.portGroupName = portGroupName
    self.dvSwitchName = dvSwitchName
    self.dvSwitchUrn = dvSwitchUrn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.portGroupUrn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.portGroupName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.dvSwitchName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.dvSwitchUrn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionNicInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 2)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.portGroupUrn is not None:
      oprot.writeFieldBegin('portGroupUrn', TType.STRING, 3)
      oprot.writeString(self.portGroupUrn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.portGroupName is not None:
      oprot.writeFieldBegin('portGroupName', TType.STRING, 4)
      oprot.writeString(self.portGroupName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.dvSwitchName is not None:
      oprot.writeFieldBegin('dvSwitchName', TType.STRING, 5)
      oprot.writeString(self.dvSwitchName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.dvSwitchUrn is not None:
      oprot.writeFieldBegin('dvSwitchUrn', TType.STRING, 6)
      oprot.writeString(self.dvSwitchUrn.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.portGroupUrn)
    value = (value * 31) ^ hash(self.portGroupName)
    value = (value * 31) ^ hash(self.dvSwitchName)
    value = (value * 31) ^ hash(self.dvSwitchUrn)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncTfFusionVmDetails(object):
  """
  Attributes:
   - urn
   - vmName
   - location
   - locationName
   - nicsInfo
   - disksInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'urn', None, None, ), # 1
    (2, TType.STRING, 'vmName', None, None, ), # 2
    (3, TType.STRING, 'location', None, None, ), # 3
    (4, TType.STRING, 'locationName', None, None, ), # 4
    (5, TType.LIST, 'nicsInfo', (TType.STRUCT,(ncTfFusionNicInfo, ncTfFusionNicInfo.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'disksInfo', (TType.STRUCT,(ncTfFusionDiskInfo, ncTfFusionDiskInfo.thrift_spec)), None, ), # 6
  )

  def __init__(self, urn=None, vmName=None, location=None, locationName=None, nicsInfo=None, disksInfo=None,):
    self.urn = urn
    self.vmName = vmName
    self.location = location
    self.locationName = locationName
    self.nicsInfo = nicsInfo
    self.disksInfo = disksInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.urn = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.location = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.locationName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.nicsInfo = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = ncTfFusionNicInfo()
            _elem40.read(iprot)
            self.nicsInfo.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.disksInfo = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = ncTfFusionDiskInfo()
            _elem46.read(iprot)
            self.disksInfo.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncTfFusionVmDetails')
    if self.urn is not None:
      oprot.writeFieldBegin('urn', TType.STRING, 1)
      oprot.writeString(self.urn.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 2)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 3)
      oprot.writeString(self.location.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.locationName is not None:
      oprot.writeFieldBegin('locationName', TType.STRING, 4)
      oprot.writeString(self.locationName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.nicsInfo is not None:
      oprot.writeFieldBegin('nicsInfo', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.nicsInfo))
      for iter47 in self.nicsInfo:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.disksInfo is not None:
      oprot.writeFieldBegin('disksInfo', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.disksInfo))
      for iter48 in self.disksInfo:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.urn)
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.location)
    value = (value * 31) ^ hash(self.locationName)
    value = (value * 31) ^ hash(self.nicsInfo)
    value = (value * 31) ^ hash(self.disksInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
