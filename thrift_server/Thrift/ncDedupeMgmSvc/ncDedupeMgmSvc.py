#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  Dedupe服务接口
  """
  def GetDedupeNodes(self):
    """
    获取可用的重删节点ip
    @ return list<string>: 重删节点IP集合

    """
    pass

  def CreateFingerprintPool(self, poolInfo):
    """
       * 添加逻辑指纹库
       * @param poolInfo.poolName: 指纹库名称
    * @param poolInfo.poolType: 指纹库类型
    * @param poolInfo.poolGuid: 指纹库guid, 用于获取所有指纹库时的返回结果，创建指纹库时置空
    * @param poolInfo.nodeIPs:  指纹库节点IP列表
    * @param poolInfo.minSize: 数据切片最小值，固定写16
    * @param poolInfo.maxSize: 数据切片最大值，固定写128
    * @return string: 指纹库guid
       *
       * @throw 转抛内部调用异常

    Parameters:
     - poolInfo
    """
    pass

  def EditFingerprintPool(self, guid, nodeIPs):
    """
    编辑指纹库
    @param guid: 指纹库guid
    @param nodeIPs: 扩展的节点IP列表


    Parameters:
     - guid
     - nodeIPs
    """
    pass

  def GetFingerprintPoolNodes(self, guid):
    """
    获取指纹库下所有节点
    @param guid: 指纹库guid
    @param nodeIPs: 扩展的节点IP列表
    @return list<string>: 指纹库所用节点IP列表


    Parameters:
     - guid
    """
    pass

  def CheckFingerprintPoolStatus(self, guid):
    """
    检查指纹库是否被占用
    @param guid: 指纹库guid
    @return string: ""表示未占用，其他表示占用，内容为提示信息


    Parameters:
     - guid
    """
    pass

  def CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
    """
    检查节点指纹库是否被占用
    @param guid: 指纹库guid
    @param nodeGuid: 节点指纹库标识
    @return 未被占用返回true,占用返回false


    Parameters:
     - guid
     - nodeguid
    """
    pass

  def FaultDDcache(self):
    pass

  def DeleteFingerprintPool(self, guid):
    """
    删除指纹池

    @param guid: 指纹池guid

    @throw 转抛内部调用异常

    Parameters:
     - guid
    """
    pass

  def CleanFingerprintPool(self, guid):
    """
    清理指纹库

    @param guid: 指纹池guid

    @throw 转抛内部调用异常

    Parameters:
     - guid
    """
    pass

  def DeleteFingerprintPoolNodeLib(self):
    """
    通知删除节点指纹库

    @throw 转抛内部调用异常
    """
    pass

  def CleanFingerprintPoolNodeLib(self):
    """
    通知清理节点指纹库

    @throw 转抛内部调用异常
    """
    pass

  def GetAllFingerprintPools(self):
    """
    获取全部指纹库信息
     
    @return 指纹库信息列表

    @throw 转抛内部调用异常
    """
    pass

  def CreateDDcache(self, ddcachename, ddcachepath, size):
    """
    创建DDcache卷
    @param ddcachename: ddcache卷名称
    @param ddcachepath: ddcache卷路径
    @param size:ddcache卷大小


    Parameters:
     - ddcachename
     - ddcachepath
     - size
    """
    pass

  def DeleteDDcache(self, ddcachename):
    """
    删除DDcache卷
    @param ddcachename: ddcache卷名称


    Parameters:
     - ddcachename
    """
    pass

  def ExpansionDDcache(self, ddcachename, size):
    """
    DDcache卷扩容
    @param ddcachename: ddcache卷名称
    @param size: ddcache扩容容量

    Parameters:
     - ddcachename
     - size
    """
    pass

  def GetLocalAllDDcache(self):
    """
    查询ddcache
    @return list<ncDedupeMgmType.ncDDCacheInfo> :ddcache卷信息集

    """
    pass

  def CheckDDcacheCanDelete(self, ddcachename):
    """
    检测ddcache是否可删除
    @param ddcachename: ddcache卷名称
    @return list<string>: 指纹库名称


    Parameters:
     - ddcachename
    """
    pass


class Client(Iface):
  """
  Dedupe服务接口
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def GetDedupeNodes(self):
    """
    获取可用的重删节点ip
    @ return list<string>: 重删节点IP集合

    """
    self.send_GetDedupeNodes()
    return self.recv_GetDedupeNodes()

  def send_GetDedupeNodes(self):
    self._oprot.writeMessageBegin('GetDedupeNodes', TMessageType.CALL, self._seqid)
    args = GetDedupeNodes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetDedupeNodes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetDedupeNodes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDedupeNodes failed: unknown result")

  def CreateFingerprintPool(self, poolInfo):
    """
       * 添加逻辑指纹库
       * @param poolInfo.poolName: 指纹库名称
    * @param poolInfo.poolType: 指纹库类型
    * @param poolInfo.poolGuid: 指纹库guid, 用于获取所有指纹库时的返回结果，创建指纹库时置空
    * @param poolInfo.nodeIPs:  指纹库节点IP列表
    * @param poolInfo.minSize: 数据切片最小值，固定写16
    * @param poolInfo.maxSize: 数据切片最大值，固定写128
    * @return string: 指纹库guid
       *
       * @throw 转抛内部调用异常

    Parameters:
     - poolInfo
    """
    self.send_CreateFingerprintPool(poolInfo)
    return self.recv_CreateFingerprintPool()

  def send_CreateFingerprintPool(self, poolInfo):
    self._oprot.writeMessageBegin('CreateFingerprintPool', TMessageType.CALL, self._seqid)
    args = CreateFingerprintPool_args()
    args.poolInfo = poolInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateFingerprintPool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CreateFingerprintPool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateFingerprintPool failed: unknown result")

  def EditFingerprintPool(self, guid, nodeIPs):
    """
    编辑指纹库
    @param guid: 指纹库guid
    @param nodeIPs: 扩展的节点IP列表


    Parameters:
     - guid
     - nodeIPs
    """
    self.send_EditFingerprintPool(guid, nodeIPs)
    self.recv_EditFingerprintPool()

  def send_EditFingerprintPool(self, guid, nodeIPs):
    self._oprot.writeMessageBegin('EditFingerprintPool', TMessageType.CALL, self._seqid)
    args = EditFingerprintPool_args()
    args.guid = guid
    args.nodeIPs = nodeIPs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_EditFingerprintPool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = EditFingerprintPool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def GetFingerprintPoolNodes(self, guid):
    """
    获取指纹库下所有节点
    @param guid: 指纹库guid
    @param nodeIPs: 扩展的节点IP列表
    @return list<string>: 指纹库所用节点IP列表


    Parameters:
     - guid
    """
    self.send_GetFingerprintPoolNodes(guid)
    return self.recv_GetFingerprintPoolNodes()

  def send_GetFingerprintPoolNodes(self, guid):
    self._oprot.writeMessageBegin('GetFingerprintPoolNodes', TMessageType.CALL, self._seqid)
    args = GetFingerprintPoolNodes_args()
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetFingerprintPoolNodes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetFingerprintPoolNodes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFingerprintPoolNodes failed: unknown result")

  def CheckFingerprintPoolStatus(self, guid):
    """
    检查指纹库是否被占用
    @param guid: 指纹库guid
    @return string: ""表示未占用，其他表示占用，内容为提示信息


    Parameters:
     - guid
    """
    self.send_CheckFingerprintPoolStatus(guid)
    return self.recv_CheckFingerprintPoolStatus()

  def send_CheckFingerprintPoolStatus(self, guid):
    self._oprot.writeMessageBegin('CheckFingerprintPoolStatus', TMessageType.CALL, self._seqid)
    args = CheckFingerprintPoolStatus_args()
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CheckFingerprintPoolStatus(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CheckFingerprintPoolStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckFingerprintPoolStatus failed: unknown result")

  def CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
    """
    检查节点指纹库是否被占用
    @param guid: 指纹库guid
    @param nodeGuid: 节点指纹库标识
    @return 未被占用返回true,占用返回false


    Parameters:
     - guid
     - nodeguid
    """
    self.send_CheckFingerprintPoolNodeLibStatus(guid, nodeguid)
    return self.recv_CheckFingerprintPoolNodeLibStatus()

  def send_CheckFingerprintPoolNodeLibStatus(self, guid, nodeguid):
    self._oprot.writeMessageBegin('CheckFingerprintPoolNodeLibStatus', TMessageType.CALL, self._seqid)
    args = CheckFingerprintPoolNodeLibStatus_args()
    args.guid = guid
    args.nodeguid = nodeguid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CheckFingerprintPoolNodeLibStatus(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CheckFingerprintPoolNodeLibStatus_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckFingerprintPoolNodeLibStatus failed: unknown result")

  def FaultDDcache(self):
    self.send_FaultDDcache()
    return self.recv_FaultDDcache()

  def send_FaultDDcache(self):
    self._oprot.writeMessageBegin('FaultDDcache', TMessageType.CALL, self._seqid)
    args = FaultDDcache_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_FaultDDcache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = FaultDDcache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "FaultDDcache failed: unknown result")

  def DeleteFingerprintPool(self, guid):
    """
    删除指纹池

    @param guid: 指纹池guid

    @throw 转抛内部调用异常

    Parameters:
     - guid
    """
    self.send_DeleteFingerprintPool(guid)
    self.recv_DeleteFingerprintPool()

  def send_DeleteFingerprintPool(self, guid):
    self._oprot.writeMessageBegin('DeleteFingerprintPool', TMessageType.CALL, self._seqid)
    args = DeleteFingerprintPool_args()
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DeleteFingerprintPool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = DeleteFingerprintPool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def CleanFingerprintPool(self, guid):
    """
    清理指纹库

    @param guid: 指纹池guid

    @throw 转抛内部调用异常

    Parameters:
     - guid
    """
    self.send_CleanFingerprintPool(guid)
    self.recv_CleanFingerprintPool()

  def send_CleanFingerprintPool(self, guid):
    self._oprot.writeMessageBegin('CleanFingerprintPool', TMessageType.CALL, self._seqid)
    args = CleanFingerprintPool_args()
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CleanFingerprintPool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CleanFingerprintPool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def DeleteFingerprintPoolNodeLib(self):
    """
    通知删除节点指纹库

    @throw 转抛内部调用异常
    """
    self.send_DeleteFingerprintPoolNodeLib()
    self.recv_DeleteFingerprintPoolNodeLib()

  def send_DeleteFingerprintPoolNodeLib(self):
    self._oprot.writeMessageBegin('DeleteFingerprintPoolNodeLib', TMessageType.CALL, self._seqid)
    args = DeleteFingerprintPoolNodeLib_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DeleteFingerprintPoolNodeLib(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = DeleteFingerprintPoolNodeLib_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def CleanFingerprintPoolNodeLib(self):
    """
    通知清理节点指纹库

    @throw 转抛内部调用异常
    """
    self.send_CleanFingerprintPoolNodeLib()
    self.recv_CleanFingerprintPoolNodeLib()

  def send_CleanFingerprintPoolNodeLib(self):
    self._oprot.writeMessageBegin('CleanFingerprintPoolNodeLib', TMessageType.CALL, self._seqid)
    args = CleanFingerprintPoolNodeLib_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CleanFingerprintPoolNodeLib(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CleanFingerprintPoolNodeLib_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def GetAllFingerprintPools(self):
    """
    获取全部指纹库信息
     
    @return 指纹库信息列表

    @throw 转抛内部调用异常
    """
    self.send_GetAllFingerprintPools()
    return self.recv_GetAllFingerprintPools()

  def send_GetAllFingerprintPools(self):
    self._oprot.writeMessageBegin('GetAllFingerprintPools', TMessageType.CALL, self._seqid)
    args = GetAllFingerprintPools_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetAllFingerprintPools(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetAllFingerprintPools_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAllFingerprintPools failed: unknown result")

  def CreateDDcache(self, ddcachename, ddcachepath, size):
    """
    创建DDcache卷
    @param ddcachename: ddcache卷名称
    @param ddcachepath: ddcache卷路径
    @param size:ddcache卷大小


    Parameters:
     - ddcachename
     - ddcachepath
     - size
    """
    self.send_CreateDDcache(ddcachename, ddcachepath, size)
    self.recv_CreateDDcache()

  def send_CreateDDcache(self, ddcachename, ddcachepath, size):
    self._oprot.writeMessageBegin('CreateDDcache', TMessageType.CALL, self._seqid)
    args = CreateDDcache_args()
    args.ddcachename = ddcachename
    args.ddcachepath = ddcachepath
    args.size = size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CreateDDcache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CreateDDcache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def DeleteDDcache(self, ddcachename):
    """
    删除DDcache卷
    @param ddcachename: ddcache卷名称


    Parameters:
     - ddcachename
    """
    self.send_DeleteDDcache(ddcachename)
    self.recv_DeleteDDcache()

  def send_DeleteDDcache(self, ddcachename):
    self._oprot.writeMessageBegin('DeleteDDcache', TMessageType.CALL, self._seqid)
    args = DeleteDDcache_args()
    args.ddcachename = ddcachename
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_DeleteDDcache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = DeleteDDcache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def ExpansionDDcache(self, ddcachename, size):
    """
    DDcache卷扩容
    @param ddcachename: ddcache卷名称
    @param size: ddcache扩容容量

    Parameters:
     - ddcachename
     - size
    """
    self.send_ExpansionDDcache(ddcachename, size)
    self.recv_ExpansionDDcache()

  def send_ExpansionDDcache(self, ddcachename, size):
    self._oprot.writeMessageBegin('ExpansionDDcache', TMessageType.CALL, self._seqid)
    args = ExpansionDDcache_args()
    args.ddcachename = ddcachename
    args.size = size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ExpansionDDcache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ExpansionDDcache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def GetLocalAllDDcache(self):
    """
    查询ddcache
    @return list<ncDedupeMgmType.ncDDCacheInfo> :ddcache卷信息集

    """
    self.send_GetLocalAllDDcache()
    return self.recv_GetLocalAllDDcache()

  def send_GetLocalAllDDcache(self):
    self._oprot.writeMessageBegin('GetLocalAllDDcache', TMessageType.CALL, self._seqid)
    args = GetLocalAllDDcache_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_GetLocalAllDDcache(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = GetLocalAllDDcache_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLocalAllDDcache failed: unknown result")

  def CheckDDcacheCanDelete(self, ddcachename):
    """
    检测ddcache是否可删除
    @param ddcachename: ddcache卷名称
    @return list<string>: 指纹库名称


    Parameters:
     - ddcachename
    """
    self.send_CheckDDcacheCanDelete(ddcachename)
    return self.recv_CheckDDcacheCanDelete()

  def send_CheckDDcacheCanDelete(self, ddcachename):
    self._oprot.writeMessageBegin('CheckDDcacheCanDelete', TMessageType.CALL, self._seqid)
    args = CheckDDcacheCanDelete_args()
    args.ddcachename = ddcachename
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_CheckDDcacheCanDelete(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = CheckDDcacheCanDelete_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckDDcacheCanDelete failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["GetDedupeNodes"] = Processor.process_GetDedupeNodes
    self._processMap["CreateFingerprintPool"] = Processor.process_CreateFingerprintPool
    self._processMap["EditFingerprintPool"] = Processor.process_EditFingerprintPool
    self._processMap["GetFingerprintPoolNodes"] = Processor.process_GetFingerprintPoolNodes
    self._processMap["CheckFingerprintPoolStatus"] = Processor.process_CheckFingerprintPoolStatus
    self._processMap["CheckFingerprintPoolNodeLibStatus"] = Processor.process_CheckFingerprintPoolNodeLibStatus
    self._processMap["FaultDDcache"] = Processor.process_FaultDDcache
    self._processMap["DeleteFingerprintPool"] = Processor.process_DeleteFingerprintPool
    self._processMap["CleanFingerprintPool"] = Processor.process_CleanFingerprintPool
    self._processMap["DeleteFingerprintPoolNodeLib"] = Processor.process_DeleteFingerprintPoolNodeLib
    self._processMap["CleanFingerprintPoolNodeLib"] = Processor.process_CleanFingerprintPoolNodeLib
    self._processMap["GetAllFingerprintPools"] = Processor.process_GetAllFingerprintPools
    self._processMap["CreateDDcache"] = Processor.process_CreateDDcache
    self._processMap["DeleteDDcache"] = Processor.process_DeleteDDcache
    self._processMap["ExpansionDDcache"] = Processor.process_ExpansionDDcache
    self._processMap["GetLocalAllDDcache"] = Processor.process_GetLocalAllDDcache
    self._processMap["CheckDDcacheCanDelete"] = Processor.process_CheckDDcacheCanDelete

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_GetDedupeNodes(self, seqid, iprot, oprot):
    args = GetDedupeNodes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetDedupeNodes_result()
    try:
      result.success = self._handler.GetDedupeNodes()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("GetDedupeNodes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateFingerprintPool(self, seqid, iprot, oprot):
    args = CreateFingerprintPool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateFingerprintPool_result()
    try:
      result.success = self._handler.CreateFingerprintPool(args.poolInfo)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CreateFingerprintPool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_EditFingerprintPool(self, seqid, iprot, oprot):
    args = EditFingerprintPool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = EditFingerprintPool_result()
    try:
      self._handler.EditFingerprintPool(args.guid, args.nodeIPs)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("EditFingerprintPool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetFingerprintPoolNodes(self, seqid, iprot, oprot):
    args = GetFingerprintPoolNodes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetFingerprintPoolNodes_result()
    try:
      result.success = self._handler.GetFingerprintPoolNodes(args.guid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("GetFingerprintPoolNodes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CheckFingerprintPoolStatus(self, seqid, iprot, oprot):
    args = CheckFingerprintPoolStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CheckFingerprintPoolStatus_result()
    try:
      result.success = self._handler.CheckFingerprintPoolStatus(args.guid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CheckFingerprintPoolStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CheckFingerprintPoolNodeLibStatus(self, seqid, iprot, oprot):
    args = CheckFingerprintPoolNodeLibStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CheckFingerprintPoolNodeLibStatus_result()
    try:
      result.success = self._handler.CheckFingerprintPoolNodeLibStatus(args.guid, args.nodeguid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CheckFingerprintPoolNodeLibStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_FaultDDcache(self, seqid, iprot, oprot):
    args = FaultDDcache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = FaultDDcache_result()
    try:
      result.success = self._handler.FaultDDcache()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("FaultDDcache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DeleteFingerprintPool(self, seqid, iprot, oprot):
    args = DeleteFingerprintPool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DeleteFingerprintPool_result()
    try:
      self._handler.DeleteFingerprintPool(args.guid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("DeleteFingerprintPool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CleanFingerprintPool(self, seqid, iprot, oprot):
    args = CleanFingerprintPool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CleanFingerprintPool_result()
    try:
      self._handler.CleanFingerprintPool(args.guid)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CleanFingerprintPool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DeleteFingerprintPoolNodeLib(self, seqid, iprot, oprot):
    args = DeleteFingerprintPoolNodeLib_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DeleteFingerprintPoolNodeLib_result()
    try:
      self._handler.DeleteFingerprintPoolNodeLib()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("DeleteFingerprintPoolNodeLib", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CleanFingerprintPoolNodeLib(self, seqid, iprot, oprot):
    args = CleanFingerprintPoolNodeLib_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CleanFingerprintPoolNodeLib_result()
    try:
      self._handler.CleanFingerprintPoolNodeLib()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CleanFingerprintPoolNodeLib", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetAllFingerprintPools(self, seqid, iprot, oprot):
    args = GetAllFingerprintPools_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetAllFingerprintPools_result()
    try:
      result.success = self._handler.GetAllFingerprintPools()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("GetAllFingerprintPools", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CreateDDcache(self, seqid, iprot, oprot):
    args = CreateDDcache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CreateDDcache_result()
    try:
      self._handler.CreateDDcache(args.ddcachename, args.ddcachepath, args.size)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CreateDDcache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_DeleteDDcache(self, seqid, iprot, oprot):
    args = DeleteDDcache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = DeleteDDcache_result()
    try:
      self._handler.DeleteDDcache(args.ddcachename)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("DeleteDDcache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ExpansionDDcache(self, seqid, iprot, oprot):
    args = ExpansionDDcache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ExpansionDDcache_result()
    try:
      self._handler.ExpansionDDcache(args.ddcachename, args.size)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("ExpansionDDcache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_GetLocalAllDDcache(self, seqid, iprot, oprot):
    args = GetLocalAllDDcache_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = GetLocalAllDDcache_result()
    try:
      result.success = self._handler.GetLocalAllDDcache()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("GetLocalAllDDcache", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_CheckDDcacheCanDelete(self, seqid, iprot, oprot):
    args = CheckDDcacheCanDelete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = CheckDDcacheCanDelete_result()
    try:
      result.success = self._handler.CheckDDcacheCanDelete(args.ddcachename)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("CheckDDcacheCanDelete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class GetDedupeNodes_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDedupeNodes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetDedupeNodes_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString().decode('utf-8')
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetDedupeNodes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter6 in self.success:
        oprot.writeString(iter6.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateFingerprintPool_args(object):
  """
  Attributes:
   - poolInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'poolInfo', (ncDedupeMgmType.ttypes.ncFPPoolInfo, ncDedupeMgmType.ttypes.ncFPPoolInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, poolInfo=None,):
    self.poolInfo = poolInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.poolInfo = ncDedupeMgmType.ttypes.ncFPPoolInfo()
          self.poolInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateFingerprintPool_args')
    if self.poolInfo is not None:
      oprot.writeFieldBegin('poolInfo', TType.STRUCT, 1)
      self.poolInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateFingerprintPool_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateFingerprintPool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditFingerprintPool_args(object):
  """
  Attributes:
   - guid
   - nodeIPs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.LIST, 'nodeIPs', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, guid=None, nodeIPs=None,):
    self.guid = guid
    self.nodeIPs = nodeIPs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nodeIPs = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.nodeIPs.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditFingerprintPool_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.nodeIPs is not None:
      oprot.writeFieldBegin('nodeIPs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.nodeIPs))
      for iter13 in self.nodeIPs:
        oprot.writeString(iter13.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    value = (value * 31) ^ hash(self.nodeIPs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditFingerprintPool_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditFingerprintPool_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFingerprintPoolNodes_args(object):
  """
  Attributes:
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
  )

  def __init__(self, guid=None,):
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFingerprintPoolNodes_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetFingerprintPoolNodes_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString().decode('utf-8')
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetFingerprintPoolNodes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter20 in self.success:
        oprot.writeString(iter20.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckFingerprintPoolStatus_args(object):
  """
  Attributes:
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
  )

  def __init__(self, guid=None,):
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckFingerprintPoolStatus_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckFingerprintPoolStatus_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckFingerprintPoolStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckFingerprintPoolNodeLibStatus_args(object):
  """
  Attributes:
   - guid
   - nodeguid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.I64, 'nodeguid', None, None, ), # 2
  )

  def __init__(self, guid=None, nodeguid=None,):
    self.guid = guid
    self.nodeguid = nodeguid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.nodeguid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckFingerprintPoolNodeLibStatus_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.nodeguid is not None:
      oprot.writeFieldBegin('nodeguid', TType.I64, 2)
      oprot.writeI64(self.nodeguid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    value = (value * 31) ^ hash(self.nodeguid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckFingerprintPoolNodeLibStatus_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckFingerprintPoolNodeLibStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FaultDDcache_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FaultDDcache_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FaultDDcache_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FaultDDcache_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteFingerprintPool_args(object):
  """
  Attributes:
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
  )

  def __init__(self, guid=None,):
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteFingerprintPool_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteFingerprintPool_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteFingerprintPool_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CleanFingerprintPool_args(object):
  """
  Attributes:
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
  )

  def __init__(self, guid=None,):
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CleanFingerprintPool_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.guid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CleanFingerprintPool_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CleanFingerprintPool_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteFingerprintPoolNodeLib_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteFingerprintPoolNodeLib_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteFingerprintPoolNodeLib_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteFingerprintPoolNodeLib_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CleanFingerprintPoolNodeLib_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CleanFingerprintPoolNodeLib_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CleanFingerprintPoolNodeLib_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CleanFingerprintPoolNodeLib_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllFingerprintPools_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllFingerprintPools_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAllFingerprintPools_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncDedupeMgmType.ttypes.ncFPPoolInfo, ncDedupeMgmType.ttypes.ncFPPoolInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = ncDedupeMgmType.ttypes.ncFPPoolInfo()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAllFingerprintPools_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateDDcache_args(object):
  """
  Attributes:
   - ddcachename
   - ddcachepath
   - size
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ddcachename', None, None, ), # 1
    (2, TType.STRING, 'ddcachepath', None, None, ), # 2
    (3, TType.I64, 'size', None, None, ), # 3
  )

  def __init__(self, ddcachename=None, ddcachepath=None, size=None,):
    self.ddcachename = ddcachename
    self.ddcachepath = ddcachepath
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ddcachename = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ddcachepath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.size = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateDDcache_args')
    if self.ddcachename is not None:
      oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
      oprot.writeString(self.ddcachename.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.ddcachepath is not None:
      oprot.writeFieldBegin('ddcachepath', TType.STRING, 2)
      oprot.writeString(self.ddcachepath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 3)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ddcachename)
    value = (value * 31) ^ hash(self.ddcachepath)
    value = (value * 31) ^ hash(self.size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateDDcache_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateDDcache_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteDDcache_args(object):
  """
  Attributes:
   - ddcachename
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ddcachename', None, None, ), # 1
  )

  def __init__(self, ddcachename=None,):
    self.ddcachename = ddcachename

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ddcachename = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteDDcache_args')
    if self.ddcachename is not None:
      oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
      oprot.writeString(self.ddcachename.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ddcachename)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteDDcache_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteDDcache_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExpansionDDcache_args(object):
  """
  Attributes:
   - ddcachename
   - size
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ddcachename', None, None, ), # 1
    (2, TType.I64, 'size', None, None, ), # 2
  )

  def __init__(self, ddcachename=None, size=None,):
    self.ddcachename = ddcachename
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ddcachename = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.size = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExpansionDDcache_args')
    if self.ddcachename is not None:
      oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
      oprot.writeString(self.ddcachename.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 2)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ddcachename)
    value = (value * 31) ^ hash(self.size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExpansionDDcache_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExpansionDDcache_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLocalAllDDcache_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLocalAllDDcache_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetLocalAllDDcache_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncDedupeMgmType.ttypes.ncDDCacheInfo, ncDedupeMgmType.ttypes.ncDDCacheInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = ncDedupeMgmType.ttypes.ncDDCacheInfo()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetLocalAllDDcache_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckDDcacheCanDelete_args(object):
  """
  Attributes:
   - ddcachename
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ddcachename', None, None, ), # 1
  )

  def __init__(self, ddcachename=None,):
    self.ddcachename = ddcachename

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ddcachename = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckDDcacheCanDelete_args')
    if self.ddcachename is not None:
      oprot.writeFieldBegin('ddcachename', TType.STRING, 1)
      oprot.writeString(self.ddcachename.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ddcachename)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CheckDDcacheCanDelete_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readString().decode('utf-8')
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CheckDDcacheCanDelete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter41 in self.success:
        oprot.writeString(iter41.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
