#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ncCommonType_Var.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ncVMStatus(object):
  SHUTDOWN = 0
  RUNNING = 1
  UNKNOWN = 2

  _VALUES_TO_NAMES = {
    0: "SHUTDOWN",
    1: "RUNNING",
    2: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SHUTDOWN": 0,
    "RUNNING": 1,
    "UNKNOWN": 2,
  }

class ncVMPowerControl(object):
  POWER_ON = 0
  POWER_OFF = 1
  POWER_FORCE_OFF = 2
  POWER_RESTART = 3
  POWER_UNKNOWN = 4

  _VALUES_TO_NAMES = {
    0: "POWER_ON",
    1: "POWER_OFF",
    2: "POWER_FORCE_OFF",
    3: "POWER_RESTART",
    4: "POWER_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "POWER_ON": 0,
    "POWER_OFF": 1,
    "POWER_FORCE_OFF": 2,
    "POWER_RESTART": 3,
    "POWER_UNKNOWN": 4,
  }


class ncVMISO(object):
  """
  Attributes:
   - ISOname
   - path
   - isoSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ISOname', None, None, ), # 1
    (2, TType.STRING, 'path', None, None, ), # 2
    (3, TType.I64, 'isoSize', None, None, ), # 3
  )

  def __init__(self, ISOname=None, path=None, isoSize=None,):
    self.ISOname = ISOname
    self.path = path
    self.isoSize = isoSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ISOname = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.isoSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncVMISO')
    if self.ISOname is not None:
      oprot.writeFieldBegin('ISOname', TType.STRING, 1)
      oprot.writeString(self.ISOname.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.isoSize is not None:
      oprot.writeFieldBegin('isoSize', TType.I64, 3)
      oprot.writeI64(self.isoSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ISOname)
    value = (value * 31) ^ hash(self.path)
    value = (value * 31) ^ hash(self.isoSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncCDMVolume(object):
  """
  Attributes:
   - volumeId
   - cfgString
   - devName
   - volumeSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volumeId', None, None, ), # 1
    (2, TType.STRING, 'cfgString', None, None, ), # 2
    (3, TType.STRING, 'devName', None, None, ), # 3
    (4, TType.I64, 'volumeSize', None, None, ), # 4
  )

  def __init__(self, volumeId=None, cfgString=None, devName=None, volumeSize=None,):
    self.volumeId = volumeId
    self.cfgString = cfgString
    self.devName = devName
    self.volumeSize = volumeSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.cfgString = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.devName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.volumeSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncCDMVolume')
    if self.volumeId is not None:
      oprot.writeFieldBegin('volumeId', TType.STRING, 1)
      oprot.writeString(self.volumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.cfgString is not None:
      oprot.writeFieldBegin('cfgString', TType.STRING, 2)
      oprot.writeString(self.cfgString.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.devName is not None:
      oprot.writeFieldBegin('devName', TType.STRING, 3)
      oprot.writeString(self.devName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.volumeSize is not None:
      oprot.writeFieldBegin('volumeSize', TType.I64, 4)
      oprot.writeI64(self.volumeSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volumeId)
    value = (value * 31) ^ hash(self.cfgString)
    value = (value * 31) ^ hash(self.devName)
    value = (value * 31) ^ hash(self.volumeSize)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncVMDisk(object):
  """
  Attributes:
   - diskPath
   - busType
   - cacheMode
   - diskSlots
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'diskPath', None, None, ), # 1
    (2, TType.STRING, 'busType', None, None, ), # 2
    (3, TType.STRING, 'cacheMode', None, None, ), # 3
    (4, TType.I32, 'diskSlots', None, None, ), # 4
  )

  def __init__(self, diskPath=None, busType=None, cacheMode=None, diskSlots=None,):
    self.diskPath = diskPath
    self.busType = busType
    self.cacheMode = cacheMode
    self.diskSlots = diskSlots

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.diskPath = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.busType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cacheMode = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.diskSlots = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncVMDisk')
    if self.diskPath is not None:
      oprot.writeFieldBegin('diskPath', TType.STRING, 1)
      oprot.writeString(self.diskPath.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.busType is not None:
      oprot.writeFieldBegin('busType', TType.STRING, 2)
      oprot.writeString(self.busType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.cacheMode is not None:
      oprot.writeFieldBegin('cacheMode', TType.STRING, 3)
      oprot.writeString(self.cacheMode.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.diskSlots is not None:
      oprot.writeFieldBegin('diskSlots', TType.I32, 4)
      oprot.writeI32(self.diskSlots)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.diskPath)
    value = (value * 31) ^ hash(self.busType)
    value = (value * 31) ^ hash(self.cacheMode)
    value = (value * 31) ^ hash(self.diskSlots)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncVMNetWork(object):
  """
  Attributes:
   - bridgeType
   - bridgeDevice
   - deviceType
   - macAddress
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bridgeType', None, None, ), # 1
    (2, TType.STRING, 'bridgeDevice', None, None, ), # 2
    (3, TType.STRING, 'deviceType', None, None, ), # 3
    (4, TType.STRING, 'macAddress', None, None, ), # 4
  )

  def __init__(self, bridgeType=None, bridgeDevice=None, deviceType=None, macAddress=None,):
    self.bridgeType = bridgeType
    self.bridgeDevice = bridgeDevice
    self.deviceType = deviceType
    self.macAddress = macAddress

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bridgeType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.bridgeDevice = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.deviceType = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.macAddress = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncVMNetWork')
    if self.bridgeType is not None:
      oprot.writeFieldBegin('bridgeType', TType.STRING, 1)
      oprot.writeString(self.bridgeType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.bridgeDevice is not None:
      oprot.writeFieldBegin('bridgeDevice', TType.STRING, 2)
      oprot.writeString(self.bridgeDevice.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.deviceType is not None:
      oprot.writeFieldBegin('deviceType', TType.STRING, 3)
      oprot.writeString(self.deviceType.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.macAddress is not None:
      oprot.writeFieldBegin('macAddress', TType.STRING, 4)
      oprot.writeString(self.macAddress.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bridgeType)
    value = (value * 31) ^ hash(self.bridgeDevice)
    value = (value * 31) ^ hash(self.deviceType)
    value = (value * 31) ^ hash(self.macAddress)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncVMConfig(object):
  """
  Attributes:
   - vmName
   - vmUUID
   - bootDsikIsGPT
   - cpuSolts
   - cpuCores
   - memSize
   - vmDisk
   - vmNetWork
   - vmISO
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'vmName', None, None, ), # 1
    (2, TType.STRING, 'vmUUID', None, None, ), # 2
    (3, TType.I32, 'bootDsikIsGPT', None, None, ), # 3
    (4, TType.I32, 'cpuSolts', None, None, ), # 4
    (5, TType.I32, 'cpuCores', None, None, ), # 5
    (6, TType.I64, 'memSize', None, None, ), # 6
    (7, TType.LIST, 'vmDisk', (TType.STRUCT,(ncVMDisk, ncVMDisk.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'vmNetWork', (TType.STRUCT,(ncVMNetWork, ncVMNetWork.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'vmISO', (TType.STRUCT,(ncVMISO, ncVMISO.thrift_spec)), None, ), # 9
  )

  def __init__(self, vmName=None, vmUUID=None, bootDsikIsGPT=None, cpuSolts=None, cpuCores=None, memSize=None, vmDisk=None, vmNetWork=None, vmISO=None,):
    self.vmName = vmName
    self.vmUUID = vmUUID
    self.bootDsikIsGPT = bootDsikIsGPT
    self.cpuSolts = cpuSolts
    self.cpuCores = cpuCores
    self.memSize = memSize
    self.vmDisk = vmDisk
    self.vmNetWork = vmNetWork
    self.vmISO = vmISO

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.vmName = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.vmUUID = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.bootDsikIsGPT = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.cpuSolts = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cpuCores = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.memSize = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.vmDisk = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncVMDisk()
            _elem5.read(iprot)
            self.vmDisk.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.vmNetWork = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = ncVMNetWork()
            _elem11.read(iprot)
            self.vmNetWork.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.vmISO = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = ncVMISO()
            _elem17.read(iprot)
            self.vmISO.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncVMConfig')
    if self.vmName is not None:
      oprot.writeFieldBegin('vmName', TType.STRING, 1)
      oprot.writeString(self.vmName.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.vmUUID is not None:
      oprot.writeFieldBegin('vmUUID', TType.STRING, 2)
      oprot.writeString(self.vmUUID.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.bootDsikIsGPT is not None:
      oprot.writeFieldBegin('bootDsikIsGPT', TType.I32, 3)
      oprot.writeI32(self.bootDsikIsGPT)
      oprot.writeFieldEnd()
    if self.cpuSolts is not None:
      oprot.writeFieldBegin('cpuSolts', TType.I32, 4)
      oprot.writeI32(self.cpuSolts)
      oprot.writeFieldEnd()
    if self.cpuCores is not None:
      oprot.writeFieldBegin('cpuCores', TType.I32, 5)
      oprot.writeI32(self.cpuCores)
      oprot.writeFieldEnd()
    if self.memSize is not None:
      oprot.writeFieldBegin('memSize', TType.I64, 6)
      oprot.writeI64(self.memSize)
      oprot.writeFieldEnd()
    if self.vmDisk is not None:
      oprot.writeFieldBegin('vmDisk', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.vmDisk))
      for iter18 in self.vmDisk:
        iter18.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vmNetWork is not None:
      oprot.writeFieldBegin('vmNetWork', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.vmNetWork))
      for iter19 in self.vmNetWork:
        iter19.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vmISO is not None:
      oprot.writeFieldBegin('vmISO', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.vmISO))
      for iter20 in self.vmISO:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.vmName)
    value = (value * 31) ^ hash(self.vmUUID)
    value = (value * 31) ^ hash(self.bootDsikIsGPT)
    value = (value * 31) ^ hash(self.cpuSolts)
    value = (value * 31) ^ hash(self.cpuCores)
    value = (value * 31) ^ hash(self.memSize)
    value = (value * 31) ^ hash(self.vmDisk)
    value = (value * 31) ^ hash(self.vmNetWork)
    value = (value * 31) ^ hash(self.vmISO)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
