#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  CdmStoreMgm服务接口
  """
  def Microprobe(self):
    """
    服务探针，测试服务可用性
    @ throw ncException
    """
    pass

  def get_volume(self, volume_name, volume_type):
    """
    有卷名卷类型获取卷信息


    Parameters:
     - volume_name
     - volume_type
    """
    pass

  def get_volume_by_id(self, volume_id, volume_type):
    """
    有卷id卷类型获取卷信息


    Parameters:
     - volume_id
     - volume_type
    """
    pass

  def get_pool(self, poolId, poolType):
    """
    获取指定存储池信息
    @ throw ncException

    Parameters:
     - poolId
     - poolType
    """
    pass

  def get_pools(self, poolType):
    """
    获取指定类型存储池信息
    @ throw ncExceptions

    Parameters:
     - poolType
    """
    pass

  def create_base_volume(self, request):
    """
    创建基本卷
    @ throw ncException

    Parameters:
     - request
    """
    pass

  def delete_base_volumes(self, baseVolumeIds, poolType):
    """
    删除基本卷
    @ throw ncException

    Parameters:
     - baseVolumeIds
     - poolType
    """
    pass

  def get_base_volume_space(self, baseVolumeId, poolType):
    """
    获取基本卷卷容量
    @ throw ncException

    Parameters:
     - baseVolumeId
     - poolType
    """
    pass

  def create_snap_volume(self, baseVolumeId, poolType):
    """
    创建快照卷
    @ throw ncException


    Parameters:
     - baseVolumeId
     - poolType
    """
    pass

  def delete_snap_volumes(self, snapVolumeIds, poolType):
    """
    删除快照卷
    @ throw ncException

    Parameters:
     - snapVolumeIds
     - poolType
    """
    pass

  def get_snap_volume_space(self, snapVolumeId, poolType):
    """
    获取快照卷容量
    @ throw ncException

    Parameters:
     - snapVolumeId
     - poolType
    """
    pass

  def create_clone_volume(self, snapVolumeId, poolType):
    """
    创建克隆卷
    @ throw ncException


    Parameters:
     - snapVolumeId
     - poolType
    """
    pass

  def delete_clone_volumes(self, cloneVolumeIds, poolType):
    """
    删除克隆卷
    @ throw ncException

    Parameters:
     - cloneVolumeIds
     - poolType
    """
    pass

  def get_clone_volume_space(self, cloneVolumeId, poolType):
    """
    获取克隆卷容量
    @ throw ncException

    Parameters:
     - cloneVolumeId
     - poolType
    """
    pass

  def create_volume_mapping(self, request):
    """
    创建卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    pass

  def delete_volume_mapping(self, request):
    """
    删除卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    pass

  def async_create_volume_mappings(self, requests, jobId):
    """
    异步批量创建卷映射
    @ throw ncException

    Parameters:
     - requests
     - jobId
    """
    pass

  def query_create_volume_mappings(self, request):
    """
    同步查询卷映射创建信息
    @ throw ncException

    Parameters:
     - request
    """
    pass

  def async_delete_volume_mappings(self, requests, jobId):
    """
    异步批量删除卷映射
    @ throw ncException

    Parameters:
     - requests
     - jobId
    """
    pass

  def query_delete_volume_mappings(self, request):
    """
    同步查询卷映射删除信息
    @ throw ncException

    Parameters:
     - request
    """
    pass

  def get_volume_mappings(self, request):
    """
    获取卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    pass

  def get_target_wwn(self, deviceIp, poolType, poolId):
    """
    Parameters:
     - deviceIp
     - poolType
     - poolId
    """
    pass

  def get_all_target_wwn(self, poolType, poolId, linkId):
    """
    获取集群所有节点的ip以及对应的iqn
    @ throw ncExeption

    Parameters:
     - poolType
     - poolId
     - linkId
    """
    pass

  def get_m_disk(self, path, poolType, nodeIp):
    """
    获取块和存储池映射

    Parameters:
     - path
     - poolType
     - nodeIp
    """
    pass

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    pass

  def get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
    """
    根据克隆卷ID得到基本卷信息

    Parameters:
     - clone_volume_id
     - poolType
    """
    pass

  def get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
    """
    根据快照卷ID得到基本卷信息

    Parameters:
     - snap_volume_id
     - poolType
    """
    pass

  def get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
    """
    根据快照卷ID得到pool的信息

    Parameters:
     - snap_volume_id
     - poolType
    """
    pass

  def get_all_base_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有基本卷的信息

    Parameters:
     - poolType
    """
    pass

  def get_all_clone_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有克隆卷的信息

    Parameters:
     - poolType
    """
    pass

  def get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
    """
    容量授权使用，根据卷类型和ID查询占用的容量,单位字节

    Parameters:
     - jobVolumeRequestList
     - poolType
    """
    pass

  def get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
    """
    容量授权使用，根据卷类型和基本卷ID查询占用的容量,单位字节

    Parameters:
     - BaseVolumeIdList
     - poolType
    """
    pass

  def get_all_spaces(self, jobVolumeRequestList, poolType):
    """
    根据卷类型和ID查询快照卷和克隆卷占用的容量,单位字节

    Parameters:
     - jobVolumeRequestList
     - poolType
    """
    pass

  def get_all_snap_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有快照卷的信息

    Parameters:
     - poolType
    """
    pass

  def notify_space_monitor(self):
    """
    通知空间检测
    """
    pass

  def get_node_ip_by_volume_id(self, volumeId, poolType):
    """
    根据volumeId和poolType获取节点Ip


    Parameters:
     - volumeId
     - poolType
    """
    pass

  def get_server_ip_by_pool_id(self, poolId, poolType):
    """
    根据poolId和poolType获取serverIp


    Parameters:
     - poolId
     - poolType
    """
    pass

  def snapshot_volume_sync(self, request):
    """
    快照卷同步


    Parameters:
     - request
    """
    pass

  def stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    """
    停止快照卷同步


    Parameters:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId
    """
    pass

  def get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    """
    查询快照同步状态信息


    Parameters:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId
    """
    pass

  def finish_snapshot_volume_sync(self, request):
    """
    完成快照同步


    Parameters:
     - request
    """
    pass

  def finish_snyc_work(self, request):
    """
    插入快照卷信息


    Parameters:
     - request
    """
    pass

  def get_data_ip_by_pool_id(self, poolId, poolType):
    """
    获取存储池所在节点的数据传输ip


    Parameters:
     - poolId
     - poolType
    """
    pass

  def get_link_info(self, linkId):
    """
    获取链路信息


    Parameters:
     - linkId
    """
    pass

  def select_link(self, request, num):
    """
    选择链路


    Parameters:
     - request
     - num
    """
    pass


class Client(Iface):
  """
  CdmStoreMgm服务接口
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def Microprobe(self):
    """
    服务探针，测试服务可用性
    @ throw ncException
    """
    self.send_Microprobe()
    self.recv_Microprobe()

  def send_Microprobe(self):
    self._oprot.writeMessageBegin('Microprobe', TMessageType.CALL, self._seqid)
    args = Microprobe_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_Microprobe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = Microprobe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_volume(self, volume_name, volume_type):
    """
    有卷名卷类型获取卷信息


    Parameters:
     - volume_name
     - volume_type
    """
    self.send_get_volume(volume_name, volume_type)
    return self.recv_get_volume()

  def send_get_volume(self, volume_name, volume_type):
    self._oprot.writeMessageBegin('get_volume', TMessageType.CALL, self._seqid)
    args = get_volume_args()
    args.volume_name = volume_name
    args.volume_type = volume_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_volume(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_volume_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume failed: unknown result")

  def get_volume_by_id(self, volume_id, volume_type):
    """
    有卷id卷类型获取卷信息


    Parameters:
     - volume_id
     - volume_type
    """
    self.send_get_volume_by_id(volume_id, volume_type)
    return self.recv_get_volume_by_id()

  def send_get_volume_by_id(self, volume_id, volume_type):
    self._oprot.writeMessageBegin('get_volume_by_id', TMessageType.CALL, self._seqid)
    args = get_volume_by_id_args()
    args.volume_id = volume_id
    args.volume_type = volume_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_volume_by_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_volume_by_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume_by_id failed: unknown result")

  def get_pool(self, poolId, poolType):
    """
    获取指定存储池信息
    @ throw ncException

    Parameters:
     - poolId
     - poolType
    """
    self.send_get_pool(poolId, poolType)
    return self.recv_get_pool()

  def send_get_pool(self, poolId, poolType):
    self._oprot.writeMessageBegin('get_pool', TMessageType.CALL, self._seqid)
    args = get_pool_args()
    args.poolId = poolId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_pool(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_pool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pool failed: unknown result")

  def get_pools(self, poolType):
    """
    获取指定类型存储池信息
    @ throw ncExceptions

    Parameters:
     - poolType
    """
    self.send_get_pools(poolType)
    return self.recv_get_pools()

  def send_get_pools(self, poolType):
    self._oprot.writeMessageBegin('get_pools', TMessageType.CALL, self._seqid)
    args = get_pools_args()
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_pools(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_pools_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pools failed: unknown result")

  def create_base_volume(self, request):
    """
    创建基本卷
    @ throw ncException

    Parameters:
     - request
    """
    self.send_create_base_volume(request)
    return self.recv_create_base_volume()

  def send_create_base_volume(self, request):
    self._oprot.writeMessageBegin('create_base_volume', TMessageType.CALL, self._seqid)
    args = create_base_volume_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_base_volume(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_base_volume_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_base_volume failed: unknown result")

  def delete_base_volumes(self, baseVolumeIds, poolType):
    """
    删除基本卷
    @ throw ncException

    Parameters:
     - baseVolumeIds
     - poolType
    """
    self.send_delete_base_volumes(baseVolumeIds, poolType)
    self.recv_delete_base_volumes()

  def send_delete_base_volumes(self, baseVolumeIds, poolType):
    self._oprot.writeMessageBegin('delete_base_volumes', TMessageType.CALL, self._seqid)
    args = delete_base_volumes_args()
    args.baseVolumeIds = baseVolumeIds
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_base_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_base_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_base_volume_space(self, baseVolumeId, poolType):
    """
    获取基本卷卷容量
    @ throw ncException

    Parameters:
     - baseVolumeId
     - poolType
    """
    self.send_get_base_volume_space(baseVolumeId, poolType)
    return self.recv_get_base_volume_space()

  def send_get_base_volume_space(self, baseVolumeId, poolType):
    self._oprot.writeMessageBegin('get_base_volume_space', TMessageType.CALL, self._seqid)
    args = get_base_volume_space_args()
    args.baseVolumeId = baseVolumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_base_volume_space(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_base_volume_space_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_space failed: unknown result")

  def create_snap_volume(self, baseVolumeId, poolType):
    """
    创建快照卷
    @ throw ncException


    Parameters:
     - baseVolumeId
     - poolType
    """
    self.send_create_snap_volume(baseVolumeId, poolType)
    return self.recv_create_snap_volume()

  def send_create_snap_volume(self, baseVolumeId, poolType):
    self._oprot.writeMessageBegin('create_snap_volume', TMessageType.CALL, self._seqid)
    args = create_snap_volume_args()
    args.baseVolumeId = baseVolumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_snap_volume(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_snap_volume_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_snap_volume failed: unknown result")

  def delete_snap_volumes(self, snapVolumeIds, poolType):
    """
    删除快照卷
    @ throw ncException

    Parameters:
     - snapVolumeIds
     - poolType
    """
    self.send_delete_snap_volumes(snapVolumeIds, poolType)
    self.recv_delete_snap_volumes()

  def send_delete_snap_volumes(self, snapVolumeIds, poolType):
    self._oprot.writeMessageBegin('delete_snap_volumes', TMessageType.CALL, self._seqid)
    args = delete_snap_volumes_args()
    args.snapVolumeIds = snapVolumeIds
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_snap_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_snap_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_snap_volume_space(self, snapVolumeId, poolType):
    """
    获取快照卷容量
    @ throw ncException

    Parameters:
     - snapVolumeId
     - poolType
    """
    self.send_get_snap_volume_space(snapVolumeId, poolType)
    return self.recv_get_snap_volume_space()

  def send_get_snap_volume_space(self, snapVolumeId, poolType):
    self._oprot.writeMessageBegin('get_snap_volume_space', TMessageType.CALL, self._seqid)
    args = get_snap_volume_space_args()
    args.snapVolumeId = snapVolumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_snap_volume_space(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_snap_volume_space_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_snap_volume_space failed: unknown result")

  def create_clone_volume(self, snapVolumeId, poolType):
    """
    创建克隆卷
    @ throw ncException


    Parameters:
     - snapVolumeId
     - poolType
    """
    self.send_create_clone_volume(snapVolumeId, poolType)
    return self.recv_create_clone_volume()

  def send_create_clone_volume(self, snapVolumeId, poolType):
    self._oprot.writeMessageBegin('create_clone_volume', TMessageType.CALL, self._seqid)
    args = create_clone_volume_args()
    args.snapVolumeId = snapVolumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_clone_volume(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_clone_volume_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_clone_volume failed: unknown result")

  def delete_clone_volumes(self, cloneVolumeIds, poolType):
    """
    删除克隆卷
    @ throw ncException

    Parameters:
     - cloneVolumeIds
     - poolType
    """
    self.send_delete_clone_volumes(cloneVolumeIds, poolType)
    self.recv_delete_clone_volumes()

  def send_delete_clone_volumes(self, cloneVolumeIds, poolType):
    self._oprot.writeMessageBegin('delete_clone_volumes', TMessageType.CALL, self._seqid)
    args = delete_clone_volumes_args()
    args.cloneVolumeIds = cloneVolumeIds
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_clone_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_clone_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_clone_volume_space(self, cloneVolumeId, poolType):
    """
    获取克隆卷容量
    @ throw ncException

    Parameters:
     - cloneVolumeId
     - poolType
    """
    self.send_get_clone_volume_space(cloneVolumeId, poolType)
    return self.recv_get_clone_volume_space()

  def send_get_clone_volume_space(self, cloneVolumeId, poolType):
    self._oprot.writeMessageBegin('get_clone_volume_space', TMessageType.CALL, self._seqid)
    args = get_clone_volume_space_args()
    args.cloneVolumeId = cloneVolumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_clone_volume_space(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_clone_volume_space_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clone_volume_space failed: unknown result")

  def create_volume_mapping(self, request):
    """
    创建卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    self.send_create_volume_mapping(request)
    return self.recv_create_volume_mapping()

  def send_create_volume_mapping(self, request):
    self._oprot.writeMessageBegin('create_volume_mapping', TMessageType.CALL, self._seqid)
    args = create_volume_mapping_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_volume_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = create_volume_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_volume_mapping failed: unknown result")

  def delete_volume_mapping(self, request):
    """
    删除卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    self.send_delete_volume_mapping(request)
    self.recv_delete_volume_mapping()

  def send_delete_volume_mapping(self, request):
    self._oprot.writeMessageBegin('delete_volume_mapping', TMessageType.CALL, self._seqid)
    args = delete_volume_mapping_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_volume_mapping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = delete_volume_mapping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def async_create_volume_mappings(self, requests, jobId):
    """
    异步批量创建卷映射
    @ throw ncException

    Parameters:
     - requests
     - jobId
    """
    self.send_async_create_volume_mappings(requests, jobId)
    self.recv_async_create_volume_mappings()

  def send_async_create_volume_mappings(self, requests, jobId):
    self._oprot.writeMessageBegin('async_create_volume_mappings', TMessageType.CALL, self._seqid)
    args = async_create_volume_mappings_args()
    args.requests = requests
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_async_create_volume_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = async_create_volume_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def query_create_volume_mappings(self, request):
    """
    同步查询卷映射创建信息
    @ throw ncException

    Parameters:
     - request
    """
    self.send_query_create_volume_mappings(request)
    return self.recv_query_create_volume_mappings()

  def send_query_create_volume_mappings(self, request):
    self._oprot.writeMessageBegin('query_create_volume_mappings', TMessageType.CALL, self._seqid)
    args = query_create_volume_mappings_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_query_create_volume_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = query_create_volume_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "query_create_volume_mappings failed: unknown result")

  def async_delete_volume_mappings(self, requests, jobId):
    """
    异步批量删除卷映射
    @ throw ncException

    Parameters:
     - requests
     - jobId
    """
    self.send_async_delete_volume_mappings(requests, jobId)
    self.recv_async_delete_volume_mappings()

  def send_async_delete_volume_mappings(self, requests, jobId):
    self._oprot.writeMessageBegin('async_delete_volume_mappings', TMessageType.CALL, self._seqid)
    args = async_delete_volume_mappings_args()
    args.requests = requests
    args.jobId = jobId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_async_delete_volume_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = async_delete_volume_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def query_delete_volume_mappings(self, request):
    """
    同步查询卷映射删除信息
    @ throw ncException

    Parameters:
     - request
    """
    self.send_query_delete_volume_mappings(request)
    return self.recv_query_delete_volume_mappings()

  def send_query_delete_volume_mappings(self, request):
    self._oprot.writeMessageBegin('query_delete_volume_mappings', TMessageType.CALL, self._seqid)
    args = query_delete_volume_mappings_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_query_delete_volume_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = query_delete_volume_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "query_delete_volume_mappings failed: unknown result")

  def get_volume_mappings(self, request):
    """
    获取卷映射
    @ throw ncExeption

    Parameters:
     - request
    """
    self.send_get_volume_mappings(request)
    return self.recv_get_volume_mappings()

  def send_get_volume_mappings(self, request):
    self._oprot.writeMessageBegin('get_volume_mappings', TMessageType.CALL, self._seqid)
    args = get_volume_mappings_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_volume_mappings(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_volume_mappings_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_volume_mappings failed: unknown result")

  def get_target_wwn(self, deviceIp, poolType, poolId):
    """
    Parameters:
     - deviceIp
     - poolType
     - poolId
    """
    self.send_get_target_wwn(deviceIp, poolType, poolId)
    return self.recv_get_target_wwn()

  def send_get_target_wwn(self, deviceIp, poolType, poolId):
    self._oprot.writeMessageBegin('get_target_wwn', TMessageType.CALL, self._seqid)
    args = get_target_wwn_args()
    args.deviceIp = deviceIp
    args.poolType = poolType
    args.poolId = poolId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_target_wwn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_target_wwn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_wwn failed: unknown result")

  def get_all_target_wwn(self, poolType, poolId, linkId):
    """
    获取集群所有节点的ip以及对应的iqn
    @ throw ncExeption

    Parameters:
     - poolType
     - poolId
     - linkId
    """
    self.send_get_all_target_wwn(poolType, poolId, linkId)
    return self.recv_get_all_target_wwn()

  def send_get_all_target_wwn(self, poolType, poolId, linkId):
    self._oprot.writeMessageBegin('get_all_target_wwn', TMessageType.CALL, self._seqid)
    args = get_all_target_wwn_args()
    args.poolType = poolType
    args.poolId = poolId
    args.linkId = linkId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_target_wwn(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_target_wwn_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_target_wwn failed: unknown result")

  def get_m_disk(self, path, poolType, nodeIp):
    """
    获取块和存储池映射

    Parameters:
     - path
     - poolType
     - nodeIp
    """
    self.send_get_m_disk(path, poolType, nodeIp)
    return self.recv_get_m_disk()

  def send_get_m_disk(self, path, poolType, nodeIp):
    self._oprot.writeMessageBegin('get_m_disk', TMessageType.CALL, self._seqid)
    args = get_m_disk_args()
    args.path = path
    args.poolType = poolType
    args.nodeIp = nodeIp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_m_disk(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_m_disk_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_m_disk failed: unknown result")

  def get_data_for_ams(self, kwargs):
    """
    AMS获取数据接口


    Parameters:
     - kwargs
    """
    self.send_get_data_for_ams(kwargs)
    return self.recv_get_data_for_ams()

  def send_get_data_for_ams(self, kwargs):
    self._oprot.writeMessageBegin('get_data_for_ams', TMessageType.CALL, self._seqid)
    args = get_data_for_ams_args()
    args.kwargs = kwargs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_data_for_ams(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_data_for_ams_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.error is not None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_for_ams failed: unknown result")

  def get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
    """
    根据克隆卷ID得到基本卷信息

    Parameters:
     - clone_volume_id
     - poolType
    """
    self.send_get_base_volume_info_by_clone_volume_id(clone_volume_id, poolType)
    return self.recv_get_base_volume_info_by_clone_volume_id()

  def send_get_base_volume_info_by_clone_volume_id(self, clone_volume_id, poolType):
    self._oprot.writeMessageBegin('get_base_volume_info_by_clone_volume_id', TMessageType.CALL, self._seqid)
    args = get_base_volume_info_by_clone_volume_id_args()
    args.clone_volume_id = clone_volume_id
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_base_volume_info_by_clone_volume_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_base_volume_info_by_clone_volume_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_info_by_clone_volume_id failed: unknown result")

  def get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
    """
    根据快照卷ID得到基本卷信息

    Parameters:
     - snap_volume_id
     - poolType
    """
    self.send_get_base_volume_info_by_snap_volume_id(snap_volume_id, poolType)
    return self.recv_get_base_volume_info_by_snap_volume_id()

  def send_get_base_volume_info_by_snap_volume_id(self, snap_volume_id, poolType):
    self._oprot.writeMessageBegin('get_base_volume_info_by_snap_volume_id', TMessageType.CALL, self._seqid)
    args = get_base_volume_info_by_snap_volume_id_args()
    args.snap_volume_id = snap_volume_id
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_base_volume_info_by_snap_volume_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_base_volume_info_by_snap_volume_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_base_volume_info_by_snap_volume_id failed: unknown result")

  def get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
    """
    根据快照卷ID得到pool的信息

    Parameters:
     - snap_volume_id
     - poolType
    """
    self.send_get_binding_pool_by_snap_volume_id(snap_volume_id, poolType)
    return self.recv_get_binding_pool_by_snap_volume_id()

  def send_get_binding_pool_by_snap_volume_id(self, snap_volume_id, poolType):
    self._oprot.writeMessageBegin('get_binding_pool_by_snap_volume_id', TMessageType.CALL, self._seqid)
    args = get_binding_pool_by_snap_volume_id_args()
    args.snap_volume_id = snap_volume_id
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_binding_pool_by_snap_volume_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_binding_pool_by_snap_volume_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_binding_pool_by_snap_volume_id failed: unknown result")

  def get_all_base_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有基本卷的信息

    Parameters:
     - poolType
    """
    self.send_get_all_base_volume_ids(poolType)
    return self.recv_get_all_base_volume_ids()

  def send_get_all_base_volume_ids(self, poolType):
    self._oprot.writeMessageBegin('get_all_base_volume_ids', TMessageType.CALL, self._seqid)
    args = get_all_base_volume_ids_args()
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_base_volume_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_base_volume_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_base_volume_ids failed: unknown result")

  def get_all_clone_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有克隆卷的信息

    Parameters:
     - poolType
    """
    self.send_get_all_clone_volume_ids(poolType)
    return self.recv_get_all_clone_volume_ids()

  def send_get_all_clone_volume_ids(self, poolType):
    self._oprot.writeMessageBegin('get_all_clone_volume_ids', TMessageType.CALL, self._seqid)
    args = get_all_clone_volume_ids_args()
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_clone_volume_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_clone_volume_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_clone_volume_ids failed: unknown result")

  def get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
    """
    容量授权使用，根据卷类型和ID查询占用的容量,单位字节

    Parameters:
     - jobVolumeRequestList
     - poolType
    """
    self.send_get_all_spaces_by_volumes(jobVolumeRequestList, poolType)
    return self.recv_get_all_spaces_by_volumes()

  def send_get_all_spaces_by_volumes(self, jobVolumeRequestList, poolType):
    self._oprot.writeMessageBegin('get_all_spaces_by_volumes', TMessageType.CALL, self._seqid)
    args = get_all_spaces_by_volumes_args()
    args.jobVolumeRequestList = jobVolumeRequestList
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_spaces_by_volumes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_spaces_by_volumes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_spaces_by_volumes failed: unknown result")

  def get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
    """
    容量授权使用，根据卷类型和基本卷ID查询占用的容量,单位字节

    Parameters:
     - BaseVolumeIdList
     - poolType
    """
    self.send_get_spaces_by_base_volume_id(BaseVolumeIdList, poolType)
    return self.recv_get_spaces_by_base_volume_id()

  def send_get_spaces_by_base_volume_id(self, BaseVolumeIdList, poolType):
    self._oprot.writeMessageBegin('get_spaces_by_base_volume_id', TMessageType.CALL, self._seqid)
    args = get_spaces_by_base_volume_id_args()
    args.BaseVolumeIdList = BaseVolumeIdList
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_spaces_by_base_volume_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_spaces_by_base_volume_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_spaces_by_base_volume_id failed: unknown result")

  def get_all_spaces(self, jobVolumeRequestList, poolType):
    """
    根据卷类型和ID查询快照卷和克隆卷占用的容量,单位字节

    Parameters:
     - jobVolumeRequestList
     - poolType
    """
    self.send_get_all_spaces(jobVolumeRequestList, poolType)
    return self.recv_get_all_spaces()

  def send_get_all_spaces(self, jobVolumeRequestList, poolType):
    self._oprot.writeMessageBegin('get_all_spaces', TMessageType.CALL, self._seqid)
    args = get_all_spaces_args()
    args.jobVolumeRequestList = jobVolumeRequestList
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_spaces(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_spaces_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_spaces failed: unknown result")

  def get_all_snap_volume_ids(self, poolType):
    """
    获取相应存储池类型的所有快照卷的信息

    Parameters:
     - poolType
    """
    self.send_get_all_snap_volume_ids(poolType)
    return self.recv_get_all_snap_volume_ids()

  def send_get_all_snap_volume_ids(self, poolType):
    self._oprot.writeMessageBegin('get_all_snap_volume_ids', TMessageType.CALL, self._seqid)
    args = get_all_snap_volume_ids_args()
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_snap_volume_ids(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_all_snap_volume_ids_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_snap_volume_ids failed: unknown result")

  def notify_space_monitor(self):
    """
    通知空间检测
    """
    self.send_notify_space_monitor()
    self.recv_notify_space_monitor()

  def send_notify_space_monitor(self):
    self._oprot.writeMessageBegin('notify_space_monitor', TMessageType.CALL, self._seqid)
    args = notify_space_monitor_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_notify_space_monitor(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = notify_space_monitor_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_node_ip_by_volume_id(self, volumeId, poolType):
    """
    根据volumeId和poolType获取节点Ip


    Parameters:
     - volumeId
     - poolType
    """
    self.send_get_node_ip_by_volume_id(volumeId, poolType)
    return self.recv_get_node_ip_by_volume_id()

  def send_get_node_ip_by_volume_id(self, volumeId, poolType):
    self._oprot.writeMessageBegin('get_node_ip_by_volume_id', TMessageType.CALL, self._seqid)
    args = get_node_ip_by_volume_id_args()
    args.volumeId = volumeId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_node_ip_by_volume_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_node_ip_by_volume_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node_ip_by_volume_id failed: unknown result")

  def get_server_ip_by_pool_id(self, poolId, poolType):
    """
    根据poolId和poolType获取serverIp


    Parameters:
     - poolId
     - poolType
    """
    self.send_get_server_ip_by_pool_id(poolId, poolType)
    return self.recv_get_server_ip_by_pool_id()

  def send_get_server_ip_by_pool_id(self, poolId, poolType):
    self._oprot.writeMessageBegin('get_server_ip_by_pool_id', TMessageType.CALL, self._seqid)
    args = get_server_ip_by_pool_id_args()
    args.poolId = poolId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_server_ip_by_pool_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_server_ip_by_pool_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_server_ip_by_pool_id failed: unknown result")

  def snapshot_volume_sync(self, request):
    """
    快照卷同步


    Parameters:
     - request
    """
    self.send_snapshot_volume_sync(request)
    return self.recv_snapshot_volume_sync()

  def send_snapshot_volume_sync(self, request):
    self._oprot.writeMessageBegin('snapshot_volume_sync', TMessageType.CALL, self._seqid)
    args = snapshot_volume_sync_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_snapshot_volume_sync(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = snapshot_volume_sync_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_volume_sync failed: unknown result")

  def stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    """
    停止快照卷同步


    Parameters:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId
    """
    self.send_stop_snapshot_volume_sync(snapshotVolumeSyncId, srcSnapshotPoolId)
    self.recv_stop_snapshot_volume_sync()

  def send_stop_snapshot_volume_sync(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    self._oprot.writeMessageBegin('stop_snapshot_volume_sync', TMessageType.CALL, self._seqid)
    args = stop_snapshot_volume_sync_args()
    args.snapshotVolumeSyncId = snapshotVolumeSyncId
    args.srcSnapshotPoolId = srcSnapshotPoolId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stop_snapshot_volume_sync(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stop_snapshot_volume_sync_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.exp is not None:
      raise result.exp
    return

  def get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    """
    查询快照同步状态信息


    Parameters:
     - snapshotVolumeSyncId
     - srcSnapshotPoolId
    """
    self.send_get_snapshot_volume_sync_status(snapshotVolumeSyncId, srcSnapshotPoolId)
    return self.recv_get_snapshot_volume_sync_status()

  def send_get_snapshot_volume_sync_status(self, snapshotVolumeSyncId, srcSnapshotPoolId):
    self._oprot.writeMessageBegin('get_snapshot_volume_sync_status', TMessageType.CALL, self._seqid)
    args = get_snapshot_volume_sync_status_args()
    args.snapshotVolumeSyncId = snapshotVolumeSyncId
    args.srcSnapshotPoolId = srcSnapshotPoolId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_snapshot_volume_sync_status(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_snapshot_volume_sync_status_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_snapshot_volume_sync_status failed: unknown result")

  def finish_snapshot_volume_sync(self, request):
    """
    完成快照同步


    Parameters:
     - request
    """
    self.send_finish_snapshot_volume_sync(request)
    return self.recv_finish_snapshot_volume_sync()

  def send_finish_snapshot_volume_sync(self, request):
    self._oprot.writeMessageBegin('finish_snapshot_volume_sync', TMessageType.CALL, self._seqid)
    args = finish_snapshot_volume_sync_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_finish_snapshot_volume_sync(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = finish_snapshot_volume_sync_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "finish_snapshot_volume_sync failed: unknown result")

  def finish_snyc_work(self, request):
    """
    插入快照卷信息


    Parameters:
     - request
    """
    self.send_finish_snyc_work(request)
    return self.recv_finish_snyc_work()

  def send_finish_snyc_work(self, request):
    self._oprot.writeMessageBegin('finish_snyc_work', TMessageType.CALL, self._seqid)
    args = finish_snyc_work_args()
    args.request = request
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_finish_snyc_work(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = finish_snyc_work_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "finish_snyc_work failed: unknown result")

  def get_data_ip_by_pool_id(self, poolId, poolType):
    """
    获取存储池所在节点的数据传输ip


    Parameters:
     - poolId
     - poolType
    """
    self.send_get_data_ip_by_pool_id(poolId, poolType)
    return self.recv_get_data_ip_by_pool_id()

  def send_get_data_ip_by_pool_id(self, poolId, poolType):
    self._oprot.writeMessageBegin('get_data_ip_by_pool_id', TMessageType.CALL, self._seqid)
    args = get_data_ip_by_pool_id_args()
    args.poolId = poolId
    args.poolType = poolType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_data_ip_by_pool_id(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_data_ip_by_pool_id_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_data_ip_by_pool_id failed: unknown result")

  def get_link_info(self, linkId):
    """
    获取链路信息


    Parameters:
     - linkId
    """
    self.send_get_link_info(linkId)
    return self.recv_get_link_info()

  def send_get_link_info(self, linkId):
    self._oprot.writeMessageBegin('get_link_info', TMessageType.CALL, self._seqid)
    args = get_link_info_args()
    args.linkId = linkId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_link_info(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = get_link_info_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_link_info failed: unknown result")

  def select_link(self, request, num):
    """
    选择链路


    Parameters:
     - request
     - num
    """
    self.send_select_link(request, num)
    return self.recv_select_link()

  def send_select_link(self, request, num):
    self._oprot.writeMessageBegin('select_link', TMessageType.CALL, self._seqid)
    args = select_link_args()
    args.request = request
    args.num = num
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_select_link(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = select_link_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.exp is not None:
      raise result.exp
    raise TApplicationException(TApplicationException.MISSING_RESULT, "select_link failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["Microprobe"] = Processor.process_Microprobe
    self._processMap["get_volume"] = Processor.process_get_volume
    self._processMap["get_volume_by_id"] = Processor.process_get_volume_by_id
    self._processMap["get_pool"] = Processor.process_get_pool
    self._processMap["get_pools"] = Processor.process_get_pools
    self._processMap["create_base_volume"] = Processor.process_create_base_volume
    self._processMap["delete_base_volumes"] = Processor.process_delete_base_volumes
    self._processMap["get_base_volume_space"] = Processor.process_get_base_volume_space
    self._processMap["create_snap_volume"] = Processor.process_create_snap_volume
    self._processMap["delete_snap_volumes"] = Processor.process_delete_snap_volumes
    self._processMap["get_snap_volume_space"] = Processor.process_get_snap_volume_space
    self._processMap["create_clone_volume"] = Processor.process_create_clone_volume
    self._processMap["delete_clone_volumes"] = Processor.process_delete_clone_volumes
    self._processMap["get_clone_volume_space"] = Processor.process_get_clone_volume_space
    self._processMap["create_volume_mapping"] = Processor.process_create_volume_mapping
    self._processMap["delete_volume_mapping"] = Processor.process_delete_volume_mapping
    self._processMap["async_create_volume_mappings"] = Processor.process_async_create_volume_mappings
    self._processMap["query_create_volume_mappings"] = Processor.process_query_create_volume_mappings
    self._processMap["async_delete_volume_mappings"] = Processor.process_async_delete_volume_mappings
    self._processMap["query_delete_volume_mappings"] = Processor.process_query_delete_volume_mappings
    self._processMap["get_volume_mappings"] = Processor.process_get_volume_mappings
    self._processMap["get_target_wwn"] = Processor.process_get_target_wwn
    self._processMap["get_all_target_wwn"] = Processor.process_get_all_target_wwn
    self._processMap["get_m_disk"] = Processor.process_get_m_disk
    self._processMap["get_data_for_ams"] = Processor.process_get_data_for_ams
    self._processMap["get_base_volume_info_by_clone_volume_id"] = Processor.process_get_base_volume_info_by_clone_volume_id
    self._processMap["get_base_volume_info_by_snap_volume_id"] = Processor.process_get_base_volume_info_by_snap_volume_id
    self._processMap["get_binding_pool_by_snap_volume_id"] = Processor.process_get_binding_pool_by_snap_volume_id
    self._processMap["get_all_base_volume_ids"] = Processor.process_get_all_base_volume_ids
    self._processMap["get_all_clone_volume_ids"] = Processor.process_get_all_clone_volume_ids
    self._processMap["get_all_spaces_by_volumes"] = Processor.process_get_all_spaces_by_volumes
    self._processMap["get_spaces_by_base_volume_id"] = Processor.process_get_spaces_by_base_volume_id
    self._processMap["get_all_spaces"] = Processor.process_get_all_spaces
    self._processMap["get_all_snap_volume_ids"] = Processor.process_get_all_snap_volume_ids
    self._processMap["notify_space_monitor"] = Processor.process_notify_space_monitor
    self._processMap["get_node_ip_by_volume_id"] = Processor.process_get_node_ip_by_volume_id
    self._processMap["get_server_ip_by_pool_id"] = Processor.process_get_server_ip_by_pool_id
    self._processMap["snapshot_volume_sync"] = Processor.process_snapshot_volume_sync
    self._processMap["stop_snapshot_volume_sync"] = Processor.process_stop_snapshot_volume_sync
    self._processMap["get_snapshot_volume_sync_status"] = Processor.process_get_snapshot_volume_sync_status
    self._processMap["finish_snapshot_volume_sync"] = Processor.process_finish_snapshot_volume_sync
    self._processMap["finish_snyc_work"] = Processor.process_finish_snyc_work
    self._processMap["get_data_ip_by_pool_id"] = Processor.process_get_data_ip_by_pool_id
    self._processMap["get_link_info"] = Processor.process_get_link_info
    self._processMap["select_link"] = Processor.process_select_link

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_Microprobe(self, seqid, iprot, oprot):
    args = Microprobe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = Microprobe_result()
    try:
      self._handler.Microprobe()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("Microprobe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_volume(self, seqid, iprot, oprot):
    args = get_volume_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_volume_result()
    result.success = self._handler.get_volume(args.volume_name, args.volume_type)
    oprot.writeMessageBegin("get_volume", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_volume_by_id(self, seqid, iprot, oprot):
    args = get_volume_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_volume_by_id_result()
    result.success = self._handler.get_volume_by_id(args.volume_id, args.volume_type)
    oprot.writeMessageBegin("get_volume_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_pool(self, seqid, iprot, oprot):
    args = get_pool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_pool_result()
    try:
      result.success = self._handler.get_pool(args.poolId, args.poolType)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_pool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_pools(self, seqid, iprot, oprot):
    args = get_pools_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_pools_result()
    try:
      result.success = self._handler.get_pools(args.poolType)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_pools", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_base_volume(self, seqid, iprot, oprot):
    args = create_base_volume_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_base_volume_result()
    try:
      result.success = self._handler.create_base_volume(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("create_base_volume", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_base_volumes(self, seqid, iprot, oprot):
    args = delete_base_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_base_volumes_result()
    try:
      self._handler.delete_base_volumes(args.baseVolumeIds, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("delete_base_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_base_volume_space(self, seqid, iprot, oprot):
    args = get_base_volume_space_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_base_volume_space_result()
    try:
      result.success = self._handler.get_base_volume_space(args.baseVolumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_base_volume_space", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_snap_volume(self, seqid, iprot, oprot):
    args = create_snap_volume_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_snap_volume_result()
    try:
      result.success = self._handler.create_snap_volume(args.baseVolumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("create_snap_volume", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_snap_volumes(self, seqid, iprot, oprot):
    args = delete_snap_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_snap_volumes_result()
    try:
      self._handler.delete_snap_volumes(args.snapVolumeIds, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("delete_snap_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_snap_volume_space(self, seqid, iprot, oprot):
    args = get_snap_volume_space_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_snap_volume_space_result()
    try:
      result.success = self._handler.get_snap_volume_space(args.snapVolumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_snap_volume_space", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_clone_volume(self, seqid, iprot, oprot):
    args = create_clone_volume_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_clone_volume_result()
    try:
      result.success = self._handler.create_clone_volume(args.snapVolumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("create_clone_volume", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_clone_volumes(self, seqid, iprot, oprot):
    args = delete_clone_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_clone_volumes_result()
    try:
      self._handler.delete_clone_volumes(args.cloneVolumeIds, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("delete_clone_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_clone_volume_space(self, seqid, iprot, oprot):
    args = get_clone_volume_space_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_clone_volume_space_result()
    try:
      result.success = self._handler.get_clone_volume_space(args.cloneVolumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_clone_volume_space", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_volume_mapping(self, seqid, iprot, oprot):
    args = create_volume_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_volume_mapping_result()
    try:
      result.success = self._handler.create_volume_mapping(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("create_volume_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_volume_mapping(self, seqid, iprot, oprot):
    args = delete_volume_mapping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_volume_mapping_result()
    try:
      self._handler.delete_volume_mapping(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("delete_volume_mapping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_async_create_volume_mappings(self, seqid, iprot, oprot):
    args = async_create_volume_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = async_create_volume_mappings_result()
    try:
      self._handler.async_create_volume_mappings(args.requests, args.jobId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("async_create_volume_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_query_create_volume_mappings(self, seqid, iprot, oprot):
    args = query_create_volume_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = query_create_volume_mappings_result()
    try:
      result.success = self._handler.query_create_volume_mappings(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("query_create_volume_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_async_delete_volume_mappings(self, seqid, iprot, oprot):
    args = async_delete_volume_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = async_delete_volume_mappings_result()
    try:
      self._handler.async_delete_volume_mappings(args.requests, args.jobId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("async_delete_volume_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_query_delete_volume_mappings(self, seqid, iprot, oprot):
    args = query_delete_volume_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = query_delete_volume_mappings_result()
    try:
      result.success = self._handler.query_delete_volume_mappings(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("query_delete_volume_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_volume_mappings(self, seqid, iprot, oprot):
    args = get_volume_mappings_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_volume_mappings_result()
    try:
      result.success = self._handler.get_volume_mappings(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_volume_mappings", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_target_wwn(self, seqid, iprot, oprot):
    args = get_target_wwn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_target_wwn_result()
    try:
      result.success = self._handler.get_target_wwn(args.deviceIp, args.poolType, args.poolId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_target_wwn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_target_wwn(self, seqid, iprot, oprot):
    args = get_all_target_wwn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_target_wwn_result()
    try:
      result.success = self._handler.get_all_target_wwn(args.poolType, args.poolId, args.linkId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_target_wwn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_m_disk(self, seqid, iprot, oprot):
    args = get_m_disk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_m_disk_result()
    try:
      result.success = self._handler.get_m_disk(args.path, args.poolType, args.nodeIp)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_m_disk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_data_for_ams(self, seqid, iprot, oprot):
    args = get_data_for_ams_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_data_for_ams_result()
    try:
      result.success = self._handler.get_data_for_ams(args.kwargs)
    except ncException.ttypes.ncException, error:
      result.error = error
    oprot.writeMessageBegin("get_data_for_ams", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_base_volume_info_by_clone_volume_id(self, seqid, iprot, oprot):
    args = get_base_volume_info_by_clone_volume_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_base_volume_info_by_clone_volume_id_result()
    try:
      result.success = self._handler.get_base_volume_info_by_clone_volume_id(args.clone_volume_id, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_base_volume_info_by_clone_volume_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_base_volume_info_by_snap_volume_id(self, seqid, iprot, oprot):
    args = get_base_volume_info_by_snap_volume_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_base_volume_info_by_snap_volume_id_result()
    try:
      result.success = self._handler.get_base_volume_info_by_snap_volume_id(args.snap_volume_id, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_base_volume_info_by_snap_volume_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_binding_pool_by_snap_volume_id(self, seqid, iprot, oprot):
    args = get_binding_pool_by_snap_volume_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_binding_pool_by_snap_volume_id_result()
    try:
      result.success = self._handler.get_binding_pool_by_snap_volume_id(args.snap_volume_id, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_binding_pool_by_snap_volume_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_base_volume_ids(self, seqid, iprot, oprot):
    args = get_all_base_volume_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_base_volume_ids_result()
    try:
      result.success = self._handler.get_all_base_volume_ids(args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_base_volume_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_clone_volume_ids(self, seqid, iprot, oprot):
    args = get_all_clone_volume_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_clone_volume_ids_result()
    try:
      result.success = self._handler.get_all_clone_volume_ids(args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_clone_volume_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_spaces_by_volumes(self, seqid, iprot, oprot):
    args = get_all_spaces_by_volumes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_spaces_by_volumes_result()
    try:
      result.success = self._handler.get_all_spaces_by_volumes(args.jobVolumeRequestList, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_spaces_by_volumes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_spaces_by_base_volume_id(self, seqid, iprot, oprot):
    args = get_spaces_by_base_volume_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_spaces_by_base_volume_id_result()
    try:
      result.success = self._handler.get_spaces_by_base_volume_id(args.BaseVolumeIdList, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_spaces_by_base_volume_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_spaces(self, seqid, iprot, oprot):
    args = get_all_spaces_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_spaces_result()
    try:
      result.success = self._handler.get_all_spaces(args.jobVolumeRequestList, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_spaces", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_snap_volume_ids(self, seqid, iprot, oprot):
    args = get_all_snap_volume_ids_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_snap_volume_ids_result()
    try:
      result.success = self._handler.get_all_snap_volume_ids(args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_all_snap_volume_ids", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_notify_space_monitor(self, seqid, iprot, oprot):
    args = notify_space_monitor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = notify_space_monitor_result()
    try:
      self._handler.notify_space_monitor()
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("notify_space_monitor", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_node_ip_by_volume_id(self, seqid, iprot, oprot):
    args = get_node_ip_by_volume_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_node_ip_by_volume_id_result()
    try:
      result.success = self._handler.get_node_ip_by_volume_id(args.volumeId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_node_ip_by_volume_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_server_ip_by_pool_id(self, seqid, iprot, oprot):
    args = get_server_ip_by_pool_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_server_ip_by_pool_id_result()
    try:
      result.success = self._handler.get_server_ip_by_pool_id(args.poolId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_server_ip_by_pool_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_snapshot_volume_sync(self, seqid, iprot, oprot):
    args = snapshot_volume_sync_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = snapshot_volume_sync_result()
    try:
      result.success = self._handler.snapshot_volume_sync(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("snapshot_volume_sync", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stop_snapshot_volume_sync(self, seqid, iprot, oprot):
    args = stop_snapshot_volume_sync_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stop_snapshot_volume_sync_result()
    try:
      self._handler.stop_snapshot_volume_sync(args.snapshotVolumeSyncId, args.srcSnapshotPoolId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("stop_snapshot_volume_sync", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_snapshot_volume_sync_status(self, seqid, iprot, oprot):
    args = get_snapshot_volume_sync_status_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_snapshot_volume_sync_status_result()
    try:
      result.success = self._handler.get_snapshot_volume_sync_status(args.snapshotVolumeSyncId, args.srcSnapshotPoolId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_snapshot_volume_sync_status", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_finish_snapshot_volume_sync(self, seqid, iprot, oprot):
    args = finish_snapshot_volume_sync_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = finish_snapshot_volume_sync_result()
    try:
      result.success = self._handler.finish_snapshot_volume_sync(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("finish_snapshot_volume_sync", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_finish_snyc_work(self, seqid, iprot, oprot):
    args = finish_snyc_work_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = finish_snyc_work_result()
    try:
      result.success = self._handler.finish_snyc_work(args.request)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("finish_snyc_work", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_data_ip_by_pool_id(self, seqid, iprot, oprot):
    args = get_data_ip_by_pool_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_data_ip_by_pool_id_result()
    try:
      result.success = self._handler.get_data_ip_by_pool_id(args.poolId, args.poolType)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_data_ip_by_pool_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_link_info(self, seqid, iprot, oprot):
    args = get_link_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_link_info_result()
    try:
      result.success = self._handler.get_link_info(args.linkId)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("get_link_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_select_link(self, seqid, iprot, oprot):
    args = select_link_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = select_link_result()
    try:
      result.success = self._handler.select_link(args.request, args.num)
    except ncException.ttypes.ncException, exp:
      result.exp = exp
    oprot.writeMessageBegin("select_link", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class Microprobe_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Microprobe_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Microprobe_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Microprobe_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_args(object):
  """
  Attributes:
   - volume_name
   - volume_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volume_name', None, None, ), # 1
    (2, TType.I32, 'volume_type', None, None, ), # 2
  )

  def __init__(self, volume_name=None, volume_type=None,):
    self.volume_name = volume_name
    self.volume_type = volume_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volume_name = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volume_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_args')
    if self.volume_name is not None:
      oprot.writeFieldBegin('volume_name', TType.STRING, 1)
      oprot.writeString(self.volume_name.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.volume_type is not None:
      oprot.writeFieldBegin('volume_type', TType.I32, 2)
      oprot.writeI32(self.volume_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volume_name)
    value = (value * 31) ^ hash(self.volume_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo, ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_by_id_args(object):
  """
  Attributes:
   - volume_id
   - volume_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volume_id', None, None, ), # 1
    (2, TType.I32, 'volume_type', None, None, ), # 2
  )

  def __init__(self, volume_id=None, volume_type=None,):
    self.volume_id = volume_id
    self.volume_type = volume_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volume_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.volume_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_by_id_args')
    if self.volume_id is not None:
      oprot.writeFieldBegin('volume_id', TType.STRING, 1)
      oprot.writeString(self.volume_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.volume_type is not None:
      oprot.writeFieldBegin('volume_type', TType.I32, 2)
      oprot.writeI32(self.volume_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volume_id)
    value = (value * 31) ^ hash(self.volume_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_by_id_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo, ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncGetVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_pool_args(object):
  """
  Attributes:
   - poolId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'poolId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, poolId=None, poolType=None,):
    self.poolId = poolId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_pool_args')
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 1)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_pool_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncTPool, ncCdmStoreMgmProto.ttypes.ncTPool.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncTPool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_pool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_pools_args(object):
  """
  Attributes:
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'poolType', None, None, ), # 1
  )

  def __init__(self, poolType=None,):
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_pools_args')
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 1)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_pools_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncTPool, ncCdmStoreMgmProto.ttypes.ncTPool.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = ncCdmStoreMgmProto.ttypes.ncTPool()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_pools_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_base_volume_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncCreateBaseVolumeRequest, ncCdmStoreMgmProto.ttypes.ncCreateBaseVolumeRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncCreateBaseVolumeRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_base_volume_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_base_volume_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_base_volume_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_base_volumes_args(object):
  """
  Attributes:
   - baseVolumeIds
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'baseVolumeIds', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, baseVolumeIds=None, poolType=None,):
    self.baseVolumeIds = baseVolumeIds
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.baseVolumeIds = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString().decode('utf-8')
            self.baseVolumeIds.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_base_volumes_args')
    if self.baseVolumeIds is not None:
      oprot.writeFieldBegin('baseVolumeIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.baseVolumeIds))
      for iter13 in self.baseVolumeIds:
        oprot.writeString(iter13.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseVolumeIds)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_base_volumes_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_base_volumes_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_space_args(object):
  """
  Attributes:
   - baseVolumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'baseVolumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, baseVolumeId=None, poolType=None,):
    self.baseVolumeId = baseVolumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.baseVolumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_space_args')
    if self.baseVolumeId is not None:
      oprot.writeFieldBegin('baseVolumeId', TType.STRING, 1)
      oprot.writeString(self.baseVolumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseVolumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_space_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeSpace, ncCdmStoreMgmProto.ttypes.ncVolumeSpace.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_space_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_snap_volume_args(object):
  """
  Attributes:
   - baseVolumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'baseVolumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, baseVolumeId=None, poolType=None,):
    self.baseVolumeId = baseVolumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.baseVolumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_snap_volume_args')
    if self.baseVolumeId is not None:
      oprot.writeFieldBegin('baseVolumeId', TType.STRING, 1)
      oprot.writeString(self.baseVolumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseVolumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_snap_volume_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail, ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_snap_volume_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_snap_volumes_args(object):
  """
  Attributes:
   - snapVolumeIds
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'snapVolumeIds', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, snapVolumeIds=None, poolType=None,):
    self.snapVolumeIds = snapVolumeIds
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.snapVolumeIds = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString().decode('utf-8')
            self.snapVolumeIds.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_snap_volumes_args')
    if self.snapVolumeIds is not None:
      oprot.writeFieldBegin('snapVolumeIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.snapVolumeIds))
      for iter20 in self.snapVolumeIds:
        oprot.writeString(iter20.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapVolumeIds)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_snap_volumes_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_snap_volumes_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_snap_volume_space_args(object):
  """
  Attributes:
   - snapVolumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snapVolumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, snapVolumeId=None, poolType=None,):
    self.snapVolumeId = snapVolumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snapVolumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_snap_volume_space_args')
    if self.snapVolumeId is not None:
      oprot.writeFieldBegin('snapVolumeId', TType.STRING, 1)
      oprot.writeString(self.snapVolumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapVolumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_snap_volume_space_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeSpace, ncCdmStoreMgmProto.ttypes.ncVolumeSpace.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_snap_volume_space_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_clone_volume_args(object):
  """
  Attributes:
   - snapVolumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snapVolumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, snapVolumeId=None, poolType=None,):
    self.snapVolumeId = snapVolumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snapVolumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_clone_volume_args')
    if self.snapVolumeId is not None:
      oprot.writeFieldBegin('snapVolumeId', TType.STRING, 1)
      oprot.writeString(self.snapVolumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapVolumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_clone_volume_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_clone_volume_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_clone_volumes_args(object):
  """
  Attributes:
   - cloneVolumeIds
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'cloneVolumeIds', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, cloneVolumeIds=None, poolType=None,):
    self.cloneVolumeIds = cloneVolumeIds
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.cloneVolumeIds = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString().decode('utf-8')
            self.cloneVolumeIds.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_clone_volumes_args')
    if self.cloneVolumeIds is not None:
      oprot.writeFieldBegin('cloneVolumeIds', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.cloneVolumeIds))
      for iter27 in self.cloneVolumeIds:
        oprot.writeString(iter27.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cloneVolumeIds)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_clone_volumes_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_clone_volumes_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_clone_volume_space_args(object):
  """
  Attributes:
   - cloneVolumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cloneVolumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, cloneVolumeId=None, poolType=None,):
    self.cloneVolumeId = cloneVolumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cloneVolumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_clone_volume_space_args')
    if self.cloneVolumeId is not None:
      oprot.writeFieldBegin('cloneVolumeId', TType.STRING, 1)
      oprot.writeString(self.cloneVolumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cloneVolumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_clone_volume_space_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeSpace, ncCdmStoreMgmProto.ttypes.ncVolumeSpace.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeSpace()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_clone_volume_space_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_volume_mapping_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest, ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_volume_mapping_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_volume_mapping_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo, ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_volume_mapping_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_volume_mapping_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest, ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_volume_mapping_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_volume_mapping_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_volume_mapping_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class async_create_volume_mappings_args(object):
  """
  Attributes:
   - requests
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'requests', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest, ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, requests=None, jobId=None,):
    self.requests = requests
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.requests = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = ncCdmStoreMgmProto.ttypes.ncCreateVolumeMappingRequest()
            _elem33.read(iprot)
            self.requests.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('async_create_volume_mappings_args')
    if self.requests is not None:
      oprot.writeFieldBegin('requests', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.requests))
      for iter34 in self.requests:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requests)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class async_create_volume_mappings_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('async_create_volume_mappings_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_create_volume_mappings_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest, ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_create_volume_mappings_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_create_volume_mappings_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncQueryCreateMappingResponse, ncCdmStoreMgmProto.ttypes.ncQueryCreateMappingResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncQueryCreateMappingResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_create_volume_mappings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class async_delete_volume_mappings_args(object):
  """
  Attributes:
   - requests
   - jobId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'requests', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest, ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'jobId', None, None, ), # 2
  )

  def __init__(self, requests=None, jobId=None,):
    self.requests = requests
    self.jobId = jobId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.requests = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = ncCdmStoreMgmProto.ttypes.ncDeleteVolumeMappingRequest()
            _elem40.read(iprot)
            self.requests.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('async_delete_volume_mappings_args')
    if self.requests is not None:
      oprot.writeFieldBegin('requests', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.requests))
      for iter41 in self.requests:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.jobId is not None:
      oprot.writeFieldBegin('jobId', TType.STRING, 2)
      oprot.writeString(self.jobId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.requests)
    value = (value * 31) ^ hash(self.jobId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class async_delete_volume_mappings_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('async_delete_volume_mappings_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_delete_volume_mappings_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest, ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncQueryMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_delete_volume_mappings_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class query_delete_volume_mappings_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncQueryDelMappingResponse, ncCdmStoreMgmProto.ttypes.ncQueryDelMappingResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncQueryDelMappingResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('query_delete_volume_mappings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_mappings_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncGetVolumeMappingRequest, ncCdmStoreMgmProto.ttypes.ncGetVolumeMappingRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncGetVolumeMappingRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_mappings_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_volume_mappings_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo, ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = ncCdmStoreMgmProto.ttypes.ncVolumeMapInfo()
            _elem47.read(iprot)
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_volume_mappings_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter48 in self.success:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_target_wwn_args(object):
  """
  Attributes:
   - deviceIp
   - poolType
   - poolId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceIp', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
    (3, TType.STRING, 'poolId', None, None, ), # 3
  )

  def __init__(self, deviceIp=None, poolType=None, poolId=None,):
    self.deviceIp = deviceIp
    self.poolType = poolType
    self.poolId = poolId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_target_wwn_args')
    if self.deviceIp is not None:
      oprot.writeFieldBegin('deviceIp', TType.STRING, 1)
      oprot.writeString(self.deviceIp.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 3)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.deviceIp)
    value = (value * 31) ^ hash(self.poolType)
    value = (value * 31) ^ hash(self.poolId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_target_wwn_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_target_wwn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_target_wwn_args(object):
  """
  Attributes:
   - poolType
   - poolId
   - linkId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'poolType', None, None, ), # 1
    (2, TType.STRING, 'poolId', None, None, ), # 2
    (3, TType.STRING, 'linkId', None, None, ), # 3
  )

  def __init__(self, poolType=None, poolId=None, linkId=None,):
    self.poolType = poolType
    self.poolId = poolId
    self.linkId = linkId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.linkId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_target_wwn_args')
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 1)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 2)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.linkId is not None:
      oprot.writeFieldBegin('linkId', TType.STRING, 3)
      oprot.writeString(self.linkId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolType)
    value = (value * 31) ^ hash(self.poolId)
    value = (value * 31) ^ hash(self.linkId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_target_wwn_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncGetTargetWwnInfo, ncCdmStoreMgmProto.ttypes.ncGetTargetWwnInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = ncCdmStoreMgmProto.ttypes.ncGetTargetWwnInfo()
            _elem54.read(iprot)
            self.success.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_target_wwn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter55 in self.success:
        iter55.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_m_disk_args(object):
  """
  Attributes:
   - path
   - poolType
   - nodeIp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
    (3, TType.STRING, 'nodeIp', None, None, ), # 3
  )

  def __init__(self, path=None, poolType=None, nodeIp=None,):
    self.path = path
    self.poolType = poolType
    self.nodeIp = nodeIp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nodeIp = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_m_disk_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    if self.nodeIp is not None:
      oprot.writeFieldBegin('nodeIp', TType.STRING, 3)
      oprot.writeString(self.nodeIp.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.path)
    value = (value * 31) ^ hash(self.poolType)
    value = (value * 31) ^ hash(self.nodeIp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_m_disk_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_m_disk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_args(object):
  """
  Attributes:
   - kwargs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'kwargs', None, None, ), # 1
  )

  def __init__(self, kwargs=None,):
    self.kwargs = kwargs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.kwargs = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_args')
    if self.kwargs is not None:
      oprot.writeFieldBegin('kwargs', TType.STRING, 1)
      oprot.writeString(self.kwargs.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.kwargs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_for_ams_result(object):
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'error', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, error=None,):
    self.success = success
    self.error = error

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = ncException.ttypes.ncException()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_for_ams_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.error is not None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.error)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_info_by_clone_volume_id_args(object):
  """
  Attributes:
   - clone_volume_id
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clone_volume_id', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, clone_volume_id=None, poolType=None,):
    self.clone_volume_id = clone_volume_id
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clone_volume_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_info_by_clone_volume_id_args')
    if self.clone_volume_id is not None:
      oprot.writeFieldBegin('clone_volume_id', TType.STRING, 1)
      oprot.writeString(self.clone_volume_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clone_volume_id)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_info_by_clone_volume_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_info_by_clone_volume_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_info_by_snap_volume_id_args(object):
  """
  Attributes:
   - snap_volume_id
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snap_volume_id', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, snap_volume_id=None, poolType=None,):
    self.snap_volume_id = snap_volume_id
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snap_volume_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_info_by_snap_volume_id_args')
    if self.snap_volume_id is not None:
      oprot.writeFieldBegin('snap_volume_id', TType.STRING, 1)
      oprot.writeString(self.snap_volume_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_volume_id)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_base_volume_info_by_snap_volume_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_base_volume_info_by_snap_volume_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_binding_pool_by_snap_volume_id_args(object):
  """
  Attributes:
   - snap_volume_id
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snap_volume_id', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, snap_volume_id=None, poolType=None,):
    self.snap_volume_id = snap_volume_id
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snap_volume_id = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_binding_pool_by_snap_volume_id_args')
    if self.snap_volume_id is not None:
      oprot.writeFieldBegin('snap_volume_id', TType.STRING, 1)
      oprot.writeString(self.snap_volume_id.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snap_volume_id)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_binding_pool_by_snap_volume_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncTPool, ncCdmStoreMgmProto.ttypes.ncTPool.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncTPool()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_binding_pool_by_snap_volume_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_base_volume_ids_args(object):
  """
  Attributes:
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'poolType', None, None, ), # 1
  )

  def __init__(self, poolType=None,):
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_base_volume_ids_args')
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 1)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_base_volume_ids_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
            _elem61.read(iprot)
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_base_volume_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter62 in self.success:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_clone_volume_ids_args(object):
  """
  Attributes:
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'poolType', None, None, ), # 1
  )

  def __init__(self, poolType=None,):
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_clone_volume_ids_args')
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 1)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_clone_volume_ids_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
            _elem68.read(iprot)
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_clone_volume_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter69 in self.success:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_spaces_by_volumes_args(object):
  """
  Attributes:
   - jobVolumeRequestList
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'jobVolumeRequestList', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest.thrift_spec)), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, jobVolumeRequestList=None, poolType=None,):
    self.jobVolumeRequestList = jobVolumeRequestList
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.jobVolumeRequestList = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
            _elem75.read(iprot)
            self.jobVolumeRequestList.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_spaces_by_volumes_args')
    if self.jobVolumeRequestList is not None:
      oprot.writeFieldBegin('jobVolumeRequestList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.jobVolumeRequestList))
      for iter76 in self.jobVolumeRequestList:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobVolumeRequestList)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_spaces_by_volumes_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_spaces_by_volumes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_spaces_by_base_volume_id_args(object):
  """
  Attributes:
   - BaseVolumeIdList
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'BaseVolumeIdList', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest.thrift_spec)), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, BaseVolumeIdList=None, poolType=None,):
    self.BaseVolumeIdList = BaseVolumeIdList
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.BaseVolumeIdList = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
            _elem82.read(iprot)
            self.BaseVolumeIdList.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_spaces_by_base_volume_id_args')
    if self.BaseVolumeIdList is not None:
      oprot.writeFieldBegin('BaseVolumeIdList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.BaseVolumeIdList))
      for iter83 in self.BaseVolumeIdList:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.BaseVolumeIdList)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_spaces_by_base_volume_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_spaces_by_base_volume_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_spaces_args(object):
  """
  Attributes:
   - jobVolumeRequestList
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'jobVolumeRequestList', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest, ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest.thrift_spec)), None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, jobVolumeRequestList=None, poolType=None,):
    self.jobVolumeRequestList = jobVolumeRequestList
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.jobVolumeRequestList = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = ncCdmStoreMgmProto.ttypes.ncJobVolumeRequest()
            _elem89.read(iprot)
            self.jobVolumeRequestList.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_spaces_args')
    if self.jobVolumeRequestList is not None:
      oprot.writeFieldBegin('jobVolumeRequestList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.jobVolumeRequestList))
      for iter90 in self.jobVolumeRequestList:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobVolumeRequestList)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_spaces_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_spaces_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_snap_volume_ids_args(object):
  """
  Attributes:
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'poolType', None, None, ), # 1
  )

  def __init__(self, poolType=None,):
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_snap_volume_ids_args')
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 1)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_snap_volume_ids_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmProto.ttypes.ncVolumeInfo, ncCdmStoreMgmProto.ttypes.ncVolumeInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = ncCdmStoreMgmProto.ttypes.ncVolumeInfo()
            _elem96.read(iprot)
            self.success.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_snap_volume_ids_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter97 in self.success:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class notify_space_monitor_args(object):

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('notify_space_monitor_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class notify_space_monitor_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('notify_space_monitor_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_ip_by_volume_id_args(object):
  """
  Attributes:
   - volumeId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'volumeId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, volumeId=None, poolType=None,):
    self.volumeId = volumeId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.volumeId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_ip_by_volume_id_args')
    if self.volumeId is not None:
      oprot.writeFieldBegin('volumeId', TType.STRING, 1)
      oprot.writeString(self.volumeId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.volumeId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_ip_by_volume_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_ip_by_volume_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_server_ip_by_pool_id_args(object):
  """
  Attributes:
   - poolId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'poolId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, poolId=None, poolType=None,):
    self.poolId = poolId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_server_ip_by_pool_id_args')
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 1)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_server_ip_by_pool_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_server_ip_by_pool_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_volume_sync_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest, ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_volume_sync_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class snapshot_volume_sync_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncReply, ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncReply.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncReply()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('snapshot_volume_sync_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_snapshot_volume_sync_args(object):
  """
  Attributes:
   - snapshotVolumeSyncId
   - srcSnapshotPoolId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snapshotVolumeSyncId', None, None, ), # 1
    (2, TType.STRING, 'srcSnapshotPoolId', None, None, ), # 2
  )

  def __init__(self, snapshotVolumeSyncId=None, srcSnapshotPoolId=None,):
    self.snapshotVolumeSyncId = snapshotVolumeSyncId
    self.srcSnapshotPoolId = srcSnapshotPoolId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snapshotVolumeSyncId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.srcSnapshotPoolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_snapshot_volume_sync_args')
    if self.snapshotVolumeSyncId is not None:
      oprot.writeFieldBegin('snapshotVolumeSyncId', TType.STRING, 1)
      oprot.writeString(self.snapshotVolumeSyncId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.srcSnapshotPoolId is not None:
      oprot.writeFieldBegin('srcSnapshotPoolId', TType.STRING, 2)
      oprot.writeString(self.srcSnapshotPoolId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapshotVolumeSyncId)
    value = (value * 31) ^ hash(self.srcSnapshotPoolId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stop_snapshot_volume_sync_result(object):
  """
  Attributes:
   - exp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, exp=None,):
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stop_snapshot_volume_sync_result')
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_snapshot_volume_sync_status_args(object):
  """
  Attributes:
   - snapshotVolumeSyncId
   - srcSnapshotPoolId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'snapshotVolumeSyncId', None, None, ), # 1
    (2, TType.STRING, 'srcSnapshotPoolId', None, None, ), # 2
  )

  def __init__(self, snapshotVolumeSyncId=None, srcSnapshotPoolId=None,):
    self.snapshotVolumeSyncId = snapshotVolumeSyncId
    self.srcSnapshotPoolId = srcSnapshotPoolId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.snapshotVolumeSyncId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.srcSnapshotPoolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_snapshot_volume_sync_status_args')
    if self.snapshotVolumeSyncId is not None:
      oprot.writeFieldBegin('snapshotVolumeSyncId', TType.STRING, 1)
      oprot.writeString(self.snapshotVolumeSyncId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.srcSnapshotPoolId is not None:
      oprot.writeFieldBegin('srcSnapshotPoolId', TType.STRING, 2)
      oprot.writeString(self.srcSnapshotPoolId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.snapshotVolumeSyncId)
    value = (value * 31) ^ hash(self.srcSnapshotPoolId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_snapshot_volume_sync_status_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncSnapStoreProto.ttypes.ncSyncSnapVolumeProgress, ncSnapStoreProto.ttypes.ncSyncSnapVolumeProgress.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncSnapStoreProto.ttypes.ncSyncSnapVolumeProgress()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_snapshot_volume_sync_status_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class finish_snapshot_volume_sync_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest, ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncSnapshotVolumeSyncRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('finish_snapshot_volume_sync_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class finish_snapshot_volume_sync_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('finish_snapshot_volume_sync_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class finish_snyc_work_args(object):
  """
  Attributes:
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail, ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail.thrift_spec), None, ), # 1
  )

  def __init__(self, request=None,):
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncSnapVolumeDetail()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('finish_snyc_work_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class finish_snyc_work_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('finish_snyc_work_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_ip_by_pool_id_args(object):
  """
  Attributes:
   - poolId
   - poolType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'poolId', None, None, ), # 1
    (2, TType.I32, 'poolType', None, None, ), # 2
  )

  def __init__(self, poolId=None, poolType=None,):
    self.poolId = poolId
    self.poolType = poolType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.poolId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.poolType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_ip_by_pool_id_args')
    if self.poolId is not None:
      oprot.writeFieldBegin('poolId', TType.STRING, 1)
      oprot.writeString(self.poolId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.poolType is not None:
      oprot.writeFieldBegin('poolType', TType.I32, 2)
      oprot.writeI32(self.poolType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.poolId)
    value = (value * 31) ^ hash(self.poolType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_data_ip_by_pool_id_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_data_ip_by_pool_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_link_info_args(object):
  """
  Attributes:
   - linkId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'linkId', None, None, ), # 1
  )

  def __init__(self, linkId=None,):
    self.linkId = linkId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.linkId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_link_info_args')
    if self.linkId is not None:
      oprot.writeFieldBegin('linkId', TType.STRING, 1)
      oprot.writeString(self.linkId.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.linkId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_link_info_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ncCdmStoreMgmCommon.ttypes.ncLinkInfo, ncCdmStoreMgmCommon.ttypes.ncLinkInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_link_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class select_link_args(object):
  """
  Attributes:
   - request
   - num
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'request', (ncCdmStoreMgmProto.ttypes.ncSelectLinkRequest, ncCdmStoreMgmProto.ttypes.ncSelectLinkRequest.thrift_spec), None, ), # 1
    (2, TType.I32, 'num', None, 1, ), # 2
  )

  def __init__(self, request=None, num=thrift_spec[2][4],):
    self.request = request
    self.num = num

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.request = ncCdmStoreMgmProto.ttypes.ncSelectLinkRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.num = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('select_link_args')
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 1)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    if self.num is not None:
      oprot.writeFieldBegin('num', TType.I32, 2)
      oprot.writeI32(self.num)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.request)
    value = (value * 31) ^ hash(self.num)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class select_link_result(object):
  """
  Attributes:
   - success
   - exp
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ncCdmStoreMgmCommon.ttypes.ncLinkInfo, ncCdmStoreMgmCommon.ttypes.ncLinkInfo.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'exp', (ncException.ttypes.ncException, ncException.ttypes.ncException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, exp=None,):
    self.success = success
    self.exp = exp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = ncCdmStoreMgmCommon.ttypes.ncLinkInfo()
            _elem103.read(iprot)
            self.success.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.exp = ncException.ttypes.ncException()
          self.exp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('select_link_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter104 in self.success:
        iter104.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.exp is not None:
      oprot.writeFieldBegin('exp', TType.STRUCT, 1)
      self.exp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.exp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
