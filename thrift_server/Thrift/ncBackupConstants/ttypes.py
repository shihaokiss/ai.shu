#
# -*- coding:utf-8 -*-
#
# Autogenerated by Thrift Compiler (1.0.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:coding=utf-8,new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ncFilterTypeEnum(object):
  """
  筛选类型

  目前有4中筛选类型
  """
  FILE = 1
  DIRECTORY = 2
  FORMAT = 3
  DATETIME = 4

  _VALUES_TO_NAMES = {
    1: "FILE",
    2: "DIRECTORY",
    3: "FORMAT",
    4: "DATETIME",
  }

  _NAMES_TO_VALUES = {
    "FILE": 1,
    "DIRECTORY": 2,
    "FORMAT": 3,
    "DATETIME": 4,
  }

class ncFilterModeEnum(object):
  """
  筛选方式(模式)

  排除
  仅包含
  """
  EXCLUDE = 1
  ONLY_CONTAIN = 2

  _VALUES_TO_NAMES = {
    1: "EXCLUDE",
    2: "ONLY_CONTAIN",
  }

  _NAMES_TO_VALUES = {
    "EXCLUDE": 1,
    "ONLY_CONTAIN": 2,
  }

class ncFileFormatEnum(object):
  """
  筛选格式(大类分类)

  """
  MS_OFFICE = 1
  MUSIC_AND_VIDEO = 2
  PICTURE = 3
  PDF = 4
  WEB = 5
  COMPRESSION = 6
  USR_FORMAT = 7

  _VALUES_TO_NAMES = {
    1: "MS_OFFICE",
    2: "MUSIC_AND_VIDEO",
    3: "PICTURE",
    4: "PDF",
    5: "WEB",
    6: "COMPRESSION",
    7: "USR_FORMAT",
  }

  _NAMES_TO_VALUES = {
    "MS_OFFICE": 1,
    "MUSIC_AND_VIDEO": 2,
    "PICTURE": 3,
    "PDF": 4,
    "WEB": 5,
    "COMPRESSION": 6,
    "USR_FORMAT": 7,
  }

class ncTimeTypeEnum(object):
  """
  时间类型
  """
  CREATE_TIME = 1
  LAST_MODIFICATION_TIME = 2
  LAST_ACCESS_TIME = 3

  _VALUES_TO_NAMES = {
    1: "CREATE_TIME",
    2: "LAST_MODIFICATION_TIME",
    3: "LAST_ACCESS_TIME",
  }

  _NAMES_TO_VALUES = {
    "CREATE_TIME": 1,
    "LAST_MODIFICATION_TIME": 2,
    "LAST_ACCESS_TIME": 3,
  }

class ncTargetFileSystemEnum(object):
  HDFS = 0
  EXTX = 1
  NTFS = 2

  _VALUES_TO_NAMES = {
    0: "HDFS",
    1: "EXTX",
    2: "NTFS",
  }

  _NAMES_TO_VALUES = {
    "HDFS": 0,
    "EXTX": 1,
    "NTFS": 2,
  }

class ncReplaceStrategyEnum(object):
  ALWAYS = 0
  ONLY_OLD = 1
  DO_NOT = 2

  _VALUES_TO_NAMES = {
    0: "ALWAYS",
    1: "ONLY_OLD",
    2: "DO_NOT",
  }

  _NAMES_TO_VALUES = {
    "ALWAYS": 0,
    "ONLY_OLD": 1,
    "DO_NOT": 2,
  }

class ncDataProduceTypeEnum(object):
  LOCAL_BACKUP = 1
  REMOTE_COPY_DATA_SYNC = 2
  REMOTE_COPY_REVERSE_COPY = 3
  D2C = 4

  _VALUES_TO_NAMES = {
    1: "LOCAL_BACKUP",
    2: "REMOTE_COPY_DATA_SYNC",
    3: "REMOTE_COPY_REVERSE_COPY",
    4: "D2C",
  }

  _NAMES_TO_VALUES = {
    "LOCAL_BACKUP": 1,
    "REMOTE_COPY_DATA_SYNC": 2,
    "REMOTE_COPY_REVERSE_COPY": 3,
    "D2C": 4,
  }

class ncLinkVolumeMappingStatusEnum(object):
  """
  任务链路创建卷映射的状态
  """
  TRIGGER_LINK_READY = 0
  TRIGGER_LINK_CREATE = 1
  TRIGGER_LINK_DELETE = 2

  _VALUES_TO_NAMES = {
    0: "TRIGGER_LINK_READY",
    1: "TRIGGER_LINK_CREATE",
    2: "TRIGGER_LINK_DELETE",
  }

  _NAMES_TO_VALUES = {
    "TRIGGER_LINK_READY": 0,
    "TRIGGER_LINK_CREATE": 1,
    "TRIGGER_LINK_DELETE": 2,
  }

class ncChannelVolumeMappingStatusEnum(object):
  """
  创建/删除卷映射的状态
  """
  VOLUME_MAPPING_READY = 0
  VOLUME_MAPPING_DOING = 1
  VOLUME_MAPPING_SUCC = 2
  VOLUME_MAPPING_FAILE = 3

  _VALUES_TO_NAMES = {
    0: "VOLUME_MAPPING_READY",
    1: "VOLUME_MAPPING_DOING",
    2: "VOLUME_MAPPING_SUCC",
    3: "VOLUME_MAPPING_FAILE",
  }

  _NAMES_TO_VALUES = {
    "VOLUME_MAPPING_READY": 0,
    "VOLUME_MAPPING_DOING": 1,
    "VOLUME_MAPPING_SUCC": 2,
    "VOLUME_MAPPING_FAILE": 3,
  }


class ncEEFCreateBackupLunMapping(object):
  """
  Lan-Free创建卷映射请求参数

  Attributes:
   - clientid
   - serverid
   - execid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientid', None, None, ), # 1
    (2, TType.STRING, 'serverid', None, None, ), # 2
    (3, TType.STRING, 'execid', None, None, ), # 3
  )

  def __init__(self, clientid=None, serverid=None, execid=None,):
    self.clientid = clientid
    self.serverid = serverid
    self.execid = execid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serverid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.execid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCreateBackupLunMapping')
    if self.clientid is not None:
      oprot.writeFieldBegin('clientid', TType.STRING, 1)
      oprot.writeString(self.clientid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.serverid is not None:
      oprot.writeFieldBegin('serverid', TType.STRING, 2)
      oprot.writeString(self.serverid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.execid is not None:
      oprot.writeFieldBegin('execid', TType.STRING, 3)
      oprot.writeString(self.execid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientid)
    value = (value * 31) ^ hash(self.serverid)
    value = (value * 31) ^ hash(self.execid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFCreateBackupLunMappingParams(object):
  """
  Lan-Free创建卷映射返回信息

  Attributes:
   - initiatorPortName_
   - targetPortName_
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'initiatorPortName_', None, None, ), # 1
    (2, TType.STRING, 'targetPortName_', None, None, ), # 2
  )

  def __init__(self, initiatorPortName_=None, targetPortName_=None,):
    self.initiatorPortName_ = initiatorPortName_
    self.targetPortName_ = targetPortName_

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.initiatorPortName_ = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.targetPortName_ = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFCreateBackupLunMappingParams')
    if self.initiatorPortName_ is not None:
      oprot.writeFieldBegin('initiatorPortName_', TType.STRING, 1)
      oprot.writeString(self.initiatorPortName_.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.targetPortName_ is not None:
      oprot.writeFieldBegin('targetPortName_', TType.STRING, 2)
      oprot.writeString(self.targetPortName_.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.initiatorPortName_)
    value = (value * 31) ^ hash(self.targetPortName_)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFDeleteBackupLunMapping(object):
  """
  Lan-Free删除卷映射请求参数

  Attributes:
   - clientid
   - serverid
   - execid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientid', None, None, ), # 1
    (2, TType.STRING, 'serverid', None, None, ), # 2
    (3, TType.STRING, 'execid', None, None, ), # 3
  )

  def __init__(self, clientid=None, serverid=None, execid=None,):
    self.clientid = clientid
    self.serverid = serverid
    self.execid = execid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serverid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.execid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFDeleteBackupLunMapping')
    if self.clientid is not None:
      oprot.writeFieldBegin('clientid', TType.STRING, 1)
      oprot.writeString(self.clientid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.serverid is not None:
      oprot.writeFieldBegin('serverid', TType.STRING, 2)
      oprot.writeString(self.serverid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.execid is not None:
      oprot.writeFieldBegin('execid', TType.STRING, 3)
      oprot.writeString(self.execid.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.clientid)
    value = (value * 31) ^ hash(self.serverid)
    value = (value * 31) ^ hash(self.execid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ncEEFDeleteBackupLunMappingParams(object):
  """
  Lan-Free删除卷映射返回信息

  Attributes:
   - isSuccess
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'isSuccess', None, None, ), # 1
  )

  def __init__(self, isSuccess=None,):
    self.isSuccess = isSuccess

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.isSuccess = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ncEEFDeleteBackupLunMappingParams')
    if self.isSuccess is not None:
      oprot.writeFieldBegin('isSuccess', TType.STRING, 1)
      oprot.writeString(self.isSuccess.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.isSuccess)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
